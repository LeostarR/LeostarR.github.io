<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/30/0hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 2</title>
    <url>/2023/04/14/2Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%202/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第二单元作业的基本训练目标是模拟<strong>多线程实时电梯系统</strong>，三次作业为迭代开发。</p>
<ul>
<li>第一次作业要求设计一个具有功能为上下行，开关门，以及模拟乘客进出的电梯系统，目标是让我们熟悉线程的创建、运行等基本操作，熟悉多线程程序的设计方法；</li>
<li>第二次作业新增加了模拟电梯系统扩建和日常维护时乘客的调度的功能，目标是让我们掌握线程安全知识并解决线程安全问题，同时在架构上围绕线程之间的协同设计层次架构；</li>
<li>第三次作业新增电梯系统调度参数，具体来说是对每一层楼正处于开门状态的电梯数量加以限制，同时电梯不一定满足每层楼可达， 目标是让我们掌握线程之间的交互，强化线程之间的协同设计层次架构。</li>
</ul>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业需要完成这些工作：</p>
<ol>
<li>设计一个<strong>队列</strong>类，用于进行乘客进入/移除，同时还需有判断是否为空/是否结束和设定结束等方法</li>
<li>设计一个<strong>调度器</strong>类，作为总等候队列与电梯之间的桥梁，需要完成对乘客的分配工作</li>
<li>设计一个<strong>电梯</strong>类，能够完成题目要求的任务</li>
<li>在<code>Main</code>中启动调度器线程和电梯线程，并将输入（如果有）送给总等候队列，结束时将等候队列设定结束</li>
</ol>
<blockquote>
<p>说明：本次作业课程组已经为我们提供了输入输出的接口，因此不再考虑解析输入的请求和格式化时间戳输出。</p>
</blockquote>
<h4 id="队列类"><a href="#队列类" class="headerlink" title="队列类"></a>队列类</h4><h5 id="PassengerQueue"><a href="#PassengerQueue" class="headerlink" title="PassengerQueue:"></a><code>PassengerQueue</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec5ffb.png"></p>
<p> <code>addPassenger(Passenger)</code>和<code>removePassenger(Passenger)</code>用于添加和移除乘客，<code>getOnePassenger()</code>用于分配乘客时按时间先后取出，<code>setEnd(boolean)</code>用于设定队列结束。其他方法用于返回该队列的一些属性，例如是否结束，是否为空以及队列所有乘客组成的集合(<code>ArrayList&lt;Passenger&gt;</code>)。</p>
<h4 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a><strong>调度器类</strong></h4><h5 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a><code>Controller</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec46f8.png"></p>
<p>重写了<code>run()</code>方法将乘客分配。</p>
<p>分配策略：采取均匀分配的策略。按照乘客到来的时间先后顺序将总等候队列中的乘客均匀分配给电梯的等候队列。（<del>所以性能不好<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 600 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Missing superscript or subscript argument" title="Missing superscript or subscript argument"><rect data-background="true" width="600" height="950" y="-200"></rect><title>Missing superscript or subscript argument</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">_</text></g></g></g></g></svg></mjx-container></del>)</p>
<p>一个示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*结束条件*/</span>) {</span><br><span class="line">            <span class="comment">//将所有电梯等候队列设为结束//</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> waitQueue.getOnePassenger()<span class="comment">//按时间顺序取出//;</span></span><br><span class="line">        <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        elevatorQueues.get(<span class="comment">/*index*/</span>).addPassenger(passenger);<span class="comment">//分配</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="电梯类："><a href="#电梯类：" class="headerlink" title="电梯类："></a>电梯类：</h4><h5 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator:"></a><code>Elevator</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec47c9.png"></p>
<p> 重写了<code>run()</code>方法使电梯运行，总的模式是这样的：根据等候队列中的顺序，确定主请求然后将主请求的乘客送到目的地。在这个过程中分为接主请求乘客和送主请求乘客两部分，这两个过程中在未超载（主请求计算在内）且运行方向相同的情况下可进行捎带。在每一个主请求到达的时候将电梯内部先到的乘客确定为主请求，继续运行直至电梯内部为空，再从等候队列中取出乘客。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*结束条件*/</span>) {</span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> queue.getOnePassenger();<span class="comment">//queue(ArrayList&lt;Passenger&gt;)是该电梯的等候队列</span></span><br><span class="line">        <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//分两步：</span></span><br><span class="line">        <span class="comment">//1.将最早的乘客起始点设为主请求，接人</span></span><br><span class="line">        <span class="built_in">this</span>.setTarget(passenger.getFromFloor());</span><br><span class="line">        forward(passenger);</span><br><span class="line">        <span class="comment">//2.将该乘客目的地设为主请求，送人</span></span><br><span class="line">        <span class="built_in">this</span>.setTarget(passenger.getToFloor());</span><br><span class="line">        forward(passenger);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.list.isEmpty()) {</span><br><span class="line">            <span class="comment">//将剩下的乘客逐一运送</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>forward(Passenger p)</code>方法用于<strong>接</strong>或<strong>送</strong>乘客<code>p</code>，同时还需满足捎带：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(Passenger p)</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.nowFloor != <span class="built_in">this</span>.targetFloor) { <span class="comment">//捎带：方向一致，目标小于主目标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*捎带或中途下人条件是否成立*/</span>openOrNot()) {</span><br><span class="line">            <span class="comment">//开门、出人、进人、关门</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.move();<span class="comment">//移动一层</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//到达指定层</span></span><br><span class="line">    <span class="built_in">this</span>.open();</span><br><span class="line">    <span class="comment">//1.如果p在电梯内且到了目的地，先让p下电梯</span></span><br><span class="line">    <span class="comment">//2.如果捎带的乘客目的地也在此层，下电梯</span></span><br><span class="line">    <span class="comment">//3.如果p还没上电梯，先让p进电梯</span></span><br><span class="line">    <span class="comment">//4.根据剩余容量捎带此层满足条件的乘客</span></span><br><span class="line">    <span class="built_in">this</span>.close();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>in()</code>,<code>out()</code>,<code>open()</code>,<code>close()</code>,<code>arrive()</code>均需要输出指定内容，<code>addPassenger()</code>和<code>removePassenger()</code>是电梯内队列的增减乘客操作方法（这里的方法和前文的队列类不同，就是很简单的删减操作，因为每一个电梯内队列只会被当前电梯操作，无需考虑线程安全的问题），都很容易实现~</p>
<h4 id="线程之间的交互和总运行流程"><a href="#线程之间的交互和总运行流程" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>开始输入，官方接口接受输入，<code>Main</code>将每一个<code>Passenger</code>送到总等候队列<code>waitQueue</code>（相当于生产者消费者模型中的托盘），调度器是电梯和乘客之间的桥梁，按照某种方式将<code>waitQueue</code>中的乘客放入不同电梯的等候队列(注意不是电梯内部)。而此时电梯和等候队列的关系也正好对应了消费者和托盘的关系，不同的是，一个等候队列仅对应一个电梯，因此每个电梯只需考虑将自己的等候队列里乘客处理完毕，直至收到结束信号并且等候队列和电梯内均为空则结束线程。</p>
<h4 id="同步块与锁"><a href="#同步块与锁" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和普通的程序不同，多线程编程中要注意线程安全的问题。例如，如果两个线程同时对一个对象进行写的操作，很有可能出现冲突和异常。因此要保证该对象每次只被一个线程访问，可以在所有可能被多个对象同时访问的成员方法加上synchronized关键字，在方法末尾调用<code>notifyAll()</code>唤醒其他线程。锁和同步块中处理语句之间的关系是，当一个线程进入同步块时，它会自动获取同步块所关联的锁对象，当它退出同步块时，它会自动释放锁对象，这样可以保证同步块中的处理语句不会被其他线程干扰。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removePassenger</span><span class="params">(Passenger p)</span> {</span><br><span class="line">    <span class="comment">//Your Method</span></span><br><span class="line">    notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5b1ddac507ccec498a.png"></p>
<h4 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次作业的中测在<del>写调度器之前</del>频繁超时，加上调度器之后就没有bug了。</p>
<p>强测和互测各出现了一个不能稳定复现的超时bug，大概率是高频发时会引发某些问题，导致乘客没进或没出以至于程序无法终止。检查代码的时候我发现在捎带乘客那一部分实际设定的电梯容量是5（@_@)，改正之后居然就能够解决了。</p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第一次作业基础上需要增加这些工作：</p>
<ol>
<li>将<strong>电梯</strong>类的属性变量添加到构造方法中以满足个性化添加电梯，并在具体实现中将常量替换为该电梯的属性</li>
<li>在<strong>队列</strong>类中新增和<code>maintain</code>有关的方法和变量以满足维修的需求</li>
<li>在<strong>电梯</strong>类的运行方法中新增判断是否<code>maintain</code>的方法以及处理措施的方法</li>
<li>修改线程结束的条件(<code>waitQueue</code>的输入来源不止一个main了，还有维修的电梯)</li>
</ol>
<h4 id="队列类-1"><a href="#队列类-1" class="headerlink" title="队列类"></a>队列类</h4><h5 id="PassengerQueue-1"><a href="#PassengerQueue-1" class="headerlink" title="PassengerQueue:"></a><code>PassengerQueue</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec604a.png"></p>
<p>增加了<code>setMaintainSymbol(int)</code>， <code>isMaintained()</code>和<code>addMaintainList(ArrayList&lt;PersonRequest)</code>三个方法。其中<code>setMaintainSymbol(int)</code>和<code>isMaintained()</code>分别用于设定维修标志和判断维修标志,<code>addMaintainList()</code>将参数<code>ArrayList&lt;PersonRequest&gt; list</code>全部加入到此对象的<code>List</code>中，可以适应将与维修电梯相关人员加入到<code>waitQueue</code>的操作。</p>
<h4 id="调度器类-1"><a href="#调度器类-1" class="headerlink" title="调度器类"></a>调度器类</h4><h5 id="Distribute"><a href="#Distribute" class="headerlink" title="Distribute:"></a><code>Distribute</code>:</h5><p><del>对的，不是打错了，是改名了</del></p>
<p>由于电梯也能将<code>waitQueue</code>加入乘客，因此需要修改调度器的结束条件：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!waitQueue.isEmpty()) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Your Method</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对比一下之前的：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Your Method</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其实仅仅时增加了中间一部分，因为考虑到maintain这个过程是需要时间的，如果仅仅在<code>waitQueue</code>为空时结束，那么一些收到maintain信号的电梯可能没来得及放出乘客，此时关闭调度器可能会使这些乘客无法参与分配从而永远到达不了目的地<del>_</del></p>
<p>所以我在满足原结束条件的情况下使调度器休眠固定时间，这也是由于课程组要求两层<code>arrive</code>以内必须完成<code>maintain</code>的操作，因此这个时间不会太难控制。如果休眠之后仍满足该条件，则结束。</p>
<p>第二次作业的调度策略与第一次作业的差别不大，此处不再赘述。</p>
<h4 id="电梯类"><a href="#电梯类" class="headerlink" title="电梯类"></a>电梯类</h4><h5 id="Elevator-1"><a href="#Elevator-1" class="headerlink" title="Elevator:"></a><code>Elevator</code>:</h5><p>在第一次作业上新增了一个方法：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec4773.png"></p>
<p>用于处理维修请求，一个示例（删去了很多细节代码，仅供参考）：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dealMaintain</span><span class="params">(PersonRequest p)</span> {</span><br><span class="line">    ArrayList&lt;PersonRequest&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*p不在电梯中*/</span>) {</span><br><span class="line">       waitQueue.add(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (PersonRequest person : arr) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*乘客未到达*/</span>) {</span><br><span class="line">            <span class="comment">//修改person的属性fromFloor为当前楼层</span></span><br><span class="line">            person.setFromFloor(nowFloor);</span><br><span class="line">            waitQueue.add(person);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.out(person);</span><br><span class="line">    }</span><br><span class="line">    waitQueue.addAll(<span class="built_in">this</span>.queue.getList());<span class="comment">//别忘了等候队列的可怜人:)</span></span><br><span class="line">    <span class="built_in">this</span>.maintainFlag = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>同时在其他方法比如<code>forward()</code>和<code>run()</code>中增加新内容以适应维修的需求：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">this</span>.nowFloor != <span class="built_in">this</span>.targetFloor) { </span><br><span class="line">           <span class="comment">//需要在正常上下客之前判断maintain</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.queue.isMaintained()) {</span><br><span class="line">               <span class="built_in">this</span>.dealMaintain(p);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">//Originated Method</span></span><br><span class="line">       }   </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">           ......</span><br><span class="line">           <span class="keyword">if</span> (<span class="comment">/*维护条件*/</span>) {</span><br><span class="line">               <span class="comment">/*输出维护信号*/</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           }</span><br><span class="line">           ......</span><br><span class="line">           forward(passenger);</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.maintainFlag == <span class="number">1</span>) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">while</span> (<span class="comment">/*电梯非空*/</span>) {</span><br><span class="line">               ......</span><br><span class="line">               forward(passenger);</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">this</span>.maintainFlag == <span class="number">1</span>) {</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></table></figure></div>

<p>总体还是通过改变<code>maintainFlag</code>来实现的。</p>
<h4 id="线程之间的交互和总运行流程-1"><a href="#线程之间的交互和总运行流程-1" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>总体结构变化不大，与第一次作业的区别：</p>
<ul>
<li>调度器并不会在标准输入结束之后结束，而是还要确定所有维护电梯均被维护才能结束</li>
<li>电梯线程可能会因为维护而提前结束，通过设定对应的等候队列的<code>maintainSymbol</code>，然后将其从<code>elevatorQueues</code>中<code>remove</code>可以切断调度器与之的联系，不会再给此电梯分配乘客，接着每个电梯根据是否收到此<code>maintainSymbol</code>来进行相应操作</li>
</ul>
<h4 id="同步块与锁-1"><a href="#同步块与锁-1" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和第一次作业区别不大。</p>
<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p>第二次作业使用了官方的<code>PersonRequest</code>类，因此比第一次作业少一个类，区别不大。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff601ddac507ccec5343.png"></p>
<h4 id="bug分析-1"><a href="#bug分析-1" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次作业应该是这个单元最折磨的一次了，因为我的代码出现了大面积CPU超时的问题，中测甚至提交了9次才通过:(</p>
<p>那一次周六对着电脑看了一天都没看出来问题，看到晚上晚上几近崩溃。每一次提交得到的10个CPU超时真的很揪心……</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff591ddac507ccec467b.png"></p>
<p>求助了助教还有很多同学，最终发现了问题的所在：</p>
<p>我一开始并没有让调度器在所有维修电梯完成且分配完成之后休眠，而是一直等到了所有乘客离开整个系统。</p>
<blockquote>
<p>程序的输入输出为<strong>实时交互</strong>，评测机可以做到在某个时间点投放一定量的输入</p>
</blockquote>
<p>也就是说输入结束的时间应该是最后一条指令实际被接受到的时刻附近。而正是这样，我觉得<code>setEnd</code>（我的理解偏差，这个时候我认为输入结束是指将数据复制到终端然后按下回车的时刻）之后调度器还必须等待最后一条指令，因为最后一条指令也可能会将<code>waitqueue</code>中添加乘客。所以就有了下面的大量无意义循环：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Distribute.java:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEnd()) {</span><br><span class="line">                <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                    elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd() &amp;&amp; table.isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> waitQueue.getOnePassenger();<span class="comment">//每次出来的结果都是null</span></span><br><span class="line">            <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {                          </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            .....</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PassengerQueue.java:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> Passenger <span class="title function_">getOnePassenger</span><span class="params">()</span> { <span class="comment">//按时间先后取出(先来后到)</span></span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; !<span class="built_in">this</span>.isEnd()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            ......</span><br><span class="line">    	}</span><br></pre></td></tr></table></figure></div>

<p>已经将<code>waitQueue</code>设定<code>setEnd()</code>，每次在<code>getOnePassenger</code>中的第一个if会直接跳过，而此时<code>queue</code>又确实为空会返回<code>null</code>。但整个系统还有乘客（<code>!table.isEmpty</code>），这样会进入大量循环返回<code>null</code>然后不断<code>continue</code>，占用大量的<code>CPU</code>资源导致超时。解决方法很容易，只要能理解到输入结束的时间就很好改了，正确的结束方式已经在前文的第二次作业总结-&gt;调度器类中解释了。</p>
<p>强测中出现了很多捎带的问题，发现漏掉了捎带的条件。</p>
<h5 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h5><p>使用了很多检查CPU时间的工具，都没能起到实质性的作用，不如直接在循环里<code>print(something)</code>，如果某个方法打印输出的东西达到了几十万行，就很好定位了：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//System.out.println("**********distributeI");</span></span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            ......</span><br><span class="line">        }</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//System.out.println("**********distributeO");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>不断将两条语句向中间靠近，找到循环最多的一个分支，就很容易发现问题了。</p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第二次作业基础上，需要新增这些内容：</p>
<ol>
<li>对每层楼可开门的数量加以限制</li>
<li>考虑到部分电梯的可达性，需要在分配乘客之前确定路径</li>
</ol>
<p>为了解决上述问题，我新增了一个<code>StateMap</code>类并提供诸多方法用于解决新的问题。</p>
<h4 id="个性化需求类"><a href="#个性化需求类" class="headerlink" title="个性化需求类"></a>个性化需求类</h4><h5 id="StateMap"><a href="#StateMap" class="headerlink" title="StateMap:"></a><code>StateMap</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff6f1ddac507ccec6bfe.png"></p>
<p>对于限制开门数量的要求，可以这样实现：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec6068.png"></p>
<p><code>serviceMap</code>的<code>value</code>对应了每层楼服务中的电梯数量，<code>key</code>指示楼层，因此初始时每层楼服务数量都是0。</p>
<p>开门时，直接调用<code>addService()</code>，由于<code>synchronized</code>的存在，每次只会有一个电梯访问该方法，若数量大于规定数量，则等待，直至该楼层服务中电梯数量小于规定数量，被唤醒，然后该楼层服务中电梯数量加1：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.serviceMap.get(floor) &gt;= <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    serviceMap.put(floor, serviceMap.get(floor) + <span class="number">1</span>);</span><br><span class="line">    notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>关门则直接调用<code>removeService()</code>:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeService</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">    serviceMap.put(floor, serviceMap.get(floor) - <span class="number">1</span>);</span><br><span class="line">    notifyAll();</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></div>

<p>对于只接人的电梯数量则跟上述方法类似，只不过需要新增方法来判断该电梯是否为只接人的。</p>
<p>为了解决路径问题，我定义了两个HashMap：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff671ddac507ccec5f6d.png"></p>
<p><code>accessMap</code>指示每个电梯可以直达的楼层，<code>pathMap</code>指示每层楼可以直达的楼层（类似于邻接矩阵）。</p>
<p>通过<code>findPath(Passenger p)</code>方法返回一个<code>LinkedList&lt;Integer&gt;</code>类型的需求队列，队列头部是该乘客下一个目的地，队列尾部是乘客的最终目的地。</p>
<h4 id="调度器类-2"><a href="#调度器类-2" class="headerlink" title="调度器类"></a>调度器类</h4><h5 id="Distribute："><a href="#Distribute：" class="headerlink" title="Distribute："></a><code>Distribute</code>：</h5><p>在调度的时候需要考虑乘客的当前需求楼层和所在楼层对于该电梯是可达的，在此基础上均匀分配：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; demand = stateMap.findPath(passenger);</span><br><span class="line">passenger.updateDemand(demand);</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    i = (i + <span class="number">1</span>) % elevatorQueues.size();</span><br><span class="line">} <span class="keyword">while</span> (!(<span class="comment">/*乘客的当前需求楼层和所在楼层对于该电梯是可达的*/</span>));</span><br><span class="line">elevatorQueues.get(i).addPassenger(passenger);</span><br></pre></td></tr></table></figure></div>

<h4 id="电梯类-1"><a href="#电梯类-1" class="headerlink" title="电梯类"></a>电梯类</h4><h5 id="Elevetor"><a href="#Elevetor" class="headerlink" title="Elevetor:"></a><code>Elevetor</code>:</h5><p>需要在开门前，关门后对<code>stateMap</code>做处理，如果数量不满足条件则会<code>wait()</code>直至被唤醒：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*判断只接人的方法*/</span>) {</span><br><span class="line">  	<span class="built_in">this</span>.stateMap.addOnly(nowFloor);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">this</span>.stateMap.addService(nowFloor);</span><br><span class="line">open();</span><br></pre></td></tr></table></figure></div>

<p>还需要把原来<code>passenger.getToFloor()</code>替换为<code>passenger.getDemand()</code>。因为现在乘客的总需求被拆分为多个子请求，我们在得到路径之后需要逐一处理子请求，<code>getDemand()</code>就是取出队列头部元素：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDemand</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.demand.getFirst();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="线程之间的交互和总运行流程-2"><a href="#线程之间的交互和总运行流程-2" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>总的结构区别不大，与第二次作业的区别：</p>
<ul>
<li>开关门时需要有额外的判断条件，新增<code>stateMap</code>类解决</li>
<li>对于换乘，我们在每次乘客进入<code>waitQueue</code>时更新<code>demand</code>队列，每次取出头部元素作为当前主请求，每次下电梯时判断是否为终点，再选择是否重新进入<code>waitQueue</code></li>
</ul>
<h4 id="同步块与锁-2"><a href="#同步块与锁-2" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和第一次作业区别不大。仅在新类<code>stateMap</code>中对应的添加删除对应楼层元素的方法中使用了synchronized关键字。</p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff671ddac507ccec5f30.png"></p>
<h4 id="bug分析-2"><a href="#bug分析-2" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次中测未测出bug，但是在使用评测机自行测试的时候发现了这样一个问题：即使设定了<code>addService</code>这样的方法但是还是会出现同一层服务电梯数量超过的情况，后来想清楚了：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前的方法:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(<span class="type">int</span> floor)</span> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.serviceMap.get(floor) &gt;= <span class="number">4</span>) {</span><br><span class="line">       <span class="comment">//Your Method(wait......)</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//Your Method</span></span><br><span class="line">	notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在这里要注意到<code>serviceMap</code>是一个<code>HashMap</code>类型，所有楼层的信息全部存储在这里。假如5楼开门的电梯已经达到最大数量，其他准备在5楼开门的电梯就会等待。但是要注意其他楼层的开关门操作也会改变该HashMap，但不一定改变此层楼对应的键值，这样5层不该开门的电梯有可能被错误地唤醒。修改方法很容易，把<code>if</code>改成<code>while</code>就行了，加一次判断即可。</p>
<h5 id="debug方法-1"><a href="#debug方法-1" class="headerlink" title="debug方法"></a>debug方法</h5><p>先用评测机评测随机数据，如果出现错误，先根据错误信息定位错误区间，确定出问题的方法。</p>
<p>强测出现了一个不能稳定复现的bug，在本地跑了好多遍都没有什么问题，官方给出的解释信息是real_time_limit_exceed，出现的异常信息：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Exception</span> <span class="keyword">in</span> thread <span class="string">"Thread-6"</span> java.<span class="property">lang</span>.<span class="property">NullPointerException</span></span><br><span class="line">    at <span class="title class_">StateMap</span>.<span class="title function_">findPath</span>(<span class="title class_">StateMap</span>.<span class="property">java</span>:<span class="number">100</span>)</span><br><span class="line">    at <span class="title class_">Distribute</span>.<span class="title function_">run</span>(<span class="title class_">Distribute</span>.<span class="property">java</span>:<span class="number">32</span>)</span><br></pre></td></tr></table></figure></div>

<p>检查了这个方法，不能够确定是否是没有加锁导致的。加锁之后，交上去，过了。但是在代码中只有一个线程能够访问此方法，所以很疑惑，感觉也不一定是线程安全的问题。</p>
<h2 id="三次作业总结"><a href="#三次作业总结" class="headerlink" title="三次作业总结"></a>三次作业总结</h2><h4 id="UML协作图"><a href="#UML协作图" class="headerlink" title="UML协作图"></a>UML协作图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff6f1ddac507ccec6c2d.png"></p>
<h4 id="分析内容"><a href="#分析内容" class="headerlink" title="分析内容"></a>分析内容</h4><p>稳定的内容：其实也就是第一次作业的内容，运送乘客，电梯开关门上下行。调度器线程从<code>waitQueue</code>中把乘客送给电梯的等候队列，电梯线程从等候队列中接人，捎带，运送乘客。</p>
<p>易变的内容：加入了维修需求之后，<code>waitQueue</code>接受的输入不止有标准输入了，还有电梯线程。自定义需求（容量，操作时间）使得电梯线程中的时间操作，输出操作需要做出相应更改。可达性需求出现后，调度器分配时要考虑乘客当前和需求楼层均可达，电梯开关门和捎带也必须考虑这两点。限制开门数量的需求出现后，在原来开关门的基础上需要额外增加条件。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全问题在多线程编程中非常重要。由于存在多个线程同时共享一个资源的情况，我们需要严格控制能够访问这一资源的数量。方法就是加锁。本次作业中我只使用了<code>synchronized</code>这一种锁<del>（其实也只会这一种）</del>，在每个方法之前加上synchronized关键字，在方法最末尾<code>notifyAll</code>唤醒其他可能正在等待访问此资源的线程。</p>
<h4 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h4><p>本单元的作业进一步加深了我对层次化设计的理解。使用生产者消费者模式可以很容易地理解每一个类扮演的角色是什么。如果是生产者，那么这个类里完成所有分配商品（乘客）到传送带（<code>waitQueue</code>）的工作，如果是消费者，只需要完成取出商品的工作即可。这样每个类能够仅考虑自己的工作，一定程度上吻合了“高内聚，低耦合”的思想，同时层次更加清晰，易于理解<del>（更容易找bug）</del>。</p>
<h4 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h4><p>本单元真的是收获颇丰的一单元，从对多线程的一无所知到能够编写出这样多功能的多线程协作电梯调度程序，已经是一件非常有成就感的事。在这个过程中，我主要有这样几点认识：</p>
<ul>
<li>寻找问题比解决问题重要得多。这是本单元第二次作业给我的教训。在没有真正发现问题之前修改一些自认为可能的bug，非常浪费时间浪费精力。<blockquote><p>The difficulty is not in finding a subject to talk about, but in discovering a subject that will reveal something in your own nature.</p>
<footer><strong>Charles Dickens</strong><cite>David Copperfield</cite></footer></blockquote></li>
<li>协作与合作的重要性。在这之前，每次的作业基本都是自己慢慢琢磨出来的。但是这单元的第二次作业我请教了大量的同学，问了很多的高年级同学，最终才发现了这个问题。没有这么多人的帮助我不可能完成这一次作业。</li>
</ul>
<p>感谢这么多同学的热心帮助^_^，希望在这条路上能够取得更大的收获。</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 3</title>
    <url>/2023/05/19/3Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%203/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第三单元作业的训练目标是<strong>掌握JML规格的理解与实现</strong>，三次作业为迭代开发。</p>
<p>需要完成的任务为实现简单社交关系的模拟和查询（第一次作业），实现社交关系模拟系统中的群组和消息功能（第二次作业）和实现社交关系系统中不同消息类型以及相关操作（第三次作业）。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业需要完成这些工作：</p>
<ol>
<li>根据官方接口和JML实现<code>MyPerson</code>类和<code>MyNetwork</code>类</li>
<li>继承官方提供的各抽象异常类，实现四个异常类</li>
<li>为<code>Network</code>类中的<code>query_triple_sum</code>方法书写OK测试</li>
</ol>
<h4 id="MyPerson"><a href="#MyPerson" class="headerlink" title="MyPerson"></a><code>MyPerson</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7bfb3.png"></p>
<p> <code>id</code>, <code>name</code>, <code>age</code>, <code>acquaintance</code>和<code>value</code>是该类的五个属性，接口要求为其中三个属性提供访问方法。<code>isLinked</code>用于判断两者是否有社交关系，<code>queryValue</code>用于查询社交值（如果有），<code>addPerson</code>和<code>addValue</code>用于添加社交关系。由于社交关系是动态变化的，因此我在设计的时候将acquaintance和value两个属性都定义为了<code>ArrayList</code>的结构，便于实现动态管理。</p>
<h4 id="MyNetwork"><a href="#MyNetwork" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06191ddac507ccf78e43.png"></p>
<p> <code>people</code>为按照接口要求实现的变量。<code>contains</code>方法判断社交网络中是否包含此人，<code>addPerson</code>和<code>addRelation</code>分别用于添加人和关系，<code>queryValue</code>用于查询两人之间的社交值（如果有），<code>isCircle</code>判断两人是否相连（通过与其他人的关系）。<code>queryBlockSum</code>用于查询最大连通分支的数目，<code>queryTripleSum</code>用于查询三元环的数目。<code>queryTripleSumOKTest</code>是一个对<code>queryTripleSum</code>方法进行OK测试的方法。</p>
<h4 id="Exception："><a href="#Exception：" class="headerlink" title="Exception："></a>Exception：</h4><h5 id="MyEqualPersonIdException"><a href="#MyEqualPersonIdException" class="headerlink" title="MyEqualPersonIdException"></a><code>MyEqualPersonIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06101ddac507ccf77f58.png"></p>
<h5 id="MyEqualRelationException"><a href="#MyEqualRelationException" class="headerlink" title="MyEqualRelationException"></a><code>MyEqualRelationException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06101ddac507ccf77f72.png"></p>
<h5 id="MyPersonIdNotFoundException"><a href="#MyPersonIdNotFoundException" class="headerlink" title="MyPersonIdNotFoundException"></a><code>MyPersonIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c016.png"></p>
<h5 id="MyRelationNotFoundException"><a href="#MyRelationNotFoundException" class="headerlink" title="MyRelationNotFoundException"></a><code>MyRelationNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c0f7.png"></p>
<p> 四种异常类的实现方法大同小异：定义静态变量sum，每次throw时将sum加1，同时定义静态HashMap存储每个id发生的异常次数。</p>
<h4 id="设计细节与bug分析"><a href="#设计细节与bug分析" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 如果完全按照JML的字面意思来实现的话，本次作业就是完完全全的照葫芦画瓢，没有任何难度。我们发现<code>isCircle</code>如果采用图遍历的方式每次调用时查找，CPU运行时间会大大增加，同样对于<code>queryTripleSum</code>。</p>
<p>因此本次作业采用并查集来解决CPU运行时间过长的问题：定义<code>HashMap&lt;Integer, Integer&gt; symbol = new HashMap&lt;&gt;()</code>指示每个节点对应的并查集，初始（添加这个人）时该集合设定为自己。每次调用<code>isCircle</code>时会调用<code>find()</code>方法判断两者是否同属一个并查集。而<code>find()</code>方法会递归地寻找从这个点到根节点的所有节点，并将这些节点的并查集全部更新：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*key的并查集不是自己*/</span>) {</span><br><span class="line">        symbol.put(key, find(symbol.get(key)));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*查找之后得到的并查集*/</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>而在每次<code>addRelation()</code>时，我们会调用<code>merge()</code>将两节点合并到同一个并查集中：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> <span class="comment">/*id1的并查集*/</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> <span class="comment">/*id2的并查集*/</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 != root2) {</span><br><span class="line">        symbol.put(root1, root2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这样就完成了对<code>isCircle()</code>的优化。</p>
<p> 同样对于<code>queryBlockSum</code>和<code>queryTripleSum</code>的方法也可以利用上述的方法：设定全局变量<code>globalQts</code>和<code>globalQbs</code>。每次<code>addPerson</code>时需要将连通分支数目加一，在<code>addRelation</code>中<code>merge</code>之前判断两人是否同属一个并查集，若不是，则将连通分支数目减一。而三元环的数目只需每次<code>addRelation</code>之后判断有多少个点同时与这两点相连即可。</p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06061ddac507ccf76df8.png"></p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第一次作业基础上需要增加这些工作：</p>
<ol>
<li>按照官方接口的JML实现<code>Group</code>类和<code>Message</code>类，并完善<code>Network</code>类中的更多方法</li>
<li>实现更多的异常类</li>
<li>为<code>Network</code>类中的<code>modifyRelation</code>方法书写OK测试</li>
</ol>
<h4 id="MyGroup"><a href="#MyGroup" class="headerlink" title="MyGroup"></a><code>MyGroup</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf77ff8.png"></p>
<p> 此类用于模拟社交群组，<code>id</code>为组id，<code>people: ArrayList&lt;Person&gt;</code>为组中人的集合，<code>addPerson</code>和<code>delPerson</code>用于向组中加入和删除成员，<code>hasPerson</code>用于判断组中是否存在某个成员，<code>getValueSum</code>，<code>getAgeMean</code>，<code>getAgeVar</code>用于计算整个组和成员年龄相关的值，<code>getSize</code>返回成员总数。</p>
<h4 id="MyMessage"><a href="#MyMessage" class="headerlink" title="MyMessage"></a><code>MyMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf78093.png"></p>
<p> 此类定义了五个成员属性：<code>id</code>, <code>socialValue</code>, <code>type</code>, <code>person1</code>, <code>person2</code>, <code>group</code>，并分别配置了访问方法。</p>
<h4 id="MyNetwork-1"><a href="#MyNetwork-1" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf78f2b.png"></p>
<p>相比第一次作业，此类新增了更多方法。<code>modifyRelation</code>用于调整两个人之间的关系，可以是改变社交值，也可以是删除关系，此外还需要为该方法编写OK测试方法。<code>addGroup</code>用于添加组，<code>addToGroup</code>用于将人添加到指定组中，<code>delFromGroup</code>则是将人从指定组中删去。<code>queryGroupValueSum</code>和<code>queryGroupAgeVar</code>用于返回组群中特定含义的数。<code>addMessage</code>，<code>getMessage</code>和<code>sendMessage</code>分别用于添加消息，接受消息和发送消息。<code>queryBestAcquaintance</code>用于查询对应id的有关系的人中社交值最高并且id更小的一个id。<code>queryCoupleSum</code>用于查询两个id互为对方的<code>BestAcquaintance</code>的对数。</p>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><h5 id="MyAcquaintanceNotFoundException"><a href="#MyAcquaintanceNotFoundException" class="headerlink" title="MyAcquaintanceNotFoundException"></a><code>MyAcquaintanceNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77296.png"></p>
<h5 id="MyEqualGroupIdException"><a href="#MyEqualGroupIdException" class="headerlink" title="MyEqualGroupIdException"></a><code>MyEqualGroupIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf970c9.png"></p>
<h5 id="MyEqualMessageIdException"><a href="#MyEqualMessageIdException" class="headerlink" title="MyEqualMessageIdException"></a><code>MyEqualMessageIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf970f7.png"></p>
<h5 id="MyGroupIdNotFoundException"><a href="#MyGroupIdNotFoundException" class="headerlink" title="MyGroupIdNotFoundException"></a><code>MyGroupIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf78015.png"></p>
<h5 id="MyMessageIdNotFoundException"><a href="#MyMessageIdNotFoundException" class="headerlink" title="MyMessageIdNotFoundException"></a><code>MyMessageIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06191ddac507ccf78dc1.png"></p>
<p> 新的异常类和第一次作业设计相同，不再赘述。</p>
<h4 id="设计细节与bug分析-1"><a href="#设计细节与bug分析-1" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 有了第一次作业的经验，我们知道，某些JML表面意思为做大量循环的方法要考虑直接循环的代价。所以可以考虑实现动态变化，在所有可能改变这个值的方法里修改这个值，在真正需要这个值的时候直接调用即可。例如<code>queryValueSum</code>，用于计算群组中所有的人和其他有关系的人的value之和，只有这些地方需要修改<code>valueSum</code>：<code>addRelation</code>之后，<code>modifyRelation</code>之后。</p>
<p> 但对于<code>ageMean</code>和<code>ageVar</code>两个与群组人数相关的变量，每次增加人数都不能确定改变的大小，因此必须在改变人数之后进行计算，这里可以设置标记，若没有增加或删除人，则可以返回上一次的计算结果，以达到提高效率的目的。</p>
<p> 对于<code>queryBestAcquaintance</code>，我们直接返回对应person中的一个变量，这个变量也是动态变化的。具体来说，每一次<code>addRelation</code>和<code>modifyRelation</code>时我们都要考虑这个变量，添加关系时，判断该<code>value</code>是否大于原<code>maxValue</code>，修改value时考虑是否会超过原<code>maxValue</code>，或者原value就是<code>maxValue</code>，以及删除关系时考虑最大值被删除等等（情况比较多，我在这里没有完全考虑清楚导致强测出现了很严重的bug）。</p>
<p> <code>queryCoupleSum</code>实际上依赖于<code>queryBestAcquaintance</code>(所以这里也寄了)，由上文知道，<code>BestAcquaintance</code>只会在<code>addRelation</code>和<code>modifyRelation</code>之后发生变化，并且只会针对两个点，我们只需在此时新建一个方法，这个方法可以计算两个点涉及的<code>coupleSum</code>数目（最小为0，最大为2），在改变关系前后分别调用，再相减就能得到经过这次改变<code>CoupleSum</code>应该变化的大小。</p>
<p> 同时，我们第一次作业中对于并查集的部分也因为增加了删边的新功能而必须修改。在这种情况下，我们必须保证每一次存入<code>HashMap</code>中的(id1-&gt;id2)按顺序排列，否则可能会出现因删边导致异常的情形。新增<code>disconnect</code>方法用于删除两节点的关系并且重新构造：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.min(id1, id2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.max(id1, id2);</span><br><span class="line">    pairs.remove(i1);</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry&lt;Integer, Integer&gt; entry : symbol.entrySet()) {</span><br><span class="line">        entry.setValue(entry.getKey());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry&lt;Integer, Integer&gt; entry : pairs.entrySet()) {</span><br><span class="line">        merge(entry.getKey(), entry.getValue());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06071ddac507ccf76e7b.png"></p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第二次作业基础上，需要新增这些内容：</p>
<ol>
<li>根据官方接口的JML实现<code>MyEmojiMessage</code>，<code>MyNoticeMessage</code>和<code>MyRedEnvelopeMessage</code>三个类，并完善<code>MyNetwork</code>类</li>
<li>新增三个异常类</li>
<li>对<code>deleteColdEmoji</code>编写OK测试方法</li>
</ol>
<h4 id="MyEmojiMessage"><a href="#MyEmojiMessage" class="headerlink" title="MyEmojiMessage"></a><code>MyEmojiMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf97046.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>emojiId</code>字段和对应的访问方法。</p>
<h4 id="MyNoticeMessage"><a href="#MyNoticeMessage" class="headerlink" title="MyNoticeMessage"></a><code>MyNoticeMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf790af.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>string</code>字段和对应的访问方法。</p>
<h4 id="MyRedEnvelopeMessage"><a href="#MyRedEnvelopeMessage" class="headerlink" title="MyRedEnvelopeMessage"></a><code>MyRedEnvelopeMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c09c.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>money</code>字段和对应的访问方法。</p>
<h4 id="MyNetwork-2"><a href="#MyNetwork-2" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf79047.png"></p>
<p> 需要新实现的方法有<code>containsEmojiId()</code>(查找表情是否存在)，<code>storeEmojiId()</code>（添加表情）,<code>queryMoney()</code>（查询money字段）, <code>queryPopularity()</code>（查询popularity字段）, <code>deleteColdEmoji()</code>（删除heat值小于limit的表情）, <code>clearNotice()</code>(清除通知）,<code>queryLeatMoments()</code>（查找最短自环）。并要求对原<code>sendMessage</code>方法进行完善。</p>
<h4 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h4><h5 id="MyEmojiIdNotFoundException"><a href="#MyEmojiIdNotFoundException" class="headerlink" title="MyEmojiIdNotFoundException"></a><code>MyEmojiIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07351ddac507ccf97012.png"></p>
<h5 id="MyEqualEmojiIdException"><a href="#MyEqualEmojiIdException" class="headerlink" title="MyEqualEmojiIdException"></a><code>MyEqualEmojiIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf97083.png"></p>
<h5 id="MyPathNotFoundException"><a href="#MyPathNotFoundException" class="headerlink" title="MyPathNotFoundException"></a><code>MyPathNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7beb6.png"></p>
<p>新的异常类与之前实现完全相同，不再赘述。</p>
<h4 id="设计细节与bug分析-2"><a href="#设计细节与bug分析-2" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 第三次作业对算法的要求极高，在查找最小环的过程需要通过枚举非树边和<code>djikstra</code>算法结合查找每一个点的最小环，同时必须按照优先队列的方式枚举以达到减小循环次数的目的。</p>
<p> 此外，笔者因为第一次作业的遗留问题在互测中被多次hack@_@（很奇怪居然前两次测试都没有测出来）。例如在将某个人的acquaintance为空时添加与自己本身的关系时，应该抛出异常的却没有抛出异常，再根据JML仔细查看发现了问题：判断<code>isLinked()</code>的方法前面一个括号包含了循环，后面的<code>id != person.getId()</code>并不包含在括号中。如果我把判断id和<code>person.getId()</code>放在循环中，但是此时person的acquaintance为空，因此不会进入循环也就不会返回<code>true</code>（以及第二次作业的<code>ageVar</code>和<code>ageMean</code>出现问题也是因为JML括号的识别问题）。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77255.png"></p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77201.png"></p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h5 id="对黑箱测试、白箱测试的理解"><a href="#对黑箱测试、白箱测试的理解" class="headerlink" title="对黑箱测试、白箱测试的理解"></a>对黑箱测试、白箱测试的理解</h5><p>黑箱测试是基于软件的功能和需求进行测试，而不考虑内部的实现细节和结构。测试人员对软件系统进行测试时，只关注输入和输出之间的关系，测试软件的功能是否符合预期。黑箱测试的目标是发现系统的功能缺陷、界面错误、性能问题等，而不关注代码的具体实现。</p>
<p>白箱测试是基于软件的内部结构和实现细节进行测试。测试人员具有对源代码的访问权限，可以深入了解软件的内部逻辑和数据流。白箱测试的目标是验证软件的内部逻辑是否正确、代码是否符合编码标准、是否存在潜在的错误和安全漏洞等。</p>
<h5 id="对单元测试、功能测试、集成测试、压力测试、回归测试的理解"><a href="#对单元测试、功能测试、集成测试、压力测试、回归测试的理解" class="headerlink" title="对单元测试、功能测试、集成测试、压力测试、回归测试的理解"></a>对单元测试、功能测试、集成测试、压力测试、回归测试的理解</h5><ul>
<li>单元测试是对软件中最小的可测试单元进行验证的过程。单元可以是函数、方法或类等独立的代码块。单元测试的目标是在尽可能独立的环境中对单元进行测试，以确保其功能的正确性。</li>
<li>功能测试是对软件的功能进行验证的测试类型。它涉及对软件的各个功能模块和组件进行测试，以确认其是否按照需求规格说明书或用户期望的方式正常工作。功能测试通常以用户的角度来进行，通过模拟真实用户的操作来检查软件的功能是否符合预期。</li>
<li>集成测试是在多个独立的软件模块或组件之间进行测试，以验证它们的协同工作和接口的正确性。集成测试的目标是发现模块之间的集成问题、接口错误、数据传递问题等。它可以确保各个模块在集成后能够正常工作，并且相互之间没有冲突或不一致。</li>
<li>压力测试是对软件系统在正常或超出正常工作负载条件下进行测试的过程。其目的是评估系统的性能、稳定性和可靠性，以确定在负载增加的情况下系统的响应是否满足需求。压力测试通过模拟高并发、大数据量或异常负载情况来测试系统的极限情况。</li>
<li>回归测试是在软件进行更改或修复后，重新执行既有的测试用例，以确保新的修改没有引入新的错误或破坏了原有的功能。回归测试的目标是验证软件在经过修改后仍然具有稳定性和兼容性，不会对现有功能产生负面影响。</li>
</ul>
<h5 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h5><ol>
<li>正常值：选择符合程序预期输入的正常值作为测试数据。这些值应涵盖程序的各种功能和逻辑情况，包括边界值、典型值和一般情况。</li>
<li>边界值：选择接近边界条件的测试数据。边界值通常是最有可能导致错误的情况，因此在测试过程中应特别关注这些值。例如，构造一个不存在长度大于等于3的自环，验证<code>queryLeastMoments</code>的正确性。</li>
<li>随机值：使用随机生成的测试数据来测试程序。通过生成大量的随机数据来覆盖各种情况和可能的输入组合，利用评测机。</li>
</ol>
<h2 id="对OK测试的思考"><a href="#对OK测试的思考" class="headerlink" title="对OK测试的思考"></a>对OK测试的思考</h2><h5 id="OK测试的作用"><a href="#OK测试的作用" class="headerlink" title="OK测试的作用"></a>OK测试的作用</h5><ol>
<li>OK测试可以帮助开发人员更好地理解需求规格，并在开发过程中发现规格中可能存在的问题或矛盾。通过对规格中的每个要求都进行OK测试，可以确保程序实现了所有规格要求，同时也能够提高开发人员对规格的理解和准确性。</li>
<li>OK测试提供了一种客观、可验证的方法来检查代码实现是否符合规格要求。它能够帮助开发人员确保代码的正确性，并减少因为规格不清晰或错误而导致的问题。</li>
<li>OK测试可以提高代码的可维护性。由于OK测试要求开发人员明确规格要求和实现的一致性，因此可以帮助减少代码中的冗余和不必要的复杂性，使得代码更易于理解和维护。</li>
</ol>
<h5 id="改进和建议"><a href="#改进和建议" class="headerlink" title="改进和建议"></a>改进和建议</h5><ol>
<li>提高OK测试的覆盖率。为了发现更多的问题和缺陷，需要尽可能覆盖更多的规格要求。这可以通过增加测试用例、考虑不同的输入组合来实现。</li>
<li>自动化测试。将OK测试自动化可以减少测试成本和人力成本，并提高测试效率和准确性。可以使用现有的自动化测试框架来实现。</li>
</ol>
<h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><h5 id="规格与实现分离"><a href="#规格与实现分离" class="headerlink" title="规格与实现分离"></a>规格与实现分离</h5><p> 规格与实现分离的目的是为了降低程序的复杂度，提高程序的可读性和可维护性。通过将规格描述与程序实现分离，可以使得程序的设计更加模块化、可重用，更容易理解和修改。此外，规格与实现分离还可以提高程序的测试效率和质量，因为规格描述可以作为测试用例的基础，而不必依赖于程序的具体实现。</p>
<h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5><ul>
<li>从0到深入了解JML：JML是一种允许开发人员指定程序属性、前置条件、后置条件和不变量的语言。JML提供了一种结构化和规范的方法来定义程序的预期行为。学习JML使我能够编写更可靠和易于维护的代码。</li>
<li>应用JML编写程序，整个单元通过迭代式开发，依赖于大量JML语言完成一个社交网络的模拟。回首整个单元不断发现问题，debug成功的过程，其实是一件很有成就感的事情。</li>
</ul>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 4</title>
    <url>/2023/06/18/4Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%204/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第四单元作业主要任务是完成一个图书馆模拟系统，以训练对程序架构的设计和抽象能力。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="本单元所实践的正向建模与开发"><a href="#本单元所实践的正向建模与开发" class="headerlink" title="本单元所实践的正向建模与开发"></a>本单元所实践的正向建模与开发</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在正向建模与开发的过程中，首先需要进行需求分析。根据指导书，我们需要完成这些任务：</p>
<ul>
<li>选用合适的方式表示书本，并提供合适的容器。在第一次作业中，由于不涉及校际借阅，情况较为简单，因此我直接用字符串（书本名称）指代这本书，所有的容器都采用<code>HashMap&lt;String, Integer&gt;</code>的形式表示对应书本及其数量。但是后续作业中新增了校际借阅的功能，这意味着每一本书都有其来源学校，并且还存在是否允许借阅的权限问题。因此必须重构，对书建类<code>Book</code>类，在构造方法中提供对来源地（<code>source</code>）、书名（<code>bookName</code>）、是否允许校际借阅（<code>permisssion</code>）的初始化并配置对应访问方法，重构之后所有存储书的容器就应该转化为<code>HashMap&lt;Book, Integer&gt;</code>。值得注意的是，将Book类作为键时，需要确保重新实现了<code>hashCode()</code>和<code>equals()</code>方法，以便在<code>HashMap</code>中正确地进行键的比较和查找，这样可以确保相同的书对象将被视为相等的键。比如：<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ((bookName == <span class="literal">null</span>) ? <span class="number">0</span> : bookName.hashCode());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) {</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Book</span> <span class="variable">other</span> <span class="operator">=</span> (Book) obj;</span><br><span class="line">    <span class="keyword">return</span> bookName.equals(other.bookName);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li>对于每种职责的管理人员需要为其建类并提供相应的方法处理书本，其中大部分标准输出在这些类里完成。请看下一小节 <strong>类设计</strong></li>
<li>处理日期。注意到作业要求整理日早晨必须整理并输出，因此对于图书借阅的标准输入要按照这样的步骤来处理：<ol>
<li>判断是否日期发生变化，若没有发生变化，继续处理当前信息</li>
<li>日期发生变化，处理当天没有成功处理的信息（没有成功借书，走校际借阅or校内预定（等书或者购买））</li>
<li>从变化前日期后一天开始，遍历所有在变化后日期之前的整理日，按顺序（完成新书购置，整理图书并输出整理信息，发放预定图书）处理<br>其中日期可以调用<code>java.time.LocalDate</code>现有的方法，比如：<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;String&gt; <span class="title function_">findArDays</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">initDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">startDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">endDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">    HashSet&lt;String&gt; datesSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (startDate.isBefore(endDate)) { <span class="comment">//isBefore可以比较日期前后</span></span><br><span class="line">        <span class="keyword">if</span> (initDate.until(startDate, ChronoUnit.DAYS) % <span class="number">3</span> == <span class="number">0</span>) { <span class="comment">//until返回日期间隔天数</span></span><br><span class="line">			datesSet.add(<span class="string">'['</span> + startDate.toString() + <span class="string">']'</span>);</span><br><span class="line">        }</span><br><span class="line">        startDate = startDate.plusDays(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    datesSet.add(<span class="string">'['</span> + initDate.toString() + <span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">return</span> datesSet;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
（在程序开始之前的静态方法，找出这一年所有整理日，之后通过<code>contains()</code>可以判断是否为整理日）</li>
</ol>
</li>
</ul>
<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><h4 id="Student"><a href="#Student" class="headerlink" title="Student"></a><code>Student</code></h4><p> 每一个学生都是独一无二的，由于后续作业表明不同学校可能有相同学号的学生，因此每个Student类中需要包含学校名和学生名(学号）两个字段。此外，每个学生借书还书还需要提供书的容器，以及保存当前拥有书籍借阅日期的信息：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bde1ddac507cc00c7a2.png"></p>
<p>对于书籍的损坏，我并没有将损坏作为一个字段放在<code>Book</code>类中，而是对于在<code>Student</code>类中新建<code>HashSet&lt;Book&gt;</code>中保存已损坏的书籍。下面是借书还书的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowB</span><span class="params">(Book book, String date)</span> {</span><br><span class="line">    <span class="built_in">this</span>.bs.add(book);</span><br><span class="line">    <span class="built_in">this</span>.borrowDate.put(book.getName(), date);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">returnB</span><span class="params">(String bookName)</span> {</span><br><span class="line">    <span class="type">Book</span> <span class="variable">reBook</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Book book: bs) {</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(bookName)) {</span><br><span class="line">            reBook = book;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.bs.remove(reBook);</span><br><span class="line">    <span class="built_in">this</span>.borrowDate.remove(bookName);</span><br><span class="line">    <span class="keyword">return</span> reBook;</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></div>

<p>在主函数Main中，我是用<code>HashMap&lt;String, HashMap&lt;String, Student&gt;&gt; students</code>来保存所有的学生的。</p>
<h4 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a><code>Lib</code></h4><p>用于表示每个学校的图书馆。提供查询图书方法，以及查询借阅是否合法（针对预定），校内借阅，校际借阅的方法。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b77f.png"></p>
<h4 id="Bar（borrowing-and-returning-librarian）"><a href="#Bar（borrowing-and-returning-librarian）" class="headerlink" title="Bar（borrowing and returning librarian）"></a><code>Bar</code>（borrowing and returning librarian）</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b723.png"></p>
<p> 借还管理员类中应包含学校名称，接受校内归还的图书以及未成功借出的图书存储到<code>barLib</code>，校际借阅归的图书还到<code>outBooks</code>。其中包含了借书还书，赔偿罚款，运走接受书籍（校际借阅），判断日期间隔的方法。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b75c.png"></p>
<h4 id="Mace-self-service-machine"><a href="#Mace-self-service-machine" class="headerlink" title="Mace(self-service machine)"></a><code>Mace</code>(self-service machine)</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b7c5.png"></p>
<p>与上文借还管理员类相似。</p>
<h4 id="Rai（logistics-division）"><a href="#Rai（logistics-division）" class="headerlink" title="Rai（logistics division）"></a><code>Rai</code>（logistics division）</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bde1ddac507cc00c77a.png"></p>
<p>后勤管理处用于修补损坏的图书，提供<code>raiLib</code>存储校内借阅的图书，<code>outBooks</code>存储校际借阅的图书。同时提供运送书籍和接收书籍的方法。</p>
<h4 id="Odr-ordering-librarian"><a href="#Odr-ordering-librarian" class="headerlink" title="Odr(ordering librarian)"></a><code>Odr</code>(ordering librarian)</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd41ddac507cc00b855.png"></p>
<p>预定管理员通过<code>orderList</code>和<code>buyList</code>记录每一天需要进行校内预定（等待还书和购买）的信息，同时提供一个存储书籍的容器<code>counter</code>和存储购买的新书的容器<code>buyMap</code>。该类还提供分发书籍，将书籍放回图书馆等方法。</p>
<h3 id="设计细节与bug分析"><a href="#设计细节与bug分析" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h3><ul>
<li><p>利用泛型存储每个学校的所有管理员对象：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用TreeMap在遍历时可以按照字典序输出</span></span><br><span class="line">TreeMap&lt;String, ArrayList&lt;Object&gt;&gt; schools = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//ArrayList&lt;Object&gt;可以允许不同的类型存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initDepartment</span><span class="params">(ArrayList&lt;Object&gt; departments, String schoolName)</span> {</span><br><span class="line">    <span class="type">Bar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bar</span>(schoolName);<span class="comment">// 1-&gt;Bar BorrowingAndReturningLibrarian</span></span><br><span class="line">    departments.add(bar);</span><br><span class="line">    <span class="type">Odr</span> <span class="variable">odr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Odr</span>(schoolName);<span class="comment">// 2-&gt;Odr OrderLibrarian</span></span><br><span class="line">    departments.add(odr);</span><br><span class="line">    <span class="type">Mace</span> <span class="variable">mace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mace</span>(schoolName);<span class="comment">// 3-&gt;Mace ServiceMachine</span></span><br><span class="line">    departments.add(mace);</span><br><span class="line">    <span class="type">Rai</span> <span class="variable">rai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rai</span>(schoolName);<span class="comment">// 4-&gt;Rai LogisticsDivision</span></span><br><span class="line">    departments.add(rai);</span><br><span class="line">    <span class="type">Arg</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arg</span>(schoolName);<span class="comment">// 5-&gt;Arg ArrangingLibrarian</span></span><br><span class="line">    departments.add(arg);</span><br><span class="line">    <span class="type">Pcd</span> <span class="variable">pcd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pcd</span>(schoolName);<span class="comment">// 6-&gt;Pcd PurchasingDepartment</span></span><br><span class="line">    departments.add(pcd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>特别注意最后一条信息之后也要处理当天的预定信息：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) {<span class="comment">//m条图书借还信息</span></span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">if</span> (i == m - <span class="number">1</span>) {</span><br><span class="line">        process(proList, schools, transList, students);<span class="comment">//处理所有没能借成功的信息</span></span><br><span class="line">        transport(transList, schools, today);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注意日期的加减，应该调用<code>plusDays()</code>方法，而不是将day++然后手动转化，比如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">findArrDay</span><span class="params">(String year, String month, String day)</span> {</span><br><span class="line">    <span class="keyword">return</span> LocalDate.of(year, month, day).plusDays(<span class="number">1</span>).toString();</span><br><span class="line">    <span class="comment">//错误示范：</span></span><br><span class="line">    <span class="comment">//String nextDay = (Integer.parseInt(day) + 1).toString();</span></span><br><span class="line">    <span class="comment">//return LocalDate.of(year, month, nextDay).toString();</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="最终的代码和UML模型设计之间的追踪关系"><a href="#最终的代码和UML模型设计之间的追踪关系" class="headerlink" title="最终的代码和UML模型设计之间的追踪关系"></a>最终的代码和UML模型设计之间的追踪关系</h2><p>本单元作业在第二次作业进行了重构。因为考虑到校际借阅的问题，每个图书中包含的信息量增大，不能仅仅用字符串来表示，这样底层的容器，方法必须全部修改。此外还要考虑多个学校多个管理员以及顺序输出，因此schools存储结构也要改变（相比之下，我的第一次作业就是一种单例模式）。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bdf1ddac507cc00c823.png"></p>
<p>最终的代码和UML图基本吻合。从UML类图可以看出，图书馆的各个管理员都建立了类，每个类内部提供方法执行对应的职能，在主类中直接调用对象的方法即可。</p>
<h2 id="四个单元中架构设计思维的演进"><a href="#四个单元中架构设计思维的演进" class="headerlink" title="四个单元中架构设计思维的演进"></a>四个单元中架构设计思维的演进</h2><ul>
<li>第一单元（表达式化简）：架构设计的雏形，第一次接触到用递归下降方法解析表达式。我们需要通过各个类来实现具体的解析和计算，可以简单理解为分工合作，各个部分完成的工作大不相同却又相辅相成，相互依赖</li>
<li>第二单元（多线程和电梯）：初步接触多线程编程，通过调度器类支持整个模块的运转</li>
<li>第三单元（JML与规格）：掌握编程的规范化，了解了接口，继承以及多态（<code>emojiMessage, moneyMessage等</code>)在面向对象中的实现</li>
<li>第四单元（通过UML对图书馆建模）：根据需求绘制UML类图，根据图进行正向建模</li>
</ul>
<h2 id="四个单元中测试思维的演进"><a href="#四个单元中测试思维的演进" class="headerlink" title="四个单元中测试思维的演进"></a>四个单元中测试思维的演进</h2><p>前两个单元主要依靠讨论区同学们提供的评测机以及手动构造数据来进行测试，认识到自动化测试是一种高效的测试方法。</p>
<p>第三单元主要依靠JUnit进行方法进行单元测试，通过编写单元测试类和方法，来实现对类和方法实现正确性的快速检查和测试，可以很好排除bug。</p>
<p>第四单元的测试点并没有刻意去增加强度，而是希望我们把重点放在UML图的设计中，手动构造数据即可很容易地通过测试。</p>
<h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><ul>
<li>深入理解了面向对象的思维方式。面向对象强调将问题领域的概念和行为转化为对象，并通过它们之间的交互来解决问题。这种思维方式使得系统的设计更加模块化、可扩展和可维护。比如说第一单元表达式分为表达式，项，因子类等，第四单元将众多图书管理员各自建立类实现。</li>
<li>熟悉了一门编程语言。不得不说，Java和C语言在很多方面都有相似之处，通过面向对象的学习可以让我在实践中逐渐掌握一门新的语言。</li>
<li>认识了一些设计模式。设计模式如工厂模式、观察者模式和单例模式等，提供了解决特定问题的经典解决方案。这些模式对于构建高质量的软件系统至关重要。</li>
<li>对测试有了新的理解。千万不要妄想着一遍不做任何测试就能成功，即使整体思路不存在问题，还是会出现许多小bug，因此做好测试是十分有必要的。</li>
</ul>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python notes</title>
    <url>/2023/06/26/5Python-notes/</url>
    <content><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h5 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'async'</span>, <span class="string">'await'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h5><p>使用反斜杠<code>\</code>来实现多行语句</p>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ul>
<li>单行注释以 <strong>#</strong> 开头</li>
<li>多行注释可以用多个 <strong>#</strong> 号，也可用三个单引号 <strong>'‘’</strong> 或者三个双引号 <strong>"“”</strong> 将注释括起来</li>
</ul>
<h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><p>使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> ，缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数</p>
<h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>python中数字有四种类型：整数(int, 1…)、布尔型(bool, True…)、浮点数(float, 1.23…)和复数(complex, 1+2j…)</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用<strong>完全相同</strong></li>
<li>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串</li>
<li>转义符 <code>\</code></li>
<li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行</li>
<li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong></li>
<li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复</li>
<li>字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始</li>
<li>Python 中的字符串不能改变</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串</li>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong>(步长表示间隔)</li>
</ul>
<h5 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h5><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"a"</span></span><br><span class="line">y=<span class="string">"b"</span></span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">" "</span>)</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line">a b </span><br></pre></td></tr></table></figure></div>

<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>变量无需声明，但每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建</li>
<li>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型</li>
</ul>
<p>同时为多个变量赋值：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>为多个对象指定多个变量：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"runoob"</span></span><br></pre></td></tr></table></figure></div>

<h5 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h5><p>Python3 的六个标准数据类型中：</p>
<ul>
<li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）</li>
<li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）</li>
</ul>
<h5 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h5><p>int、float、bool、complex（复数）</p>
<p>内置的 <code>type()</code> 函数和 <code>isinstance</code>可以询变量所指的对象类型</p>
<blockquote>
<p><strong>注意：</strong>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， <strong>True==1、False==0</strong> <em>会返回</em> <strong>True</strong>，但可以通过<strong>is</strong>来判断类型。</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>==<span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<h6 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数, 往小的方向取整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在混合计算时，Python会把整型转换成为浮点数</li>
<li>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 **<code>a + bj</code>**，或者 <strong><code>complex(a,b)</code></strong> 表示， 复数的实部 <code>a</code> 和虚部 <strong><code>b</code></strong> 都是浮点型</li>
<li><code>//</code> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系</li>
</ul>
<h6 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h6><p>只需要将数据类型作为函数名即可</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数</li>
<li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y，x 和 y 是数字表达式</li>
</ul>
<h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left">cmp(x, y)</td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-log.html">log(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定参数的最大值，参数可以为序列</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定参数的最小值，参数可以为序列</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">x**y 运算后的值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-round.html">round(x,[,n]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。**其实准确的说是保留值将保留到离上一位更近的一端</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字x的平方根</td>
</tr>
</tbody></table>
<h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数</td>
</tr>
<tr>
<td align="left">[randrange (<a class="link" href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-random.html">random() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">随机生成下一个实数，它在[0,1)范围内</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-seed.html">seed([x]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">随机生成下一个实数，它在[x,y]范围内</td>
</tr>
</tbody></table>
<h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反余弦弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反正弦弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反正切弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定的 X 及 Y 坐标值的反正切值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的弧度的余弦值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回欧几里德范数 sqrt(x*x + y*y)</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回的x弧度的正弦值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x弧度的正切值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将角度转换为弧度</td>
</tr>
</tbody></table>
<h6 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h6><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）</td>
</tr>
</tbody></table>
<h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><ul>
<li>字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 <code>\</code>转义特殊字符</li>
<li>使用反斜杠 <code>\</code> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r'Ru\noob'</span>)</span><br><span class="line">Ru\noob</span><br></pre></td></tr></table></figure></div></li>
<li>自带空格连接<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></div></li>
<li>Python 字符串不能被改变。向一个索引位置赋值，比如 <strong><code>word[0] = 'm'</code></strong> 会导致错误\</li>
<li>用+运算符连接在一起，用*运算符重复</li>
<li>两种索引方式，从左往右以0开始，从右往左以-1开始</li>
<li>字符串的截取的语法格式如下：<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br><span class="line"><span class="comment">#不会打印尾下标字符，也就是说会打印到尾下标之前的那一个字符</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="字符串更新"><a href="#字符串更新" class="headerlink" title="字符串更新"></a>字符串更新</h6><p>通过截取字符串的一部分并与其他字段拼接：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">var1 = <span class="string">'Hello World!'</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"已更新字符串 : "</span>, var1[:<span class="number">6</span>] + <span class="string">'Runoob!'</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h6><table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>\</strong>(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td><strong><span>\</span></strong></td>
<td>反斜杠</td>
</tr>
<tr>
<td><strong>\‘</strong></td>
<td>单引号</td>
</tr>
<tr>
<td><strong>\“</strong></td>
<td>双引号</td>
</tr>
<tr>
<td><strong>\a</strong></td>
<td>响铃</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>退格</td>
</tr>
<tr>
<td><strong>\000</strong></td>
<td>空</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td>换行</td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td>纵向制表符</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td>横向制表符</td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td>回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成</td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td>换页</td>
</tr>
<tr>
<td><strong>\yyy</strong></td>
<td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行</td>
</tr>
<tr>
<td><strong>\xyy</strong></td>
<td>十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td>
</tr>
</tbody></table>
<h6 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h6><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串连接</td>
<td align="left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">重复输出字符串</td>
<td align="left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通过索引获取字符串中字符</td>
<td align="left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td align="left">[ : ]</td>
<td align="left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td>
<td align="left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td align="left"><strong>‘H’ in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td align="left"><strong>‘M’ not in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">r/R</td>
<td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法</td>
<td align="left"><code>print( r'\n' ) print( R'\n' )</code></td>
</tr>
</tbody></table>
<h6 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">"我叫 %s 今年 %d 岁!"</span> % (<span class="string">'Leo'</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符串格式化符号与C语言类似</li>
<li><a class="link" href="https://www.runoob.com/python/att-string-format.html">str.format() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>增强了字符串格式化的功能</li>
</ul>
<h6 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h6><p>三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符</p>
<h5 id="bool（布尔类型）"><a href="#bool（布尔类型）" class="headerlink" title="bool（布尔类型）"></a>bool（布尔类型）</h5><ul>
<li>布尔类型即 True 或 False</li>
<li>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0</li>
<li>可以和逻辑运算符一起使用，包括 and、or 和 not，这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &lt; <span class="number">3</span>)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> == <span class="number">3</span>)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a)    <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(a))   <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(b)) <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(a))   <span class="comment"># "True"</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意:</strong> 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 <strong>0、空字符串、空列表、空元组</strong>等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。</p>
</blockquote>
<h5 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h5><ul>
<li>表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（类似于Java中的泛型）</li>
<li>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表</li>
<li>和字符串一样，列表同样可以被索引和截取，截取后返回一个包含所需元素的新列表</li>
<li>与Python字符串不一样的是，列表中的元素是可以改变的：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = []   <span class="comment"># 将对应的元素值设置为 []</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></div></li>
<li>Python 列表截取可以接收第三个参数，参数作用是截取的步长，如果第三个参数为负数表示逆向读取</li>
</ul>
<p>逆转句子的实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">" "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">' '</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">'I like runoob'</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure></div>

<h6 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h6><p>直接进行修改或更新:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"第三个元素为 : "</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"更新后的第三个元素为 : "</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></div>

<p>使用 append() 方法:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line">list1.append(<span class="string">'Baidu'</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"更新后的列表 : "</span>, list1)</span><br></pre></td></tr></table></figure></div>

<h6 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h6><p>使用 del 语句来删除列表的的元素，如下实例:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></div>

<h6 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure></div>

<h6 id="与列表有关的函数和方法"><a href="#与列表有关的函数和方法" class="headerlink" title="与列表有关的函数和方法"></a>与列表有关的函数和方法</h6><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">len(list)	max(list) 	min(list)	list(<span class="built_in">seq</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">list.append(obj)	list.count(obj)		list.extend(<span class="built_in">seq</span>)	list.index(obj)		</span><br><span class="line">list.insert(index, obj)		list.pop([index=-1])	list.remove(obj)	list.reverse()		</span><br><span class="line">list.sort( key=None, reverse=False)		list.clear()		list.copy()</span><br></pre></td></tr></table></figure></div>

<h5 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h5><ul>
<li>与列表类似，不同之处在于元组的元素<strong>不能修改</strong>(可以把字符串看作一种特殊的元组)</li>
<li>元组写在小括号 <strong>()</strong> 里，元素之间用<strong>逗号</strong>隔开</li>
<li>元组中的元素类型也可以不相同</li>
<li>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表\</li>
</ul>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号，否则括号会被当作运算符使用</span></span><br></pre></td></tr></table></figure></div>

<h6 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h6><p>使用下标索引：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<h6 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h6><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="comment"># 不允许出现类似tup1[0] = 100的用法</span></span><br></pre></td></tr></table></figure></div>

<h6 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h6><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">del</span> tup</span><br></pre></td></tr></table></figure></div>

<h6 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">len(tuple)	+	+=	*	in</span><br></pre></td></tr></table></figure></div>

<h6 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h6><p>同列表</p>
<h6 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h6><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>len(tuple)</code> 计算元组元素个数</td>
<td align="left"><code>&gt;&gt;&gt; tuple1 = ('Google', 'Runoob', 'Taobao') &gt;&gt;&gt; len(tuple1) 3 </code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>max(tuple)</code> 返回元组中元素最大值</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; max(tuple2) '8'  </code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>min(tuple)</code> 返回元组中元素最小值</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; min(tuple2) '4' &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>tuple(iterable)</code> 将可迭代系列转换为元组</td>
<td align="left"><code>&gt;&gt;&gt; list1= ['Google', 'Taobao', 'Runoob', 'Baidu'] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 ('Google', 'Taobao', 'Runoob', 'Baidu')</code></td>
</tr>
</tbody></table>
<h5 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h5><ul>
<li>一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员</li>
<li>基本功能是进行成员关系测试和删除重复元素</li>
<li>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sites = {<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Zhihu'</span>, <span class="string">'Baidu'</span>}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'Runoob'</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Runoob 在集合中'</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Runoob 不在集合中'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'alacazam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure></div>

<h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.add( x )		<span class="comment">#将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作</span></span><br><span class="line">s.update( x )	<span class="comment">#也可以添加元素，且参数可以是列表，元组，字典等</span></span><br></pre></td></tr></table></figure></div>

<h6 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.remove( x )		<span class="comment">#将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误</span></span><br><span class="line">s.discard( x )		<span class="comment">#移除集合中的元素，如果元素不存在，不会发生错误</span></span><br><span class="line">s.pop() 			<span class="comment">#随机删除集合中的一个元素</span></span><br></pre></td></tr></table></figure></div>

<h6 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure></div>

<h6 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure></div>

<h6 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></div>

<h6 id="集合内置方法"><a href="#集合内置方法" class="headerlink" title="集合内置方法"></a>集合内置方法</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add()		<span class="comment">#为集合添加元素</span></span><br><span class="line">clear()		<span class="comment">#移除集合中的所有元素</span></span><br><span class="line">copy()		<span class="comment">#拷贝一个集合</span></span><br><span class="line">difference()	<span class="comment">#返回多个集合的差集</span></span><br><span class="line">difference_update()		<span class="comment">#移除集合中的元素，该元素在指定的集合也存在。</span></span><br><span class="line">discard()		<span class="comment">#删除集合中指定的元素</span></span><br><span class="line">intersection()		<span class="comment">#返回集合的交集</span></span><br><span class="line">intersection_update()		<span class="comment">#返回集合的交集</span></span><br><span class="line">isdisjoint()		<span class="comment">#判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</span></span><br><span class="line">issubset()			<span class="comment">#判断指定集合是否为该方法参数集合的子集。</span></span><br><span class="line">issuperset()		<span class="comment">#判断该方法的参数集合是否为指定集合的子集</span></span><br><span class="line">pop()		<span class="comment">#随机移除元素</span></span><br><span class="line">remove()	<span class="comment">#移除指定元素</span></span><br><span class="line">symmetric_difference()		<span class="comment">#返回两个集合中不重复的元素集合</span></span><br><span class="line">symmetric_difference_update()	</span><br><span class="line"><span class="comment">#移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中</span></span><br><span class="line">union()			<span class="comment">#返回两个集合的并集</span></span><br><span class="line">update()		<span class="comment">#给集合添加元素</span></span><br></pre></td></tr></table></figure></div>

<h5 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h5><ul>
<li>列表是有序的对象集合，字典是无序的对象集合，两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取</li>
<li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合</li>
<li>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中</li>
<li>键(key)必须使用不可变类型</li>
</ul>
<h6 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h6><p>把相应的键放入到方括号中：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tinydict['Name']: "</span>, tinydict[<span class="string">'Name'</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tinydict['Age']: "</span>, tinydict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure></div>

<h6 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h6><p>增加新的键/值对，修改或删除已有键/值对：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line">tinydict[<span class="string">'Age'</span>] = <span class="number">8</span>                <span class="comment"># 更新 Age</span></span><br><span class="line">tinydict[<span class="string">'School'</span>] = <span class="string">"菜鸟教程"</span>  	<span class="comment"># 添加信息</span></span><br></pre></td></tr></table></figure></div>

<h6 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">'Name'</span>] <span class="comment"># 删除键 'Name'</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br></pre></td></tr></table></figure></div>

<h6 id="字典键特性"><a href="#字典键特性" class="headerlink" title="字典键特性"></a>字典键特性</h6><ul>
<li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</li>
<li>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</li>
</ul>
<h6 id="字典内置函数和方法"><a href="#字典内置函数和方法" class="headerlink" title="字典内置函数和方法"></a>字典内置函数和方法</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">dict</span>)	<span class="comment">#计算字典元素个数，即键的总数</span></span><br><span class="line"><span class="built_in">str</span>(<span class="built_in">dict</span>)	<span class="comment">#输出字典，可以打印的字符串表示</span></span><br><span class="line"><span class="built_in">type</span>(variable)	<span class="comment">#返回输入的变量类型，如果变量是字典就返回字典类型</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.clear()	<span class="comment">#删除字典内所有元素</span></span><br><span class="line"><span class="built_in">dict</span>.copy()		<span class="comment">#返回一个字典的浅复制</span></span><br><span class="line"><span class="built_in">dict</span>.fromkeys()		<span class="comment">#创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</span></span><br><span class="line"><span class="built_in">dict</span>.get(key, default=<span class="literal">None</span>)		<span class="comment">#返回指定键的值，如果键不在字典中返回 default 设置的默认值</span></span><br><span class="line">key <span class="keyword">in</span> <span class="built_in">dict</span>		<span class="comment">#如果键在字典dict里返回true，否则返回false</span></span><br><span class="line"><span class="built_in">dict</span>.items()	<span class="comment">#以列表返回一个视图对象</span></span><br><span class="line"><span class="built_in">dict</span>.keys()		<span class="comment">#返回一个视图对象</span></span><br><span class="line"><span class="built_in">dict</span>.setdefault(key, default=<span class="literal">None</span>)		<span class="comment">#和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</span></span><br><span class="line"><span class="built_in">dict</span>.update(dict2)		<span class="comment">#把字典dict2的键/值对更新到dict里</span></span><br><span class="line"><span class="built_in">dict</span>.values()		<span class="comment">#返回一个视图对象</span></span><br><span class="line">pop(key[,default])		<span class="comment">#删除字典 key（键）所对应的值，返回被删除的值</span></span><br><span class="line">popitem()	<span class="comment">#返回并删除字典中的最后一对键和值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><ul>
<li>自动将一种数据类型转换为另一种数据类型</li>
<li>较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失</li>
<li>某些情况（例如字符串与整数相加）无法隐式转换</li>
</ul>
<h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><p>使用 int()、float()、str() 等预定义函数来执行显式类型转换</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="built_in">int</span>(<span class="number">2.8</span>) <span class="comment"># y 输出结果为 2</span></span><br><span class="line">w = <span class="built_in">float</span>(<span class="string">"4.2"</span>) <span class="comment"># w 输出结果为 4.2</span></span><br><span class="line">z = <span class="built_in">str</span>(<span class="number">3.0</span>)  <span class="comment"># z 输出结果为 '3.0'</span></span><br></pre></td></tr></table></figure></div>

<p>以下几个内置的函数可以执行数据类型之间的转换，这些函数返回一个新的对象，表示转换的值：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a class="link" href="https://www.runoob.com/python/python-func-int.html">int(x[,base]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将x转换为一个整数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-float.html">float(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将x转换到一个浮点数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python/python-func-complex.html">complex(real[,imag]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">创建一个复数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-str.html">str(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-repr.html">repr(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-eval.html">eval(str) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python3-att-list-list.html">list(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-set.html">set(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">转换为可变集合</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-dict.html">dict(d) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">转换为不可变集合</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-chr.html">chr(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-ord.html">ord(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-hex.html">hex(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-oct.html">oct(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">+, -, *, /, %, **, //</span><br></pre></td></tr></table></figure></div>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">==, !=, &gt;, &lt; , &gt;=, &lt;=</span><br></pre></td></tr></table></figure></div>

<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">=, +=, -=, *=, /=, %=, **=, //=, :=</span><br></pre></td></tr></table></figure></div>

<p>(<code>:=</code>是海象运算符，可在表达式内部为变量赋值)</p>
<h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>假设a为10， b为20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th align="left">逻辑表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td align="left">x and y</td>
<td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值</td>
<td align="left">(a and b) 返回 20</td>
</tr>
<tr>
<td>or</td>
<td align="left">x or y</td>
<td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值</td>
<td align="left">(a or b) 返回 10</td>
</tr>
<tr>
<td>not</td>
<td align="left">not x</td>
<td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True</td>
<td align="left">not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h5 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#in, not in</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"变量 a 在给定的列表中 list 中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"变量 a 不在给定的列表中 list 中"</span>)</span><br></pre></td></tr></table></figure></div>

<p>指示指定序列中是否包含元素</p>
<h5 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(x) != id(y)**，如果引用的不是同一个对象则返回结果 True，否则返回 False</td>
</tr>
</tbody></table>
<p><strong>注：</strong> <a class="link" href="https://www.runoob.com/python/python-func-id.html">id() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 函数用于获取对象内存地址</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"1 - a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"1 - a 和 b 没有相同的标识"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">id</span>(a) == <span class="built_in">id</span>(b) ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"2 - a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"2 - a 和 b 没有相同的标识"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#1 - a 和 b 有相同的标识</span></span><br><span class="line"><span class="comment">#2 - a 和 b 有相同的标识</span></span><br></pre></td></tr></table></figure></div>

<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure></div>

<p>注：</p>
<ul>
<li><strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong></li>
<li>每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块</li>
<li>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块</li>
</ul>
<h5 id="match…case"><a href="#match…case" class="headerlink" title="match…case"></a>match…case</h5><p>match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，**_** 可以匹配一切:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure></div>

<p>实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    <span class="keyword">match</span> status:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Bad request"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Not found"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I'm a teapot"</span></span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Something's wrong with the internet"</span></span><br></pre></td></tr></table></figure></div>

<p>一个 case 也可以设置多个匹配条件，条件使用 <strong>｜</strong> 隔开</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>一般格式为：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure></div>

<p>注：</p>
<ul>
<li>同样需要注意冒号和缩进</li>
<li>Python 中没有 do..while 循环</li>
</ul>
<h5 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h5><p>如果while 后面的条件语句为 false 时，则执行 else 的语句块：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:    </span><br><span class="line">	&lt;statements&gt; </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">	&lt;statements&gt;</span><br></pre></td></tr></table></figure></div>

<p>实例如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sites = [<span class="string">"Baidu"</span>, <span class="string">"Google"</span>,<span class="string">"Runoob"</span>,<span class="string">"Taobao"</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="built_in">print</span>(site)</span><br><span class="line">    </span><br><span class="line">word = <span class="string">'runoob'</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">    <span class="built_in">print</span>(letter)</span><br></pre></td></tr></table></figure></div>

<h5 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h5><p>当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure></div>

<h5 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h5><p>会返回指定区间的值：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	     <span class="built_in">print</span>(i)</span><br><span class="line">	</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">     </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">     </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></div>

<h5 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h5><p>Python pass是空语句，是为了保持程序结构的完整性</p>
<p>pass 不做任何事情，一般用做占位语句:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">'执行 pass 块'</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br></pre></td></tr></table></figure></div>

<h3 id="Python推导式"><a href="#Python推导式" class="headerlink" title="Python推导式"></a>Python推导式</h3><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line">或者 </span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure></div>

<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">new_names = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">'ALICE'</span>, <span class="string">'JERRY'</span>, <span class="string">'WENDY'</span>, <span class="string">'SMITH'</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">{ key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection }</span><br><span class="line">或</span><br><span class="line">{ key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition }</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">listdemo = [<span class="string">'Google'</span>,<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line">newdict = {key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo}</span><br><span class="line"><span class="comment">#{'Google': 6, 'Runoob': 6, 'Taobao': 6}</span></span><br></pre></td></tr></table></figure></div>

<h5 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">{ expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> }</span><br><span class="line">或</span><br><span class="line">{ expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional }</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = {x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>}</span><br><span class="line"><span class="comment">#{'d', 'r'}</span></span><br></pre></td></tr></table></figure></div>

<h5 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h5><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure></div>

<p>元组推导式返回的结果是一个生成器对象:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代是Python访问集合元素的一种方式</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可使用for进行常规遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#也可以使用 next() 函数</span></span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></div>

<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><ul>
<li>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）</li>
<li>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield</strong> 后面的表达式作为当前迭代的值返回</li>
<li>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果</li>
</ul>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure></div>

<p>使用 yield 实现斐波那契数列：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></div>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong></li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算面积函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_welcome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome"</span>, name)</span><br><span class="line"> </span><br><span class="line">print_welcome(<span class="string">"Runoob"</span>)</span><br><span class="line">w = <span class="number">4</span></span><br><span class="line">h = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"width ="</span>, w, <span class="string">" height ="</span>, h, <span class="string">" area ="</span>, area(w, h))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Welcome Runoob</span></span><br><span class="line"><span class="string">width = 4  height = 5  area = 20</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><h6 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h6><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值，例如</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure></div>

<h6 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h6><p>调用函数时，如果没有传递参数，则会使用默认参数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"------------------------"</span>)</span><br><span class="line">printinfo( name=<span class="string">"runoob"</span> )	<span class="comment">#age = 35</span></span><br></pre></td></tr></table></figure></div>

<h6 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></div>

<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">70</span></span><br><span class="line"><span class="string">(60, 50)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<p>还有一种就是参数带两个星号 ******基本语法如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] **var_args_dict </span>):</span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></div>

<p>加了两个星号 ****** 的参数会以字典的形式导入:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">{'a': 2, 'b': 3}</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>Python 使用 <strong>lambda</strong> 来创建匿名函数</p>
<p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"相加后的值为 : "</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"相加后的值为 : "</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure></div>

<p>将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> a : a * n</span><br><span class="line"> </span><br><span class="line">mydoubler = myfunc(<span class="number">2</span>)	<span class="comment">#a*2</span></span><br><span class="line">mytripler = myfunc(<span class="number">3</span>)	<span class="comment">#a*3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(mydoubler(<span class="number">11</span>))	<span class="comment">#22</span></span><br><span class="line"><span class="built_in">print</span>(mytripler(<span class="number">11</span>))	<span class="comment">#33</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 1</title>
    <url>/2023/03/17/1Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%201/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第一单元作业总的训练目标是对表达式结构进行建模，体会层次化的思想，三次作业为迭代开发。第一次作业是完成对多项式括号的展开，第二次作业新引入了三角函数(sin,cos)以及自定义函数(f(x),g(x,y),h(x,y,z))，第三次作业新增求导因子(dx(表达式))并允许函数定义时调用其他已定义过的函数。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>我的总思路分为三步：</p>
<ol>
<li>预处理表达式</li>
<li>解析表达式</li>
<li>转化为字符串并打印</li>
</ol>
<h4 id="预处理表达式"><a href="#预处理表达式" class="headerlink" title="预处理表达式"></a>预处理表达式</h4><h5 id="PreStr"><a href="#PreStr" class="headerlink" title="PreStr"></a><code>PreStr</code></h5><p>预处理：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed81ddac507ccd3d7d8.png#pic_center"></p>
<ul>
<li>去除所有连续的空白字符（用Java自带的方法<code>replaceAll</code>即可解决）</li>
<li>通过一系列<code>replaceAll</code>使得字符串不含有连续的两个及以上的’+’和’-‘（例如”—-“应化为”+”，”+-“应化为”-“）</li>
<li>将表示幂次的”**”替换为”^”，防止与乘号弄混，产生不必要的bug</li>
</ul>
<h4 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h4><h5 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a><code>Lexer</code></h5><p>读取处理：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc1e.png#pic_center"></p>
<ul>
<li><code>read()</code>能够保证每次取出当前的操作数或者运算符</li>
<li><code>next()</code>能够往后读一个操作数或者运算符</li>
<li>由于数字长度的不确定，使用<code>getNumber()</code>能够取出当前数字</li>
</ul>
<h5 id="Ele"><a href="#Ele" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>根据题目要求，我选择新建一个<code>Ele</code>类完成对基本元素的存储，每一个<code>Ele</code>应形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd382e8.png#pic_center"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd38349.png#pic_center"></p>
<p><code>coe</code>存储每一个<code>Ele</code>的系数，<code>hashVar</code>通过<code>HashMap</code>存储变量及其对应幂次。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a935.png#pic_center"></p>
<p>刚开始写<code>Ele</code>时只写了<code>setCoe()</code>,<code>getCoe()</code>,<code>setHashVar()</code>,<code>getHashVar()</code>四个方法用于设定值和取值，其他方法是在后续框架的整体搭建中书写的，因此放到后面讲解。</p>
<h5 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>一连串的表达式形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd382fe.png#pic_center"></p>
<p>此处系数本身是可能带符号的，因此直接用加号相连。</p>
<p>为了方便数据的调用，我选择<code>ArrayList</code>来存储多个<code>Ele</code>：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a95c.png#pic_center"></p>
<p><code>Expr</code>方法中，<code>initExperList(ArrayList&lt;Ele&gt;)</code>,<code>initExpr(Ele)</code>用于初始化，<code>getExperlist()</code>用于取出该<code>ArrayList</code>，其他很多方法是在构建整体的过程中完成的，因此也放到后面。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a9a2.png#pic_center"></p>
<h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a><code>Parser</code></h5><p>使用递归下降解析表达式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39dc3.png#pic_center"></p>
<p>注：<code>dealEx(Expr)</code>是<code>parseExpr()</code>的一部分，分离出来是因为方法过长影响码风:）</p>
<p>1.<code>parseExpr()</code>用于解析表达式，根据定义，表达式由加法和减法运算符连接若干项组成并且在第一项之前，可以带一个正号或者负号，表示第一个项的正负，因此考虑如下结构。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">parseExpr</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (当前符号 == <span class="string">'+'</span> || 当前符号 == <span class="string">'-'</span>) { <span class="comment">//表达式的第一个项可以有符号（+，-）</span></span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (当前符号 == <span class="string">'+'</span> || 当前符号 == <span class="string">'-'</span>) {</span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<p>此处涉及到正负号的处理，因此不在方法中区分加减，而是新建合并的方法<code>Expr.combTerm(ArrayList&lt;Ele&gt; list, String s)</code>，<code>s</code>代表符号。若<code>s</code>为负号，就通过<code>Expr.reverseList(ArrayList&lt;Ele&gt; list)</code>取反，然后使用<code>addAll()</code>，考虑性能，我们需要化简，在<code>combTerm</code>之后使用<code>merge()</code>合并同类项。</p>
<p>2.<code>parseTerm()</code>用于解析项，项由乘法运算符连接若干因子组成，总体架构与上文相似，只是要重新写一个乘法的方法，也就是<code>Expr.mulTerm(ArrayList&lt;Ele&gt;)</code>能够实现两个<code>ArrayList&lt;Ele&gt;</code>的相乘（实际上就是多个相加）。</p>
<p>3.<code>parseFactor()</code>用于解析因子。由定义知，因子包括幂函数，常数因子和表达式因子。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">parseFactor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (符号 == <span class="string">'('</span>) { <span class="comment">//表达式因子，函数表达式（已在PreStr中套上了一层括号，因此也可以当成表达式因子处理）</span></span><br><span class="line">            parseExpr();</span><br><span class="line">            <span class="keyword">if</span> (下一个符号是<span class="string">'^'</span>) { <span class="comment">//下一个一定为指数</span></span><br><span class="line">                <span class="comment">//读入下一个整数n;</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) { <span class="comment">//考虑特殊情况</span></span><br><span class="line">                    <span class="comment">//置1;</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//重复的乘原表达式n-1次;</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (符号 == <span class="string">'+'</span> || 符号 == <span class="string">'-'</span>) { <span class="comment">//不是第一个带符号的因子，则一定为有符号常数</span></span><br><span class="line">            <span class="comment">//读入常数n并结合当前符号;</span></span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (符号为数字) { <span class="comment">//处理无符号整数</span></span><br><span class="line">           <span class="comment">// 读入常数n;</span></span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">//处理幂函数</span></span><br><span class="line">            <span class="keyword">return</span>  parsePow();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<p>4.<code>parsePow()</code>同上文分支一样，用于解析幂函数，并返回一个<code>Expr</code>类。这里单独写是因为方法行数太多影响码风：)</p>
<h4 id="转化为字符串并打印"><a href="#转化为字符串并打印" class="headerlink" title="转化为字符串并打印"></a>转化为字符串并打印</h4><p>这一点主要体现在<code>Expr</code>类中的<code>toString()</code>方法。总的思路是设置<code>StringBuilder</code>然后不断<code>append</code>。对<code>ArrayList</code>中的每一个<code>Ele</code>依次判断是否有’+’，是否为正负1，幂次是否为0，整体是否为0。（这一部分细节还挺多的需要特别注意）</p>
<h3 id="基于度量的程序结构分析"><a href="#基于度量的程序结构分析" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析"><a href="#代码规模分析" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b8ec.png#pic_center"></p>
<p>核心代码在450行左右，<code>Expr</code>类行数最多，占到了175行，其次是119行的解析<code>Parser</code>类。</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度"><a href="#方法复杂度" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">16</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.canMerge(Ele)</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">expr.Ele.compareTo(Object)</td>
<td align="left">7</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">expr.Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.isOne()</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">expr.Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.sort()</td>
<td align="left">9</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">expr.Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">118</td>
<td align="left">49</td>
<td align="left">109</td>
<td align="left">117</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">3.47</td>
<td align="left">1.44</td>
<td align="left">3.21</td>
<td align="left">3.44</td>
</tr>
</tbody></table>
<h5 id="类复杂度"><a href="#类复杂度" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b913.png"></p>
<p>表中可以看出最复杂的三个方法：<code>Parser.parseFactor()</code>，<code>expr.Expr.toString()</code>和<code>expr.Expr.varStr(Ele)</code>。由于因子的可能类型较多，讨论情况较多，因此复杂度也较高。后两者都是转化为字符串的方法，由于情况种类较多，因此复杂度上升较显著。</p>
<p>图中也能看到<code>Expr</code>类，<code>Ele</code>类和<code>Parser</code>类的复杂度较高，<code>Parser</code>类中分解的方法较多，<code>Expr</code>和<code>Ele</code>中计算合并之类的方法较多导致了这几个类的复杂度较高。</p>
<h6 id="附：度量分析条目解释"><a href="#附：度量分析条目解释" class="headerlink" title="附：度量分析条目解释"></a>附：度量分析条目解释</h6><ul>
<li>CogC：认知复杂度</li>
<li>ev(G)：非抽象方法的基本复杂度，用以衡量一个方法的控制流结构缺陷，范围是 [1, v(G)]</li>
<li>iv(G)：方法的设计复杂度，用以衡量方法控制流与其他方法之间的耦合程度，范围是 [1, v(G)]</li>
<li>v(G)：非抽象方法的圈复杂度，用以衡量每个方法中不同执行路径的数量</li>
<li>OC：类的非抽象方法圈复杂度，继承类不计入</li>
<li>WMC：类的总圈复杂度</li>
</ul>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39d21.jpg#pic_center"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业新增了这些要求：</p>
<ul>
<li>支持嵌套多层括号</li>
<li>新增三角函数因子，三角函数括号内部包含任意因子</li>
<li>新增自定义函数因子，但自定义函数的函数表达式中不会调用其他函数</li>
</ul>
<p>因此在第一次作业的基础上，需要完成这些工作：</p>
<ol>
<li>替换自定义函数</li>
<li>引入新的数据结构能够存储三角因子</li>
<li>增加或完善方法并完成三角函数的计算与化简</li>
</ol>
<h4 id="替换自定义函数"><a href="#替换自定义函数" class="headerlink" title="替换自定义函数"></a>替换自定义函数</h4><h5 id="DeFun"><a href="#DeFun" class="headerlink" title="DeFun"></a><code>DeFun</code></h5><p>仅仅实现替换，替换之后即可按照之前的递归下降实现表达式解析：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd3838f.png#pic_center"></p>
<ul>
<li>根据’=’分割成左右两字符串，左边的可根据’,’找出形参，将形参和右边的表达式存入<code>HashMap</code></li>
<li>在原表达式中通过<code>process()</code>替换所有的自定义函数</li>
</ul>
<h4 id="处理三角因子"><a href="#处理三角因子" class="headerlink" title="处理三角因子"></a>处理三角因子</h4><h5 id="Ele-1"><a href="#Ele-1" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>本次作业每个<code>Ele</code>类型应形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd3831e.png#pic_center"></p>
<p>将三角因子括号内部的因子<code>toString</code>作为<code>key</code>，指数作为<code>value</code>再存入<code>HashMap</code>：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a9d7.png#pic_center"></p>
<p>增加了处理三角因子的方法：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc7d.png"></p>
<h5 id="Expr-1"><a href="#Expr-1" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>加法和乘法只需在原有基础上添加三角因子的运算即可（加法乘法需要在<code>canMerge()</code>中添加条件)。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc2b.png"></p>
<p>在<code>toString()</code>中加上打印三角因子的方法<code>triStr(Ele)</code>。</p>
<h3 id="基于度量的程序结构分析-1"><a href="#基于度量的程序结构分析-1" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析-1"><a href="#代码规模分析-1" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b9a6.png"></p>
<p>核心代码在742行左右，<code>Expr</code>类行数最多，占到了259行，其次是150行的解析<code>Parser</code>类。</p>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度-1"><a href="#方法复杂度-1" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DeFun.max(int, int)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">DeFun.process(String)</td>
<td align="left">22</td>
<td align="left">6</td>
<td align="left">13</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">DeFun.readFun(String)</td>
<td align="left">6</td>
<td align="left">3</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">18</td>
<td align="left">5</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Parser.parseTri()</td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.canMerge(Ele)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">expr.Ele.compareTo(Object)</td>
<td align="left">27</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">expr.Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashCos()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashSin()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.isOne()</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">expr.Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.putHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Ele.putHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashCos(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashSin(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.simplify()</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">expr.Expr.sort()</td>
<td align="left">32</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">expr.Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.triStr(Ele)</td>
<td align="left">14</td>
<td align="left">1</td>
<td align="left">11</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">expr.Term.getTermList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">233</td>
<td align="left">90</td>
<td align="left">180</td>
<td align="left">195</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">4.75</td>
<td align="left">1.83</td>
<td align="left">3.67</td>
<td align="left">3.97</td>
</tr>
</tbody></table>
<h5 id="类复杂度-1"><a href="#类复杂度-1" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b9f2.png"></p>
<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b943.jpg"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业新增了这些要求：</p>
<ul>
<li>自定义函数定义时可以调用已经定义过的自定义函数</li>
<li>新增求导因子</li>
</ul>
<p>因此，在第二次作业的基础上，需要完成这些工作：</p>
<ol>
<li>在<code>DeFun</code>类中完善方法使支持调用定义过的自定义函数并且包含求导因子</li>
<li>在<code>Expr</code>类中新增求导的方法</li>
</ol>
<h4 id="完善替换自定义函数的方法"><a href="#完善替换自定义函数的方法" class="headerlink" title="完善替换自定义函数的方法"></a>完善替换自定义函数的方法</h4><h5 id="DeFun-1"><a href="#DeFun-1" class="headerlink" title="DeFun"></a><code>DeFun</code></h5><p>在同一个类中替换已经存在于HashMap中的自定义函数，然后替换求导因子（根据题目要求，需要在这里将求导因子化简并替换），因此我们直接复用之前的Parser类解析求导因子内部的表达式，并且用<code>toString()</code>替换原求导因子。</p>
<p>下面是可能的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.contains(<span class="string">"d"</span>)) { <span class="comment">//求导因子只出现一次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> str.indexOf(<span class="string">"d"</span>);</span><br><span class="line">            <span class="comment">//subString = dx(表达式) | dy(表达式) | dz(表达式)，是求导因子</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> sim.substring(<span class="comment">/*将dx()或dy()或dz()的子串提取出来*/</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">derFact</span> <span class="operator">=</span> subString.substring(<span class="number">2</span>); <span class="comment">//derFact是需要求导的表达式</span></span><br><span class="line">            parser.parseExpr();<span class="comment">//预处理，解析，返回一个Expr类</span></span><br><span class="line">            expr.derExpr();<span class="comment">//括号内的表达式进行求导能够返回一个Expr类</span></span><br><span class="line">            str = str.replace(subString, <span class="string">"("</span> + expr + <span class="string">")"</span>); <span class="comment">//将整个求导因子剔除（替换）</span></span><br><span class="line">        }</span><br></pre></td></tr></table></figure></div>

<h4 id="增加求导的方法"><a href="#增加求导的方法" class="headerlink" title="增加求导的方法"></a>增加求导的方法</h4><h5 id="Ele-2"><a href="#Ele-2" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>在<code>Ele</code>中增加方法支持判断该<code>Ele</code>是否包含该变量（’x’,’y’,’z’)，若不包含，则求导的结果为零，反之则可进行正常的求导。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39cef.png"></p>
<h5 id="Expr-2"><a href="#Expr-2" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>增加支持求导的方法，<code>derExpr(char)</code>中对参数<code>char</code>作为自变量求导，分别对每一个<code>Ele</code>的变量部分，三角因子部分进行求导再合并。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a8f4.png"></p>
<h3 id="基于度量的程序结构分析-2"><a href="#基于度量的程序结构分析-2" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析-2"><a href="#代码规模分析-2" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeecf1ddac507ccd3cb6a.png"></p>
<p>核心代码在899行左右，<code>Expr</code>类行数最多，占到了370行，其次是173行的解析<code>Expr</code>类。</p>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度-2"><a href="#方法复杂度-2" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DeFun.findRi(int, String)</td>
<td align="left">9</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">DeFun.max(int, int)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">DeFun.process(String)</td>
<td align="left">10</td>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">DeFun.readFun(String)</td>
<td align="left">7</td>
<td align="left">3</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.canMerge(Ele)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Ele.compareTo(Object)</td>
<td align="left">27</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Ele.cosContain(String)</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashCos()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashSin()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.isOne()</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.putHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.putHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashCos(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashSin(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.sinContain(String)</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.varContain(String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.derCos(int, String)</td>
<td align="left">7</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Expr.derExpr(char)</td>
<td align="left">14</td>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">Expr.derSin(int, String)</td>
<td align="left">7</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Expr.derVar(int, String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.simplify()</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Expr.sort()</td>
<td align="left">32</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">Expr.triStr(Ele)</td>
<td align="left">22</td>
<td align="left">1</td>
<td align="left">13</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">6</td>
<td align="left">2</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseDer(char)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">20</td>
<td align="left">6</td>
<td align="left">14</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Parser.parseTri()</td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">277</td>
<td align="left">102</td>
<td align="left">214</td>
<td align="left">230</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">4.85</td>
<td align="left">1.79</td>
<td align="left">3.75</td>
<td align="left">4.04</td>
</tr>
</tbody></table>
<h5 id="类复杂度-2"><a href="#类复杂度-2" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeecf1ddac507ccd3cb95.png"></p>
<p>图中也能看到<code>Expr</code>类，<code>Ele</code>类和<code>Parser</code>类的复杂度较高，Expr类中大量的化简、计算和求导方法使得该类复杂度很高。</p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39d81.jpg"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><h3 id="分析自己程序的bug"><a href="#分析自己程序的bug" class="headerlink" title="分析自己程序的bug"></a>分析自己程序的bug</h3><h5 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h5><ul>
<li>一些特殊点的情况，例如：0^0+5^0+2*10^0，需要提前做好调试并在<code>toString()</code>中修改</li>
</ul>
<h5 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h5><ul>
<li>替换自定义函数时根据逗号分割，因此在面对嵌套函数例如f(g(y,z),h(x,y),sin(x))中存在多于2个逗号的情况可能会出错，解决方案是每次循环找到最靠后的一个自定义函数（保证这个函数里异地没有嵌套的自定义）进行替换</li>
<li>注意替换时索引的位置，例如f((((x,y,z))))可能会出现括号判断错误</li>
<li>注意特殊和边界点，例如sin((0))^2,sin((0))^0,cos((0))^3</li>
<li>幂次为0时应该直接读取整数而不是往后解析表达式（大概是脑子抽了才这样写，大部分类似的问题全都是这点引起的）</li>
</ul>
<h5 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h5><ul>
<li>求导之后化简会出问题，例如dx(x*cos(x)**0)最后解析得到的Expr没有问题但是输出会出错，原因在于我判断cos部分含不含x是根据HashMap是否为空（第二次作业的遗留），但是在求导之后我没有进行相应的remove工作，导致输出错误</li>
</ul>
<h3 id="分析他人程序的bug"><a href="#分析他人程序的bug" class="headerlink" title="分析他人程序的bug"></a>分析他人程序的bug</h3><p>手动构造具有代表性的边界数据，拥有多层嵌套括号，同时包含特殊条件（结果为0，1，求导内部无自变量），例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title function_">f</span>(x,y)=(((<span class="title function_">sin</span>(<span class="title function_">cos</span>(x))-(+<span class="number">1</span>-<span class="title function_">sin</span>(<span class="title function_">cos</span>(y))))))</span><br><span class="line"><span class="title function_">f</span>((<span class="title function_">sin</span>(x)),(y**<span class="number">2</span>-<span class="number">0</span>**<span class="number">0</span>))+<span class="title function_">cos</span>(<span class="number">0</span>)**<span class="number">0</span>-<span class="title function_">sin</span>(<span class="number">0</span>)**<span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="title function_">dx</span>(x*<span class="title function_">cos</span>(x)**<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>第一单元作业主要是针对表达式括号展开和求导的三次迭代开发。从最开始的不理解git的作用，到现在渐渐认识到版本管理在工程中的重要性；从对IDEA的无所适从和屡次犯错，到逐渐领略到这款IDE功能的强大；从最开始的对Java感到陌生，到逐渐熟悉它的众多优良简便的方法、数据结构和其面向对象的思维。同时，三次作业对代码风格的要求使我进一步意识到码风的重要性并逐渐内在地提升了自己编程的码风。第一次作业由于只有整体的架构，在缺少对Java语法以及数据结构等知识的缺乏的情况下，完成得非常艰难。在第二次第三次的迭代开发中，任务量明显比第一次的从零开始要轻松一些，但是要特别特别注意类以及方法之间的耦合性，尽量不改变现有的方法，这样更容易发现代码的bug。最后，我认为可以多参考讨论区里同学们的设计思路，这对于我的架构设计有很大的帮助^_^ 感谢助教和同学们的热心帮助！</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading and Questions about The Building Method of Modern Software Engineering</title>
    <url>/2024/03/08/7Reading%20and%20Questions%20about%20The%20Building%20Method%20Modern%20Software%20Engineering/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">这个作业属于哪个课程</td>
<td><a class="link" href="https://bbs.csdn.net/forums/buaa-ase2024">2024年北航敏捷软件工程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">这个作业的要求在哪里</td>
<td><a class="link" href="https://bbs.csdn.net/topics/618159304">个人作业：阅读和提问 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">我在这个课程的目标是</td>
<td>学习并实践软件工程，提升自己的工程能力和团队协作能力</td>
</tr>
<tr>
<td align="left">这个作业在哪个具体方面帮助我实现目标</td>
<td>培养自己的思考能力，去形成自己分析问题、解决问题的思路</td>
</tr>
</tbody></table>
<h4 id="阅读提问"><a href="#阅读提问" class="headerlink" title="阅读提问"></a>阅读提问</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote>
<p>向进度落后的项目中增加人员，会让项目更加落后。	–《人月神话》</p>
</blockquote>
<p>我在书中第1.2.3节，第15页上方看到了这句话。在网上查找资料后我了解到，增加人员仍会使项目更加落后的原因是：</p>
<ul>
<li><strong>“关键时间”的浪费</strong>：新人对项目不了解，所以项目组需要抽调人员培训新人，这样不仅新人自己帮不上忙，还要浪费浪费项目组成员的关键时间</li>
<li><strong>“沟通时间”的增加</strong>：新加的人员需要增加额外的沟通来消除彼此之间对项目的不同认识，<strong>一个团队内部的沟通方式总数=n*(n-1)/2</strong></li>
<li><strong>“等待时间”的消耗</strong>：在实际项目中，总项目已经细分为分项目（一个人的工作量），分项目往往具有先后顺序，所以新加进来的人发挥不了作用，造成了等待时间的消耗</li>
</ul>
<p>我的问题是 如果现实中互联网企业发生了项目进度落后的情况（通常由于一些成员个人的原因），团队leader应该在不增加人员的情况下采取什么措施保证项目进度呢，这些措施是否有效呢？</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote>
<p>结对编程中有两个角色：</p>
<ol>
<li>驾驶员（Driver）：控制键盘输入</li>
<li>领航员（Navigator）：起到领航、提醒的作用</li>
</ol>
<p>这两个角色是可以互换的……</p>
</blockquote>
<p>我在书中4.5.1节，第79页上方看到了这一段话。我了解到在越野赛车中，驾驶员和领航员的身份往往不轻易互换，因为驾驶员的驾驶技术往往更胜一筹，而领航员的领航技术往往也是更强的。但是在实际的结对编程中，两人是不断变化角色的，因为结对编程是一个相互磨合的渐进过程，不论谁的资历等级更高抑或是设计编程的能力更强，双方都拥有平等的决策权力，所以这样的比喻（越野赛车的驾驶和领航员）我认为不妥当。</p>
<h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote>
<p>1969年代，程序员Melvin Conway就总结了一个康威规律：</p>
<p>一个机构设计出来的系统，它的体系结构注定会沿用这个机构的内部交流模式。</p>
</blockquote>
<p>我在书中第5.2.10节，第95页上方看到了这一段话。这句话大概意思是说组织内部的工作和交流方式，会极大地影响系统的设计。但是这会带来一个问题，团队模式不会轻易改变，但是系统的架构或者模式可能会随着时间推移不断优化和完善，这样一来可能导致组织架构和系统架构的失配，从这个角度来看这个规律变得不正确了，这是否是一种悖论或者”陷阱“？</p>
<h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote>
<p>团队成员往往各抒己见，争执地不亦乐乎，但是最后谁也说服不了谁，还有一些人觉得无从下手，干脆不参加讨论。在这种情况下，可以考虑通过Wideband Delphi方法来做到快速沟通并达到意见的一致。</p>
</blockquote>
<p>我在书中8.6.2节，第171页上方看到这一段话。这一方法反映了生活中遇到的团队意见不一致的问题，并在后面给出了解决方法。我的问题是，Wideband Delphi方法确实一定程度上统一了所有人意见，但这些意见是否大概率是主持人自己的意见呢？作为一个moderator，他在主持讨论的时候会慢慢地说服我们他自己的意见，所以我对此抱有疑问，如果使用这个方法最终统一的意见大部分取决于主持人，就达不到讨论和统一意见的意义了。除此之外，我认为某些情况下人与人之间理解的差异还是很大的，这种情况该如何达到共识呢，或者如何界定共识的标准？</p>
<h5 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h5><blockquote>
<p>原则2</p>
<p>软件工程师应以其客户和雇主利益最大化的方式做事，与公众利益保持一致。</p>
</blockquote>
<p>我在书中17.8节，第407页看到了这段话。这一部分主要在讲软件工程师的职业道德，我的疑问是某些情况下雇主和客户的利益可能与公众利益冲突，比如用户隐私相关的事务。在这种情况下，要如何平衡各方利益呢？</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiling Design Docs</title>
    <url>/2023/12/25/6Compiling%20Design%20Docs/</url>
    <content><![CDATA[<p>我的编译器源代码存放于<strong><a class="link" href="https://github.com/LeostarR/Compiling-Techniques">https://github.com/LeostarR/Compiling-Techniques <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<h2 id="参考编译器设计"><a href="#参考编译器设计" class="headerlink" title="参考编译器设计"></a>参考编译器设计</h2><p>参考：<code>pl0-compiler.doc</code></p>
<h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>文档介绍了一个用Pascal语言编写的<code>pl0</code>语言的编译器，它包括四个主要部分：词法分析器、语法分析器、代码生成器和解释器。</p>
<ul>
<li><strong>词法分析器</strong>：它负责从源程序中读取字符，识别并返回单词符号，如标识符、保留字、运算符、界符等。</li>
<li><strong>语法分析器</strong>：它负责根据<code>pl0</code>语言的语法规则，分析单词符号的组合，构造出抽象语法树，并检查语法错误。</li>
<li><strong>代码生成器</strong>：它负责根据抽象语法树，生成一种中间代码，即指令序列，用于表示源程序的语义,存储在<code>code</code>数组中。</li>
<li><strong>解释器</strong>：负责对中间代码进行解释执行，模拟一个抽象机器，使用<code>栈</code>来存储数据和控制信息。</li>
</ul>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><ul>
<li>编译器的输入是一个文本文件，包含源程序的代码，文件名由用户输入。</li>
<li>编译器的输出是一个文本文件，包含中间代码的列表，以及解释执行的结果，输出到标准输出流。如果发生错误，编译器还会在标准错误流输出错误信息。</li>
</ul>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>编译器的源代码包含了所有的常量、类型、变量、函数和过程的定义。文件的主要结构如下：</p>
<ul>
<li>常量定义：定义了一些编译器需要用到的常量，如保留字的个数、标识符的最大长度、数字的最大位数、地址的最大值、嵌套层次的最大值、代码数组的大小等。</li>
<li>类型定义：定义了一些编译器需要用到的类型，如符号的枚举类型、标识符的字符串类型、符号集合的集合类型、指令的记录类型、符号表的记录类型等。</li>
<li>变量定义：定义了一些编译器需要用到的全局变量，如当前字符、当前符号、当前标识符、当前数字、字符计数、行长度、错误计数、代码索引、行缓冲区、指令数组、保留字数组、符号数组、助记符数组、声明开始符号集合、语句开始符号集合、因子开始符号集合、符号表等。</li>
<li>函数和过程定义：定义了一些编译器需要用到的函数和过程，如错误处理函数、获取字符过程、获取符号过程、生成指令过程、测试符号过程、分程序过程、解释执行过程、主程序过程等。</li>
</ul>
<h2 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h2><h3 id="总体结构-1"><a href="#总体结构-1" class="headerlink" title="总体结构"></a>总体结构</h3><p>编译器总体结构包括词法分析器(<code>LexicalTools</code>)，语法分析器(<code>GrammaticalTools</code>)，符号表工具(<code>SymbolTools</code>)，中间代码生成器(<code>IRTools_llvm</code>)和目标代码生成器(<code>MIPSTools</code>)，以<code>LLVM</code>为中间代码生成<code>MIPS</code>目标代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode          		   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">d-----       				  GrammaticalTools</span><br><span class="line">d-----       				  IRTools_llvm</span><br><span class="line">d-----       		  		  LexicalTools</span><br><span class="line">d-----       				  MIPSTools</span><br><span class="line">d-----       				  SymbolTools</span><br><span class="line">-a----       			 3191 Compiler.java</span><br></pre></td></tr></table></figure></div>



<h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><ul>
<li>每个分析器都能返回这一阶段解析的内容，在顶层模块控制输出请求</li>
<li><code>IRBuildFactory.java</code>提供了生成中间代码的接口</li>
</ul>
<h3 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h3><ul>
<li><p>顶层模块为<code>Compiler.java</code>，读入<code>testfile.txt</code>，然后进行词法语法分析，代码生成，控制输出等操作</p>
</li>
<li><p>词法分析器(<code>LexicalTools</code>)，<code>Lexer.java</code>用于分析单词，生成<code>ArrayList&lt;wordTuple&gt;</code>:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode                   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">-a----                  11639 Lexer.java</span><br><span class="line">-a----                    363 LexType.java</span><br><span class="line">-a----                   4681 wordTuple.java</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>语法分析器(<code>GrammaticalTools</code>)，<code>Parser.java</code>遍历单词，生成语法树：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode                   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">d-----                        GrammaticalTreeDef</span><br><span class="line">-a----                  60997 Parser.java</span><br></pre></td></tr></table></figure></div>

<p><code>GrammaticalTreeDef</code>是定义的树节点集合</p>
</li>
<li><p>符号表工具(<code>SymbolTools</code>)定义了符号(<code>Symbol</code>),符号表(<code>SymbolTable</code>)以及枚举的变量类型(<code>IdentType</code>:普通变量，1/2维数组，函数)：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode                   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">-a----                    116 IdentType.java</span><br><span class="line">-a----                   1782 Symbol.java</span><br><span class="line">-a----                   2242 SymbolTable.java</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>中间代码生成器(<code>IRTools_llvm</code>)，<code>Type</code>定义了<code>Value</code>的类型，<code>Value</code>是所有编译过程中所有<code>object</code>的抽象类，<code>IRBuildFactory</code>提供对外接口方便生成指令，<code>Visitor.java</code>进行语义分析，构建<code>LLVM_Module</code>并生成中间代码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode                   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">d-----                        Type</span><br><span class="line">d-----                        Value</span><br><span class="line">-a----                   7070 IRBuildFactory.java</span><br><span class="line">-a----                  60290 Visitor.java</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>目标代码生成器(<code>MIPSTools</code>)，<code>MipsInstructions</code>定义指令的抽象类，<code>Atom</code>定义指令的原子部分——立即数，寄存器和标签的抽象类，<code>Tools</code>定义<code>MIPS</code>语言的结构，最后使用<code>LLVMParser</code>对上面生成的<code>LLVM_Module</code>解析，生成<code>MIPS_Module</code>并输出目标代码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Mode                   Length Name</span><br><span class="line">----                   ------ ----</span><br><span class="line">d-----                        Atom</span><br><span class="line">d-----                        MipsInstructions</span><br><span class="line">d-----                        Tools</span><br><span class="line">-a----                  31282 LLVMParser.java</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h2><h3 id="编码前的设计"><a href="#编码前的设计" class="headerlink" title="编码前的设计"></a><strong>编码前的设计</strong></h3><ul>
<li><p>总的思路是将整个文件的内容视作一个超长字符串，将这个字符串识别出有效的信息（如标识符，关键字以及各种运算，操作符号等等）并保存，将无效信息（注释等）准确识别并丢弃</p>
</li>
<li><p>对需要的有效信息创建类，定义有用的字段，例如行号，类别码，名称，值（例如数字的值是int类型，而字符串的值是它本身String类型）：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">wordTuple</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String wordName;    	<span class="comment">//单词名，原字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String wordType;   	<span class="comment">//单词类，在枚举类中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object wordValue;   	<span class="comment">//单词值，可能是整数，也有可能是字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> wordLine;       	<span class="comment">//所在行数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wordColumn;     		<span class="comment">//所在列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> legitimate; 		<span class="comment">//是否合法，用于输出错误信息</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>列数和合法信息在本次作业中尚未使用到</p>
</li>
<li><p>在词法解析中，成功解析的所有单词将存入一个<code>ArrayList&lt;wordTuple&gt;</code>中便于之后的语法分析和本次作业的输出环节</p>
</li>
<li><p>在具体的解析过程中</p>
<ul>
<li>设置<code>curPos</code>表示当前的读的位置，读取过程中及时更新位置和行数</li>
<li>每读完一个单词要掠过所有的空格换行直到下一个有效字符</li>
</ul>
</li>
<li><p>对于单词首字符</p>
<ul>
<li>如果是字母或下划线，考虑标识符和保留字</li>
<li>如果是数字，考虑无符号整数</li>
<li>如果是冒号，考虑形式化字符串</li>
<li>其他有效符号，例如’+’,’*’,’&gt;’,”==”等所有出现在指导书中的单词类别符号</li>
<li>特别注意区分’/‘和两种注释，’==’和’=’,’&gt;=’和’=’,’&amp;&amp;’和’&amp;’等等</li>
</ul>
</li>
<li><p>最后记录单词名，类型，行数等重要信息</p>
</li>
</ul>
<h3 id="编码完成之后的修改"><a href="#编码完成之后的修改" class="headerlink" title="编码完成之后的修改"></a><strong>编码完成之后的修改</strong></h3><ul>
<li><p>重新定义枚举类<code>Lextype</code>表示单词类而不是简单的字符串，方便统一表示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lextype wordType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getLexType</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.wordType.toString();</span><br><span class="line">}			</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LexType</span> {</span><br><span class="line">    IDENFR, INTCON, STRCON, MAINTK, CONSTTK,</span><br><span class="line">    INTTK, BREAKTK, CONTINUETK, IFTK, ELSETK,</span><br><span class="line">    NOT, AND, OR, FORTK, GETINTTK,</span><br><span class="line">    PRINTFTK, RETURNTK, PLUS, MINU, VOIDTK,</span><br><span class="line">    MULT, DIV, MOD, LSS, LEQ,</span><br><span class="line">    GRE, GEQ, EQL, NEQ,</span><br><span class="line">    ASSIGN, SEMICN, COMMA, LPARENT, RPARENT,</span><br><span class="line">    LBRACK, RBRACK, LBRACE, RBRACE</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>设置了两个集合分别存储所有的保留字和单一符号，读取中判断是否在这两个集合中就行了，例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initReserveWords</span><span class="params">()</span> {</span><br><span class="line">        reserveWords.put(<span class="string">"main"</span>, LexType.MAINTK);</span><br><span class="line">        reserveWords.put(<span class="string">"const"</span>, LexType.CONSTTK);</span><br><span class="line">        reserveWords.put(<span class="string">"int"</span>, LexType.INTTK);</span><br><span class="line">        reserveWords.put(<span class="string">"break"</span>, LexType.BREAKTK);</span><br><span class="line">        reserveWords.put(<span class="string">"continue"</span>, LexType.CONTINUETK);</span><br><span class="line">        reserveWords.put(<span class="string">"if"</span>, LexType.IFTK);</span><br><span class="line">        reserveWords.put(<span class="string">"else"</span>, LexType.ELSETK);</span><br><span class="line">        reserveWords.put(<span class="string">"for"</span>, LexType.FORTK);</span><br><span class="line">        reserveWords.put(<span class="string">"getint"</span>, LexType.GETINTTK);</span><br><span class="line">        reserveWords.put(<span class="string">"printf"</span>, LexType.PRINTFTK);</span><br><span class="line">        reserveWords.put(<span class="string">"return"</span>, LexType.RETURNTK);</span><br><span class="line">        reserveWords.put(<span class="string">"void"</span>, LexType.VOIDTK);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">reserved</span><span class="params">(String s)</span> {</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.reserveWords.containsKey(s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>实际读取过程中采用<code>StringBuilder</code>类型更容易逐个添加字符</p>
</li>
</ul>
<h2 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h2><h3 id="编码前的设计-1"><a href="#编码前的设计-1" class="headerlink" title="编码前的设计"></a>编码前的设计</h3><ul>
<li><p>总任务是对所有单词进行语法分析并构建语法树，因此要对上一节词法分析得到的<code>ArrayList&lt;wordTuple&gt;</code>逐一分析</p>
</li>
<li><p>自定义语法树的节点类型，利用面向对象的继承性质，设置一个总的父类<code>MyTreeNode</code>，其余节点均继承此类，举例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeBlock</span> <span class="keyword">extends</span> <span class="title class_">MyTreeNode</span>;</span><br></pre></td></tr></table></figure></div>

<p>对文法每一个非终结符都做这样的操作，对于语法成分的子节点有多种情况的，可以建立多个构造方法覆盖所有的情况：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeAddExp</span> <span class="keyword">extends</span>  <span class="title class_">MyTreeNode</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeMulExp mulExp1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeAddExp addExp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> wordTuple operator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeMulExp mulExp2;</span><br><span class="line">    <span class="keyword">private</span> IdentType identType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeAddExp</span><span class="params">(<span class="type">int</span> lineNum, NodeMulExp mulExp1)</span> {</span><br><span class="line">        <span class="built_in">super</span>(lineNum);</span><br><span class="line">        <span class="built_in">this</span>.mulExp1 = mulExp1;</span><br><span class="line">        <span class="built_in">this</span>.addExp = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.operator = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.mulExp2 = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeAddExp</span><span class="params">(<span class="type">int</span> lineNum, NodeAddExp addExp, wordTuple operator, NodeMulExp mulExp2)</span> {</span><br><span class="line">        <span class="built_in">super</span>(lineNum);</span><br><span class="line">        <span class="built_in">this</span>.mulExp1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.addExp = addExp;</span><br><span class="line">        <span class="built_in">this</span>.operator = operator;</span><br><span class="line">        <span class="built_in">this</span>.mulExp2 = mulExp2;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对于文法<code>AddExp → MulExp | AddExp ('+' | '−') MulExp</code>，使用第一个构造方法的时候对应<code>AddExp → MulExp</code>，使用第二个构造方法的时候对应<code>AddExp → AddExp ('+' | '−') MulExp</code>，判断属于哪一种语法构造只需通过<code>getter()</code>判断特定子节点是否为<code>null</code>即可。</p>
</li>
<li><p>在<code>Parser</code>中采用递归下降完成整个语法分析的过程，由于给定的文法不算过于复杂，大部分<code>parse()</code>不需要回溯，根据<code>First(非终结符)</code>就能确定是何种语法成分:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> NodeDecl <span class="title function_">parseDecl</span><span class="params">()</span> {  <span class="comment">//Decl → ConstDecl | VarDecl</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isConstDecl()) {</span><br><span class="line">            <span class="type">NodeConstDecl</span> <span class="variable">constDecl</span> <span class="operator">=</span> <span class="built_in">this</span>.parseConstDecl();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeDecl</span>(constDecl.getLineNum(), constDecl);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">NodeVarDecl</span> <span class="variable">varDecl</span> <span class="operator">=</span> <span class="built_in">this</span>.parseVarDecl();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeDecl</span>(varDecl.getLineNum(), varDecl);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在解析<code>Stmt</code>的时候可能会遇到下面的情况，按照<code>LVal</code>和Exp解析都能成功解析出第一部分,这个时候需要回溯</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">//Exp <span class="string">';'</span>   LVal <span class="string">'='</span> Exp <span class="string">';'</span>    LVal <span class="string">'='</span> <span class="string">'getint'</span><span class="string">'('</span><span class="string">')'</span><span class="string">';'</span></span><br></pre></td></tr></table></figure></div>

<p>按照<code>Exp</code>解析，若得到下一个符号是’=’则排除前一种情况，回溯，按照<code>LVal</code>解析。</p>
</li>
<li><p>所有语法成分解析完成后将会得到一颗完整的语法树，为之后的语义分析和代码生成做准备</p>
</li>
</ul>
<h3 id="编码完成之后的修改-1"><a href="#编码完成之后的修改-1" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><ul>
<li><p>和设计时差别不大，但是需要新建几个继承<code>NodeStmt</code>的子节点，例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeStmtBr</span> <span class="keyword">extends</span> <span class="title class_">NodeStmt</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> wordTuple type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeStmtBr</span><span class="params">(<span class="type">int</span> lineNum, wordTuple type)</span> {</span><br><span class="line">        <span class="built_in">super</span>(lineNum);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> wordTuple <span class="title function_">getType</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>表示<code>Stmt → 'break' ';' | 'continue' ';'</code>的情况，其他由<code>Stmt</code>推导的语法成分同理</p>
</li>
</ul>
<h2 id="错误处理设计"><a href="#错误处理设计" class="headerlink" title="错误处理设计"></a>错误处理设计</h2><h3 id="编码前的设计-2"><a href="#编码前的设计-2" class="headerlink" title="编码前的设计"></a>编码前的设计</h3><ul>
<li><p>a类错误在词法分析就可判断，当判断出字符串时，检查是否包含非法字符即可：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'"'</span>) {                  <span class="comment">//形式化字符串</span></span><br><span class="line">            <span class="keyword">while</span> (curPos &lt; source.length() &amp;&amp; source.charAt(curPos) != <span class="string">'"'</span>) {</span><br><span class="line">                c = source.charAt(curPos++);</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (curPos &lt; source.length() &amp;&amp; source.charAt(curPos) == <span class="string">'"'</span>) {</span><br><span class="line">                c = source.charAt(curPos++);</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            token = <span class="keyword">new</span> <span class="title class_">String</span>(sb);</span><br><span class="line">            type = LexType.STRCON;</span><br><span class="line">            value = <span class="keyword">new</span> <span class="title class_">String</span>(sb);</span><br><span class="line">    <span class="comment">/************************************************/</span></span><br><span class="line">            <span class="built_in">this</span>.legitimate = <span class="built_in">this</span>.checkErrorA();	<span class="comment">//此处判断</span></span><br><span class="line">    <span class="comment">/************************************************/</span></span><br><span class="line">}</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>需要新建符号表处理<code>b-h</code>类错误，符号表的主要结构如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SymbolTable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fatherId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Symbol symbol;    <span class="comment">//函数名，最外层函数的此值为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SymbolTable preTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;SymbolTable&gt; nextTables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Symbol&gt; varSets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Symbol&gt; funcSets;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>所有符号表存储在一个<code>ArrayList</code>中，<code>id</code>是符号表的索引，全局变量常量以及函数所在的符号表的<code>id</code>为0，<code>fatherId</code>是外层符号表的索引，<code>varSets</code>和<code>funcSets</code>存储当前作用域定义的变量和函数</p>
</li>
<li><p>在语法分析过程中定义和使用变量和函数(<code>ident</code>)之前查阅符号表即可判断<code>b,c</code>类错误：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defNewVar</span><span class="params">(wordTuple ident, IdentType identType, <span class="type">boolean</span> isConst)</span> {</span><br><span class="line">        <span class="type">SymbolTable</span> <span class="variable">curTable</span> <span class="operator">=</span> <span class="built_in">this</span>.tables.get(<span class="built_in">this</span>.curIndex);</span><br><span class="line">        <span class="keyword">if</span> (curTable.containsVar(ident.getWordName()) || curTable.containsFunc(ident.getWordName())) {    </span><br><span class="line">            		<span class="comment">//重复定义，报错</span></span><br><span class="line">            <span class="built_in">this</span>.checkErrorB(ident.getWordLine());</span><br><span class="line">        } <span class="keyword">else</span> {    <span class="comment">//否则，填表</span></span><br><span class="line">            <span class="type">Symbol</span> <span class="variable">symbol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(<span class="built_in">this</span>.wordList.indexOf(ident), <span class="built_in">this</span>.curIndex, ident, identType, isConst);</span><br><span class="line">            curTable.addVar(ident.getWordName(), symbol);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>d,e,f,g</code>类错误一边解析一边完成即可，对于函数符号，根据参数信息可以判断类型正确性和参数个数正确性，根据返回类型判断<code>return</code>的正确性</p>
</li>
<li><p>符号缺失的错误都可以像这样判断：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.token.isSemi()) {</span><br><span class="line">                System.out.println(token.getLexType() + <span class="string">" "</span> + token.getWordName());</span><br><span class="line">                <span class="built_in">this</span>.next();</span><br><span class="line"> } <span class="keyword">else</span> {    <span class="comment">//分号缺失</span></span><br><span class="line">                <span class="built_in">this</span>.checkErrorI(lineNum);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在进入循环体时，传入参数表示当前处于循环中，即可判断<code>m</code>类错误</p>
</li>
</ul>
<h3 id="编码完成之后的修改-2"><a href="#编码完成之后的修改-2" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><ul>
<li><p>在考虑重定义时既要考虑变量重定义也要考虑函数重定义，例如下面的例子是非法的：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fff = <span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fff</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>所以必须检查两个<code>HashMap</code>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curTable.containsVar(ident.getWordName()) || curTable.containsFunc(ident.getWordName())) {   </span><br><span class="line">    		<span class="comment">//重复定义，报错</span></span><br><span class="line">            <span class="built_in">this</span>.checkErrorB(ident.getWordLine());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>之前只对同类型进行检查，忽略了其他函数和变量不同类型的重定义</p>
</li>
</ul>
<h2 id="代码生成设计"><a href="#代码生成设计" class="headerlink" title="代码生成设计"></a>代码生成设计</h2><h3 id="编码前的设计-3"><a href="#编码前的设计-3" class="headerlink" title="编码前的设计"></a>编码前的设计</h3><h4 id="中间代码生成IRTools-llvm"><a href="#中间代码生成IRTools-llvm" class="headerlink" title="中间代码生成IRTools_llvm"></a>中间代码生成<code>IRTools_llvm</code></h4><ul>
<li><p><code>Type</code>:<code>Value</code>的各种类型，拿数组类型举例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeArray</span> <span class="keyword">extends</span> <span class="title class_">Type</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numOfElement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type typeOfElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TypeArray</span><span class="params">(<span class="type">int</span> numOfElement, Type typeOfElement)</span> {    </span><br><span class="line">        <span class="comment">//numOfElement-&gt;数组一维空间的size，即多少个元素, typeOfElement-&gt;每一个元素的type（应相同）</span></span><br><span class="line">        <span class="built_in">this</span>.numOfElement = numOfElement;</span><br><span class="line">        <span class="built_in">this</span>.typeOfElement = typeOfElement;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfElement</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.numOfElement;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type <span class="title function_">getTypeOfElement</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.typeOfElement;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSpace</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.numOfElement * <span class="built_in">this</span>.typeOfElement.getSpace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + <span class="built_in">this</span>.numOfElement + <span class="string">" x "</span> + <span class="built_in">this</span>.typeOfElement.toString() + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>它可以指示这个数组Value的维数（如果是二维，那么<code>typeOfElement</code>也是’<code>TypeArray</code>‘类型的，除此之外还重写<code>toString()</code>方法，方便输出指令</p>
</li>
<li><p><code>Value</code>:万物皆Value，不论是顶层的<code>LLVM_Module</code>，还是基本块<code>BasicBlock</code>，还是函数<code>Function</code>都是<code>Value</code>，因此让他们全部继承抽象类<code>Value.java</code>，而<code>User</code>一般指指令，但同时指令也是一种<code>Value</code>，因此它也要继承<code>Value</code>，<code>Value</code>和<code>User</code>类似于一条边的两个节点，关系通过<code>Use</code>维护：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Value</span> {</span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Value&gt; operands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Type type, Value parent)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, type, parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(Value value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.operands.add(value);</span><br><span class="line">        <span class="type">Use</span> <span class="variable">use</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Use</span>(<span class="built_in">this</span>, value, operands.indexOf(value));</span><br><span class="line">        value.addUse(use);</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>以<code>BasicBlock</code>为例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicBlock</span> <span class="keyword">extends</span> <span class="title class_">Value</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BasicBlock&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Instruction&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasicBlock</span><span class="params">(String name, Value parent)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, <span class="keyword">new</span> <span class="title class_">TypeLabel</span>(), parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstruction</span><span class="params">(Instruction instruction)</span> {</span><br><span class="line">        <span class="built_in">this</span>.instructions.add(instruction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Instruction&gt; <span class="title function_">getInstructions</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instructions;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>以二进制运算And指令为例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinAnd</span> <span class="keyword">extends</span> <span class="title class_">InstructonOfBinary</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinAnd</span><span class="params">(String name, Value v1, Value v2, BasicBlock parent)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, <span class="keyword">new</span> <span class="title class_">TypeInt</span>(<span class="number">32</span>), parent);</span><br><span class="line">        <span class="built_in">this</span>.addValue(v1);</span><br><span class="line">        <span class="built_in">this</span>.addValue(v2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getName() +</span><br><span class="line">                <span class="string">" = and "</span> +</span><br><span class="line">                <span class="built_in">this</span>.getType() +</span><br><span class="line">                <span class="string">" "</span> +</span><br><span class="line">                <span class="built_in">this</span>.getValue(<span class="number">0</span>).getName() +</span><br><span class="line">                <span class="string">", "</span>  +</span><br><span class="line">                <span class="built_in">this</span>.getValue(<span class="number">1</span>).getName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>Visitor</code>接收语法分析得到的语法树根节点<code>(NodeCompUnit) compUnit</code>，向下递归进行语义分析，举例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visitNodeDecl</span><span class="params">(NodeDecl decl)</span> {                         <span class="comment">//声明 Decl → ConstDecl | VarDecl</span></span><br><span class="line">        <span class="type">NodeConstDecl</span> <span class="variable">constDecl</span> <span class="operator">=</span> decl.getConstDecl();</span><br><span class="line">        <span class="type">NodeVarDecl</span> <span class="variable">varDecl</span> <span class="operator">=</span> decl.getVarDecl();</span><br><span class="line">        <span class="keyword">if</span> (varDecl == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.visitConstDecl(constDecl);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.visitNodeVarDecl(varDecl);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>分析过程中，借用全局变量curVal和curInt等值传递属性，生成LLVM指令：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visitNodeConstDef</span><span class="params">(NodeConstDef constDef)</span> {             </span><br><span class="line">    	<span class="comment">//常数定义 ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal</span></span><br><span class="line">        <span class="type">wordTuple</span> <span class="variable">ident</span> <span class="operator">=</span> constDef.getIdent();</span><br><span class="line">        ArrayList&lt;NodeConstExp&gt; constExps = constDef.getConstExps();</span><br><span class="line">        <span class="type">NodeConstInitVal</span> <span class="variable">constInitVal</span> <span class="operator">=</span> constDef.getConstInitVal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ident.getWordName();</span><br><span class="line">        <span class="keyword">if</span> (constExps.isEmpty()) {          <span class="comment">//0维数组（常数）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.symbolIndex == <span class="number">0</span>) {    <span class="comment">//全局</span></span><br><span class="line">                <span class="built_in">this</span>.isInit = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">this</span>.visitNodeConstInitVal(constInitVal);</span><br><span class="line">                <span class="built_in">this</span>.isInit = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">GlobalVar</span> <span class="variable">globalVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalVar</span>(name, <span class="literal">true</span>, (Const) <span class="built_in">this</span>.curVal);</span><br><span class="line">                <span class="built_in">this</span>.storeVal(name, globalVar);</span><br><span class="line">                Module.getInstance().addGlobalVar(globalVar);</span><br><span class="line">            }</span><br><span class="line">            ......</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>短路求值，对形如<code>if (A || B) {...} else {...}</code> 的语句当A为真时不能执行B而是直接跳转到A的语句块，因此 设置两个全局块<code>curIfBlock</code>和<code>cueElseBlock</code>，在递归向下解析时传递参数<code>flag</code>指示是否需要更改<code>cueElseBlock</code>的值，如果当前在解析A则需要更改<code>curElseBlock</code>为新建的基本块（描述B），如果当前在解析B则无需修改<code>cueElseBlock</code>:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.visitNodeLOrExp(nodelOrExp, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) {</span><br><span class="line">	<span class="built_in">this</span>.visitNodeLAndExp(lAndExp2, <span class="literal">true</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	<span class="type">BasicBlock</span> <span class="variable">nextBlock</span> <span class="operator">=</span> IRBuildFactory.buildBasicBlock(<span class="built_in">this</span>.curFunction);</span><br><span class="line">	<span class="built_in">this</span>.curElseBlock = nextBlock;</span><br><span class="line">	<span class="built_in">this</span>.visitNodeLAndExp(lAndExp2, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">this</span>.curBasicBlock = nextBlock;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>isCruit</code>指示是否为表达式，如果是，则需要通过<code>Icmp</code>指令将表达式转化为值：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.isCruit) {</span><br><span class="line">    ......</span><br><span class="line">	<span class="built_in">this</span>.curVal = </span><br><span class="line">        IRBuildFactory.buildBinIcmp(BinIcmpType.NE, <span class="built_in">this</span>.curVal, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(<span class="number">32</span>, <span class="number">0</span>), <span class="built_in">this</span>.curBasicBlock);</span><br><span class="line">	<span class="built_in">this</span>.isCruit = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="目标代码生成MIPSTools"><a href="#目标代码生成MIPSTools" class="headerlink" title="目标代码生成MIPSTools"></a>目标代码生成<code>MIPSTools</code></h4><ul>
<li><p><code>Atom</code>：指令的原子组成部分，包括寄存器，立即数还有跳转指令用到的标签，以寄存器为例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reg</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reg</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$zero"</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$at"</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">this</span>.id &lt;= <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$v"</span> + (<span class="built_in">this</span>.id - <span class="number">2</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt;= <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.id &lt;= <span class="number">7</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$a"</span> + (<span class="built_in">this</span>.id - <span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt;= <span class="number">8</span> &amp;&amp; <span class="built_in">this</span>.id &lt;= <span class="number">15</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$t"</span> + (<span class="built_in">this</span>.id - <span class="number">8</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt;=<span class="number">16</span> &amp;&amp; <span class="built_in">this</span>.id &lt;= <span class="number">23</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$s"</span> + (<span class="built_in">this</span>.id - <span class="number">16</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt;= <span class="number">24</span> &amp;&amp; <span class="built_in">this</span>.id &lt;= <span class="number">25</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$t"</span> + (<span class="built_in">this</span>.id - <span class="number">24</span> + <span class="number">8</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">28</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$gp"</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">29</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$sp"</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">30</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$fp"</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.id == <span class="number">31</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"$ra"</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"$"</span> + <span class="built_in">this</span>.id;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>只提供了返回寄存器名字的方法</p>
</li>
<li><p><code>MipsInstructions</code>：各种<code>MIPS</code>指令的抽象类，包括二进制运算指令，跳转指令，存取指令以及其他简化指令等:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryPure</span> <span class="keyword">extends</span> <span class="title class_">MIPSInstruction</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryPureType opType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reg rd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reg rs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reg rt;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryPure</span><span class="params">(BinaryPureType opType, Reg rd, Reg rs, Reg rt)</span> {</span><br><span class="line">        <span class="built_in">this</span>.opType = opType;</span><br><span class="line">        <span class="built_in">this</span>.rd = rd;</span><br><span class="line">        <span class="built_in">this</span>.rs = rs;</span><br><span class="line">        <span class="built_in">this</span>.rt = rt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> opType.toString() + <span class="string">" "</span> + rd.getName() + <span class="string">", "</span> + rs.getName() + <span class="string">", "</span> + rt.getName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BinaryPureType</span> {</span><br><span class="line">    addu,</span><br><span class="line">    subu,</span><br><span class="line">    and,</span><br><span class="line">    or;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>Tools</code>完成对MIPS代码的抽象化，包括模块<code>Module</code>，全局变量<code>GlobalVar</code>，代码块<code>Block</code>以及函数<code>Function</code>:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIPSBlock</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String blockName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BasicBlock basicBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MIPSFunction mipsFunction;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;MIPSInstruction&gt; Instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MIPSBlock</span><span class="params">(String blockName, BasicBlock basicBlock, MIPSFunction mipsFunction)</span> {</span><br><span class="line">        <span class="built_in">this</span>.blockName = blockName;</span><br><span class="line">        <span class="built_in">this</span>.basicBlock = basicBlock;</span><br><span class="line">        <span class="built_in">this</span>.mipsFunction = mipsFunction;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstruction</span><span class="params">(MIPSInstruction instruction)</span> {</span><br><span class="line">        <span class="built_in">this</span>.Instructions.add(instruction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBlockName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.blockName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BasicBlock <span class="title function_">getBasicBlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.basicBlock;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MIPSFunction <span class="title function_">getParentMipsFunction</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mipsFunction;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用<code>LLVMParser</code>解析得到的<code>LLVMModule</code>，全局变量可以直接存入<code>Module</code>然后输出即可，对于函数需要分析每一条指令，根据每一条指令属于LLVM指令的类型进行生成：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> MemAlloca) {</span><br><span class="line">	......      </span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> MemGetelementptr) {</span><br><span class="line">	......</span><br><span class="line">}</span><br><span class="line">	......</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="编码完成之后的修改-3"><a href="#编码完成之后的修改-3" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><ul>
<li>增加<code>ZextTo</code>指令，如果不定义这条指令，生成的<code>llvm</code>中间代码会有问题，<code>i32</code>类型和<code>i1</code>类型不能通过<code>icmp</code>指令进行比较，因此在语义分析过程中处理<code>icmp</code>指令之前对<code>curVal</code>的<code>Type</code>进行判断</li>
</ul>
<h2 id="代码优化设计"><a href="#代码优化设计" class="headerlink" title="代码优化设计"></a>代码优化设计</h2><h3 id="编码前的设计-4"><a href="#编码前的设计-4" class="headerlink" title="编码前的设计"></a>编码前的设计</h3><h4 id="中端优化"><a href="#中端优化" class="headerlink" title="中端优化"></a>中端优化</h4><ul>
<li>删除无用函数，遍历<code>LLVM_Module</code>的所有函数，判断每一个函数的<code>userList</code>是否为空，（主要是<code>br</code>指令），若为空则删除并维护use-value的基本关系，遍历剩下的函数直到函数集合不发生变化</li>
<li>删除无用基本快，不可到达的基本块应该删除，并维护use-value的基本关系</li>
<li>合并基本块，从一个没有后继的基本块开始遍历，递归查找能到达这个的唯一基本块（如果不唯一应该停止查找）</li>
<li>删除死代码</li>
</ul>
<h4 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h4><ul>
<li>乘除优化，乘法判端常数是否是2的整数次幂，转化为移位指令，除法将除法指令转化为乘法指令和移位指令</li>
<li>基本块合并</li>
</ul>
<h3 id="编码完成之后的修改-4"><a href="#编码完成之后的修改-4" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><p>删除函数的时候要对函数的每个基本快的每个指令进行use-value的维护</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>compile technology</tag>
      </tags>
  </entry>
  <entry>
    <title>Individual assignment：Analysis of Software Examples</title>
    <url>/2024/03/17/8Individual%20assignment%EF%BC%9AAnalysis%20of%20Software%20Examples/</url>
    <content><![CDATA[<h1 id="代码仓库管理系统"><a href="#代码仓库管理系统" class="headerlink" title="代码仓库管理系统"></a>代码仓库管理系统</h1><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">这个作业属于哪个课程</td>
<td align="left"><a class="link" href="https://bbs.csdn.net/forums/buaa-ase2024?typeId=6559174">2024年北航敏捷软件工程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">这个作业的要求在哪里</td>
<td align="left"><a class="link" href="https://bbs.csdn.net/topics/618159312">个人作业：软件案例分析 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">我在这个课程的目标是</td>
<td align="left">学习敏捷软件工程开发的知识，锻炼工程能力</td>
</tr>
<tr>
<td align="left">这个作业在哪个<strong>具体方面</strong>帮助我实现目标</td>
<td align="left">通过各种现有软件的案例分析，评测，总结并体验软件工程的原则在实践中的种种体现，学好软件工程，帮助我们在实践中做得更好</td>
</tr>
</tbody></table>
<h2 id="第一部分-调研，评测"><a href="#第一部分-调研，评测" class="headerlink" title="第一部分 调研，评测"></a>第一部分 调研，评测</h2><p>本次作业选择代码仓库管理系统<a class="link" href="https://gitcode.net/">GitCode <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="软件评测"><a href="#软件评测" class="headerlink" title="软件评测"></a>软件评测</h3><h4 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h4><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><p>这里是笔者已经使用过一些功能后的界面，如果初次登陆会与下图略有不同<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa5af9f345e8d03684826.png" alt="image-20240314155923765"></p>
<h5 id="查看项目"><a href="#查看项目" class="headerlink" title="查看项目"></a>查看项目</h5><p>我的所有项目</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa5da9f345e8d0368fb1c.png" alt="image-20240314160527814"></p>
<p>项目内部细节</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa5ed9f345e8d036948a8.png" alt="image-20240314161106297"></p>
<h5 id="查看组织"><a href="#查看组织" class="headerlink" title="查看组织"></a>查看组织</h5><p>我的所有组织</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6029f345e8d03699de4.png" alt="image-20240314160648008"></p>
<p>组织内部细节</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6199f345e8d0369fde4.png" alt="image-20240314161356308"></p>
<h5 id="查看个人主页"><a href="#查看个人主页" class="headerlink" title="查看个人主页"></a>查看个人主页</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6299f345e8d036a3e82.png" alt="image-20240314160710090"></p>
<h5 id="查看Issue"><a href="#查看Issue" class="headerlink" title="查看Issue"></a>查看Issue</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa63f9f345e8d036a96ae.png" alt="image-20240314160740502"></p>
<h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6799f345e8d036b864a.png" alt="image-20240314160956109"></p>
<h4 id="软件分析"><a href="#软件分析" class="headerlink" title="软件分析"></a>软件分析</h4><p>基本流程：通过主页右上角的加号图标新建项目、组织或者代码片段（组织内部可以新建项目）</p>
<p>​									      <img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa68b9f345e8d036bc576.png" alt="image-20240314161723817"></p>
<ol>
<li>项目：可通过三种方式创建新项目<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6a39f345e8d036c16c5.png" alt="image-20240314162119743"></li>
<li>组织：按照要求新建组织<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6b59f345e8d036c55dc.png" alt="image-20240314162145707"></li>
<li>代码片段：按照要求新建代码片段<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6e59f345e8d036d1046.png" alt="image-20240314162355843"></li>
</ol>
<p>管理代码：每个仓库提供<code>ssh</code>或者<code>https</code>克隆到本地，也可直接下载。本地通过git提交推送可以完成远程仓库的更新。并且提供邀请成员合作，讨论Issue解决方案等功能。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa6f49f345e8d036d4836.png" alt="image-20240314162446562"></p>
<p>对于普通的代码仓库管理系统而言，需要满足<strong>存储代码，多人协作，版本管理，组织管理</strong>等功能。所以该软件<strong>能够解决用户的需求</strong>。</p>
<h4 id="其他评价"><a href="#其他评价" class="headerlink" title="其他评价"></a>其他评价</h4><p>数据量：</p>
<ul>
<li>优点：服务人数多，”一亿人的安全代码仓”</li>
<li>缺点：代码量大时导入仓库和推送时较慢</li>
</ul>
<p>界面</p>
<ul>
<li>优点：简洁干净，没有广告，可以专注于自己的事务</li>
<li>缺点：除个别功能不能在第一时间找到外暂无明显缺点</li>
</ul>
<p>准确度</p>
<ul>
<li>优点：搜索结果比较准确</li>
<li>缺点：搜索开源项目没有排序功能，例如佳匹配，最多Star，最多forks</li>
</ul>
<p>用户体验</p>
<ul>
<li>优点：中文版整体汉化程度很高，可以选择不同语言，体验较好</li>
<li>缺点：部分用户认为Issue也应该翻译成英文，其它一些用户对界面不够满意</li>
</ul>
<h4 id="改进意见"><a href="#改进意见" class="headerlink" title="改进意见"></a><strong>改进意见</strong></h4><ol>
<li>GitCode是CSDN为开发者提供的开源项目创新服务平台，这两者是否可以联系更紧密一些呢？例如GitCode主页可以加上一个直接访问CSDN的链接，就像CSDN主页提供直接访问GitCode的快捷入口一样</li>
<li>多关注一下用户反馈里的issue，一百多条反馈都没人处理</li>
<li>搜索项目式添加最佳匹配，最多Star，最多forks的过滤器，并且搜索页面底部应该明确能跳转到第几页，而不是只能往前一页和后一页，如果想要回到第一页很困难<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7039f345e8d036d7d30.png" alt="image-20240314192029766"></li>
</ol>
<h4 id="用户调研"><a href="#用户调研" class="headerlink" title="用户调研"></a><strong>用户调研</strong></h4><p>采访的同学来自6系另一位软工班级的木同学，采访截图如下</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7129f345e8d036db5ea.png" alt="微信图片_20240317095732"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7249f345e8d036dfdf4.png" alt="微信图片_20240317095749"></p>
<p>采访原因：他们的软工大作业有代码管理的需求，也需要这样一个代码仓库托管平台</p>
<p>使用的实际产品：GitCode</p>
<p>遇到的问题：</p>
<ol>
<li>仓库的README文件渲染有问题，不能正常显示图片和公式</li>
<li>搜索项目或者用户时，底部没有选择第几页的标识，只有回到上一页或者下一个的按钮。例如搜索名叫helloword的用户时结果数目99+，但是无法标识当前结果为第几页，想要回到某一页只能自己手动计数。</li>
</ol>
<p>亮点：</p>
<ol>
<li>对中文用户友好，并且支持多种语言</li>
<li>没有推广广告，界面整洁</li>
</ol>
<p>需要改进的地方：</p>
<ol>
<li>优化markdown语法渲染的问题</li>
<li>优化搜索界面，在底部添加计数器标识当前页并跳转其他页。</li>
</ol>
<h4 id="评测结论"><a href="#评测结论" class="headerlink" title="评测结论"></a><strong>评测结论</strong></h4><p>d) 好，不错</p>
<h3 id="Bug-分析和提交"><a href="#Bug-分析和提交" class="headerlink" title="Bug 分析和提交"></a>Bug 分析和提交</h3><table>
<thead>
<tr>
<th align="left">bug 严重等级</th>
<th align="left">标准</th>
</tr>
</thead>
<tbody><tr>
<td align="left">⭐⭐⭐⭐⭐</td>
<td align="left">致命性系统故障，能导致系统完全崩溃，或者引发严重的数据丢失，以及对安全性造成严重威胁</td>
</tr>
<tr>
<td align="left">⭐⭐⭐⭐</td>
<td align="left">严重系统故障，虽然不会导致系统完全崩溃，但仍可能引起重要功能的错误或者数据损坏</td>
</tr>
<tr>
<td align="left">⭐⭐⭐</td>
<td align="left">较大系统故障，可能会引发一些功能性的问题，但通常不会对系统的整体稳定性产生重大影响</td>
</tr>
<tr>
<td align="left">⭐⭐</td>
<td align="left">不影响正常运作的系统故障，对系统的影响较小，可能是一些界面上的错别字、格式问题或者不太明显的功能缺陷。</td>
</tr>
<tr>
<td align="left">⭐</td>
<td align="left">非系统故障，一些不影响系统功能和用户体验的小问题，或者是一些细微的视觉或者交互问题</td>
</tr>
</tbody></table>
<h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a><strong>测试环境</strong></h4><p>操作系统：Windows 11 家庭中文版</p>
<p>浏览器环境和版本：Google Chrome 版本 122.0.6261.112（正式版本） （64 位）</p>
<h4 id="Bug1-无法从github导入项目"><a href="#Bug1-无法从github导入项目" class="headerlink" title="Bug1 无法从github导入项目"></a>Bug1 无法从github导入项目</h4><h5 id="可复现性及具体复现步骤"><a href="#可复现性及具体复现步骤" class="headerlink" title="可复现性及具体复现步骤"></a><strong>可复现性及具体复现步骤</strong></h5><p><strong>必然发生</strong></p>
<p>具体描述：</p>
<ol>
<li><p>主页<strong>右上角加号</strong>点击新建项目，在弹出的界面选择<strong>导入项目</strong></p>
</li>
<li><p>点击<strong>从URL导入仓库</strong>，输入你想导入的<code>github</code>仓库地址，例如<a class="link" href="https://github.com/ozan-oktay/Attention-Gated-Networks.git%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E6%9C%80%E4%B8%8B%E6%96%B9%E7%9A%84**%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE**%EF%BC%8C%E6%98%BE%E7%A4%BA**%E6%AD%A3%E5%9C%A8%E5%AF%BC%E5%85%A5">https://github.com/ozan-oktay/Attention-Gated-Networks.git，然后点击最下方的**新建项目**，显示**正在导入 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>**</p>
</li>
<li><p>提示导入成功，回到仓库查看，该仓库为空，没有导入任何数据，证明此功能无效</p>
</li>
<li><p>笔者又尝试了<code>GitHub</code>上的其他公开仓库，比如<a class="link" href="https://github.com/Issam28/Brain-tumor-segmentation%E6%88%96%E8%80%85https://github.com/himashi92/VT-UNet%E9%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98">https://github.com/Issam28/Brain-tumor-segmentation或者https://github.com/himashi92/VT-UNet都会出现这样的问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>如果从第二步开始点击从<code>GitHub</code>导入，根据提示我们需要输入自己的个人权限令牌（可以根据他给的<strong>链接</strong>跳转到<code>GitHub</code>获取），输入成功后当前网址会失效，笔者尝试数次都是同样的结果（所以这其实是两个bug，不管从<code>GitHub</code>或者输入url都不行）</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa73c9f345e8d036e6307.png" alt="image-20240314195316750"></p>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa74a9f345e8d036ea532.png" alt="image-20240314200143845"></p>
<h5 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h5><p><strong>可能成因</strong>：我认为他们根本没有实现这个功能，只是前端比划了一下。或者是准备做这个功能（因为前端已经做出来了），但是后端的具体实现一直没有时间完成。</p>
<p><strong>严重性</strong>：⭐⭐⭐</p>
<ol>
<li>系统功能：该bug会影响正常的导入功能</li>
<li>安全性：不会有严重的安全泄露问题</li>
<li>用户体验：较差，感觉受到了欺骗</li>
</ol>
<p><strong>发现的 bug，为何软件团队不能在发布前修复？</strong>我认为他们知道这一问题，但是他们敷衍了事，认为这个功能不重要。</p>
<p><strong>BUG 改进建议</strong>：此处正常行为应该自动将需要导入的远程仓库导入到新创建的仓库。</p>
<p><strong>如何实现？</strong>写一个正常地导入远程仓库的程序，将远程仓库的地址换成用户输入的地址。</p>
<h4 id="Bug2-Markdown渲染bug"><a href="#Bug2-Markdown渲染bug" class="headerlink" title="Bug2 Markdown渲染bug"></a>Bug2 Markdown渲染bug</h4><h5 id="可复现性及具体复现步骤-1"><a href="#可复现性及具体复现步骤-1" class="headerlink" title="可复现性及具体复现步骤"></a><strong>可复现性及具体复现步骤</strong></h5><p>必然发生</p>
<p>具体描述：</p>
<p>仓库的<code>README</code>文件不能展示公式甚至图片。</p>
<p>步骤：</p>
<ol>
<li>本地git仓库中新建README文件，里面内容大致如下(docker.png是同目录下的图片)：<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa75c9f345e8d036ef1fb.png" alt="image-20240314204126171">本地渲染效果大致如下<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa77a9f345e8d036f63fb.png" alt="image-20240314204326188"></li>
<li>通过git命令将更新后的文件推送至远程仓库</li>
<li>远程仓库看到的README文件实际效果为<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7969f345e8d036fd70f.png" alt="image-20240314204444055">可以清楚地看到公式渲染失败，图片未显示，但是如果在这个界面点击README.md文件去查看具体的文件内容，会出现<img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7a99f345e8d037024c6.png" alt="image-20240314204613223">图片在这个界面能够正常显示，但是公式仍不行。</li>
</ol>
<p>为什么说这是一个bug而不是feature？对于公式而言，姑且可以认为它的功能缺失不完善，不支持渲染公式。但是对于图片来说，点开具体文件能够渲染图片，但是在仓库主页不行，表现得不一致，所以这里是一个bug。</p>
<h5 id="bug分析-1"><a href="#bug分析-1" class="headerlink" title="bug分析"></a>bug分析</h5><p><strong>可能成因</strong>：对于图片来说，我猜想的原因是，不支持相对路径，只支持绝对路径（所以必须通过图床这样的方式），并且项目主页的渲染代码和文件内部的渲染代码没有同步；对于公式，他们根本没有实现这个功能。</p>
<p><strong>严重性</strong>：⭐⭐</p>
<ol>
<li>系统功能：该bug会影响显示图片，公式等功能</li>
<li>安全性：不会有严重的安全泄露问题</li>
<li>用户体验：较差，无法通过常用的方式展示自己仓库的简介图片等</li>
</ol>
<p><strong>发现的 bug，为何软件团队不能在发布前修复？</strong>我认为他们知道这一问题，并且修复过，但是开发人员粗心大意，仓库主页的渲染代码没有同步；渲染公式这一功能没有实现。</p>
<p><strong>BUG 改进建议</strong>：正常的行为应该是远程仓库渲染和本地渲染一样，能够展示出图片和公式。</p>
<p><strong>如何实现？</strong>将仓库主页的渲染逻辑和md文件内部的渲染逻辑保持一致；新增渲染公式的功能。</p>
<h4 id="Bug-反馈"><a href="#Bug-反馈" class="headerlink" title="Bug 反馈"></a><strong>Bug 反馈</strong></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7bd9f345e8d037074b9.png" alt="image-20240317103644387"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/65faa7cc9f345e8d0370b3b5.png" alt="image-20240317103725033"></p>
<h2 id="第二部分-分析-参考-8-6-节对工作的估计，和-14-1-节软件工程的质量"><a href="#第二部分-分析-参考-8-6-节对工作的估计，和-14-1-节软件工程的质量" class="headerlink" title="第二部分 分析(参考 8.6 节对工作的估计，和 14.1 节软件工程的质量)"></a>第二部分 分析(参考 8.6 节对工作的估计，和 14.1 节软件工程的质量)</h2><h3 id="工作量分析"><a href="#工作量分析" class="headerlink" title="工作量分析"></a><strong>工作量分析</strong></h3><ul>
<li><p><strong>功能范围定义和规划</strong>：需求收集，功能规划；与利益相关者进行沟通，确定平台的所有功能和需求，并将它们分解成可执行的任务。1个月</p>
</li>
<li><p><strong>技术栈选择和环境搭建，UI设计</strong>:评估不同的技术选择，进行原型开发和技术验证，并搭建好开发和测试环境，以及原型设计、用户研究、UI设计。1-2个月</p>
</li>
<li><p><strong>后端开发</strong>：包括数据库设计、API开发、业务逻辑开发等。4-6个月。</p>
</li>
<li><p><strong>前端开发</strong>：包括界面开发、交互设计、前端逻辑开发等。6-8个月。</p>
</li>
<li><p><strong>测试与质量保证</strong>：包括单元测试、集成测试、用户验收测试等。2-3个月。</p>
<p>此外还需要不断地迭代反馈，因此估计这个项目大概需要一年半以上的时间。</p>
</li>
</ul>
<h3 id="软件质量分析"><a href="#软件质量分析" class="headerlink" title="软件质量分析"></a><strong>软件质量分析</strong></h3><ol>
<li><p>分析这个软件目前的优劣（和类似软件相比），这个产品的质量在同类产品中估计名列第几？</p>
<p>和同类产品<code>GitHub</code>相比：</p>
<p>优点：</p>
<ol>
<li><strong>语言</strong>：完全支持中文，并且还提供其他语言（目前翻译不完善），适合中文社区，在中国访问更快</li>
<li><strong>社区</strong>：针对中国开发者的需求进行了一些定制化的功能和服务，比如集成了国内常用的开发工具、社区支持CSDN等，更好地适应了中国开发者的使用习惯</li>
</ol>
<p>缺点：</p>
<ol>
<li><strong>搜索界面</strong>：不支持页数跳转，只能一页一页地跳转</li>
<li><strong>渲染</strong>：markdown渲染问题，不能正确显示图片和公式</li>
<li><strong>邀请链接</strong>：不能通过邮件或者账号直接邀请对方加入仓库，而是只能生成链接再手动发给对方</li>
<li><strong>导入</strong>：不支持从其他仓库平台导入代码</li>
</ol>
<p>在同类产品中，能排第三或者第四（其他产品有<code>Github, GitLab, Gitee, GitLink</code>等)</p>
</li>
<li><p>从各方面的问题，推理出这个软件团队在软件工程方面可以提高的一个重要方面（具体建议）。</p>
<ol>
<li>重视用户建议和反馈，我在提issue反馈的时候发现GitCode官方帮助文档有一百多条待解决的issue</li>
<li>实事求是，不能敷衍了事，前端的导入代码功能应该和后端的导入保持一致，不能只做前端不管后端了</li>
</ol>
</li>
</ol>
<h2 id="第三部分-建议和规划"><a href="#第三部分-建议和规划" class="headerlink" title="第三部分 建议和规划"></a>第三部分 建议和规划</h2><ol>
<li><p><strong>市场现状</strong>：</p>
<ol>
<li><p><strong>市场概况</strong>：市场有多大？（直接用户有多少？潜在用户又有多少？）</p>
<p>直接用户有大约250万人（<strong>GitCode目前用户数量超245万</strong>，已有33万余个项目及近5万个组织入驻）。</p>
<p>潜在用户还包括国内社区其他未使用GitCode的用户，大概有500万人（中国程序员数量大概七百多万）。</p>
</li>
<li><p><strong>竞争产品</strong>：目前市场上有什么样的竞争产品？</p>
<p>竞争产品包括其他的代码仓库管理平台，例如</p>
<ol>
<li><code>GitHub</code>, 全球最大的基于 Git 的代码托管平台之一，被广泛用于开源项目协作和商业软件开发。它提供了强大的版本控制功能，包括分支管理、Pull Request（PR）审查、问题跟踪等。GitHub 也提供了丰富的社区功能，用户可以在平台上发现、贡献和共享开源项目。</li>
<li><code>Gitlab</code>, 以Git为核心的完整的DevOps平台，提供了代码托管、CI/CD、问题追踪、代码审查等功能。</li>
<li><code>Gitee</code>, 中国的一个代码托管平台，与 GitHub 类似，提供 Git 代码仓库托管服务以及问题跟踪、代码审查等功能。Gitee 在中国用户中较为流行，尤其受到国内开发者和企业的青睐，因为它能提供了更快的访问速度以及与国内其他开发工具的集成。</li>
<li><code>Gitlink</code>，一个新兴的代码托管平台，致力于提供更简洁、更高效的代码协作体验。它着重于简化工作流程和提高团队协作效率，通过直观的界面和易用的功能，吸引了一部分开发者和团队的关注。</li>
</ol>
</li>
<li><p><strong>产品定位</strong>：上述产品的定位、优势与劣势在哪里？以及竞争中的各方态势如何？</p>
<ol>
<li><strong>GitCode</strong>：<ul>
<li>定位：一个相对较新的代码托管平台，定位于为开发者和团队提供简洁、高效的代码管理和协作环境。</li>
<li>优势：有庞大的社区CSDN支持；汉化程度高，适合中文用户</li>
<li>劣势：功能上有缺陷，例如导入项目，搜索界面的filter等；没有引入AI新技术，其他平台例如Github引入了copilot新功能，Gitee也引入了Gitee AI；没有针对特定群体，例如Gitee还开发了针对特定群体的版本，例如高校版和企业版</li>
</ul>
</li>
<li><strong>GitHub</strong>：<ul>
<li>定位：GitHub 是全球最大的基于 Git 的代码托管平台，定位于开源社区和商业软件开发。</li>
<li>优势：拥有庞大的开源社区和丰富的开源项目资源，提供强大的协作工具和第三方集成支持，广泛应用于全球范围内的软件开发。</li>
<li>劣势：对于一些企业用户来说，可能缺乏一些企业级的功能和定制选项。</li>
</ul>
</li>
<li><strong>GitLab</strong>：<ul>
<li>定位：GitLab 是一个完整的 DevOps 平台，定位于为开发团队提供端到端的代码管理和协作解决方案。</li>
<li>优势：提供了完整的 DevOps 功能，包括代码托管、CI/CD、问题跟踪等，同时支持企业版和自托管选项，适用于各种规模和需求的组织。</li>
<li>劣势：相对于 GitHub，在开源社区和项目资源方面可能稍显不足。</li>
</ul>
</li>
<li><strong>Gitee</strong>：<ul>
<li>定位：Gitee 是中国的代码托管平台，定位于为中国开发者和企业提供快速、稳定的代码托管服务，同时提供与国内其他开发工具的集成。</li>
<li>优势：在中国用户中有较高的市场份额，提供了更快的访问速度和与国内其他工具的无缝集成，受到国内开发者和企业的青睐。</li>
<li>劣势：在国际市场上的影响力相对较弱，缺乏全球化的开源社区资源。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>市场与产品生态</strong>：</p>
<ol>
<li><p>这个产品的 <strong>核心用户群是什么样的人</strong>？典型用户是什么样的？学历，年龄，专业，爱好，收入，表面需求，潜在需求都是什么？</p>
<p><strong>核心</strong>用户群是企业的程序开发人员。</p>
<p><strong>典型</strong>用户以计算机或者软件工程专业为主的技术人员，或以科研任务为主的高校教师，学生等。学历较高，专业多以计算机相关或者软件工程专业为主，年龄主要在20-40之间，爱好编程，收入相对较高。表面需求是需要代码仓库平台为自己的工程做版本管理和存储，潜在需求包括职业晋升，升学，完成科研任务，论文等。</p>
</li>
<li><p>产品的用户群体之间是否存在一定的关系？如果有，则是否能利用这些关系构成特定的用户生态？</p>
<p>产品的用户群体都是计算机工程或者相关科研任务相关的用户，可以利用CSDN中文开发者社区，提供讨论计算机技术的平台，构建开发人员为主的用户生态。</p>
</li>
</ol>
</li>
<li><p><strong>产品规划</strong>：</p>
<ol>
<li><p>你要在 <strong>当前软件的基础上</strong> 设计什么样的新功能？为何要做这个功能，而不是其他功能？为什么用户会用你的产品/功能？你的创新在哪里？可以用 <strong>NABCD分析</strong>。</p>
<p>设计新功能<strong>基于AI的智能代码建议和改进建议</strong>。</p>
<ul>
<li><strong>Need（需求）</strong>：在软件开发过程中，开发者经常需要面对代码的优化和改进。然而，有时候对于一些复杂的代码结构或性能问题，开发者可能需要更多的指导和建议。因此，提供一个智能的代码建议和改进建议功能可以帮助开发者更轻松地优化代码、提高代码质量。</li>
<li><strong>Approach（方法）</strong>：设计一个基于机器学习和静态代码分析的智能代码建议和改进建议功能，通过分析代码结构、性能指标，为开发者提供个性化的建议和优化方案。</li>
<li><strong>Benefit（好处）</strong>：用户可以通过使用智能代码建议和改进建议功能来快速发现代码中的问题和潜在的优化空间，提高代码质量、性能和可维护性。同时，这个功能还能提高开发效率，减少用户在代码优化方面的工作量。</li>
<li><strong>Competition（竞争）</strong>：相较于其他代码托管平台，添加智能代码建议和改进建议功能的软件将提供更智能、更个性化的代码优化建议，为用户提供更丰富的功能和更好的用户体验。</li>
<li><strong>Delivery（交付）</strong>：通过主页的公告通知用户新功能的上线，同时在CSDN社区提供教程，视频等指导用户如何使用这一新功能。还可以提供一定的奖励机制鼓励用户使用新功能，在这一阶段可以通过收集反馈迭代优化新功能。</li>
</ul>
</li>
<li><p>如果你是项目经理，可以招聘 <strong>6个人</strong>，并且有 <strong>16周</strong> 的时间，你认为应该 <strong>如何配置角色</strong>（开发，测试，美工等等）才能在第 16 周如期发布软件的改进版本，并取得预想中的成绩。</p>
<p><strong>1</strong>名项目经理Project Manager：负责项目规划、进度管理、资源协调和沟通等工作，确保项目按时交付</p>
<p><strong>2</strong>名全栈工程师：负责新功能的设计、开发和测试。每个开发工程师应具备前后端开发的能力，能够独立完成任务，同时还要负责美工等。</p>
<p><strong>1</strong>名后端工程师：负责后端系统的设计和开发，包括数据库设计、API开发等</p>
<p><strong>1</strong>名前端工程师：负责前端界面的设计和开发，确保用户界面的友好性和响应性</p>
<p><strong>1</strong>名测试工程师：负责测试计划的制定、测试用例的编写和执行，确保软件质量和稳定性</p>
</li>
<li><p><strong>请为你的团队设计 16 个周每周的详细规划。</strong></p>
<ol>
<li>1周：确定项目目标、范围和需求；制定项目计划和时间表；配置开发环境和工具；明确每人的分工角色</li>
<li>2-3周：收集用户需求；完善新功能的设计和功能规划；确定技术实现方案和架构设计</li>
<li>4-6周：设计和实现后端系统的数据库结构；开发后端系统的核心功能和业务逻辑；进行后端系统的单元测试和集成测试</li>
<li>7-9周：开发前端界面的基本框架和布局；实现前端界面的主要功能模块；进行前端界面的初步测试和调试</li>
<li>10-11周：将前后端功能集成到一个完整的系统中；进行系统集成测试和用户验收测试；修复和优化已发现的问题和Bug</li>
<li>12-13周：进行系统性能优化，提高系统的稳定性和响应速度；完善功能细节，优化用户体验；准备文档和用户指南</li>
<li>14-15周：进行最后的系统测试和性能优化；解决项目中的剩余问题和Bug；准备发布软件的改进版本</li>
<li>16周：发布软件的改进版本，并进行宣传和推广；监控发布过程，确保软件的稳定性；收集用户反馈和意见。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch notes</title>
    <url>/2024/04/25/9PyTorch-notes/</url>
    <content><![CDATA[<h2 id="用PyTorch实现MNIST手写数字识别"><a href="#用PyTorch实现MNIST手写数字识别" class="headerlink" title="用PyTorch实现MNIST手写数字识别"></a>用PyTorch实现MNIST手写数字识别</h2><blockquote>
<p>PyTorch is an optimized tensor library for deep learning using GPUs and CPUs.</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6640b3380ea9cb140355f13d.png"></p>
<h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># torchvision是PyTorch的一个子模块，提供了一些常用的数据集、模型架构和图像转换工具</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="comment"># 导入DataLoader类，用于加载数据集并生成批次数据</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="comment"># 导入PyTorch的神经网络模块(neural network)，其中包含了构建神经网络所需的各种层和功能</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="comment"># 导入PyTorch的函数模块，其中包含了一些常用的神经网络操作函数，如激活函数、损失函数等</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="comment"># 导入PyTorch的优化器模块，用于配置和执行优化算法来更新神经网络的参数</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块，用于绘制图表</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></div>



<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历整个训练数据集的次数</span></span><br><span class="line">n_epochs = <span class="number">3</span></span><br><span class="line"><span class="comment"># 训练时每个批次的样本数</span></span><br><span class="line">batch_size_train = <span class="number">64</span></span><br><span class="line"><span class="comment"># 测试时每个批次的样本数</span></span><br><span class="line">batch_size_test = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 学习率，是优化器在更新参数时使用的步长</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="comment"># 动量参数，用于优化器的动量更新</span></span><br><span class="line">momentum = <span class="number">0.5</span></span><br><span class="line"><span class="comment"># 每隔多少个批次打印一次训练日志</span></span><br><span class="line">log_interval = <span class="number">10</span></span><br><span class="line"><span class="comment"># 定义和设置随机种子</span></span><br><span class="line">random_seed = <span class="number">1</span></span><br><span class="line">torch.manual_seed(random_seed)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>learning_rate</code>：学习率，是优化算法中的一个关键超参数，它决定了模型参数在每次迭代中更新的幅度大小。学习率越大，参数更新的步长就越大，模型可能更快地收敛到局部最优解，但也可能导致不稳定性或者错过全局最优解；学习率越小，参数更新的步长就越小，模型收敛速度可能较慢，但可能更容易得到更精确的结果</li>
<li><code>momentum</code>：在优化算法中，动量参数指定了每次参数更新时，上一步更新的动量对当前更新的影响程度。0.5意思是在每次参数更新时，当前梯度的贡献占50%，而上一步更新的动量占50%</li>
<li><code>torch.manual_seed(random_seed)</code>设置随机种子，可以使得每次程序运行时生成的随机数序列是一致的，从而使得程序的运行结果可复现。每次运行时都会得到相同的结果，而不会受到随机性的影响，这对于调试和结果验证非常有用</li>
</ul>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    torchvision.datasets.MNIST(<span class="string">'./data/'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                               transform=torchvision.transforms.Compose([</span><br><span class="line">                                   torchvision.transforms.ToTensor(),</span><br><span class="line">                                   torchvision.transforms.Normalize(</span><br><span class="line">                                       (<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                               ])),</span><br><span class="line">    batch_size=batch_size_train, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    torchvision.datasets.MNIST(<span class="string">'./data/'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>,</span><br><span class="line">                               transform=torchvision.transforms.Compose([</span><br><span class="line">                                   torchvision.transforms.ToTensor(),</span><br><span class="line">                                   torchvision.transforms.Normalize(</span><br><span class="line">                                       (<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                               ])),</span><br><span class="line">    batch_size=batch_size_test, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>download</code>：为<code>True</code>表示如果数据集不存在，则从网络下载</p>
</li>
<li><p><code>transform=...</code>定义了一系列的数据转换操作，并将它们组合成一个转换管道（transformation pipeline），以便对图像数据进行预处理和标准化：</p>
<ul>
<li><code>torchvision.transforms.ToTensor()</code>：图像数据转换为PyTorch张量（tensor），同时将像素值缩放到 [0, 1] 的范围内</li>
<li><code>torchvision.transforms.Normalize((0.1307,), (0.3081,))</code>：对图像数据进行标准化，即将每个通道的像素值减去均值（0.1307）并除以标准差（0.3081），以使得图像数据的分布接近标准正态分布</li>
</ul>
</li>
<li><p><code>shuffle</code>：为<code>True</code>表示打乱数据</p>
</li>
</ul>
<h5 id="观察测试数据"><a href="#观察测试数据" class="headerlink" title="观察测试数据"></a>观察测试数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">examples = <span class="built_in">enumerate</span>(test_loader)</span><br><span class="line">batch_idx, (example_data, example_targets) = <span class="built_in">next</span>(examples)</span><br><span class="line"><span class="built_in">print</span>(example_targets)</span><br><span class="line"><span class="built_in">print</span>(example_data.shape)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">// 图片实际对应的数字标签</span><br><span class="line">tensor([<span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>,</span><br><span class="line">         ......</span><br><span class="line">        <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>])</span><br><span class="line">// 一批测试数据是一个形状张量，是<span class="number">1000</span>个例子的28x28像素的灰度</span><br><span class="line">torch.Size([<span class="number">1000</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure></div>



<h4 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2_drop = nn.Dropout2d()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">320</span>, <span class="number">50</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(F.max_pool2d(self.conv1(x), <span class="number">2</span>))</span><br><span class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">320</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>self.conv1 = nn.Conv2d(1, 10, kernel_size=5)</code>表示第一个卷积层，输入通道为1（灰度图像），输出通道为10，卷积核大小为5x5</li>
<li><code>self.conv2_drop = nn.Dropout2d()</code>表示二维的dropout层，用于在训练过程中随机地将输入张量的部分元素设置为0，以减少过拟合</li>
<li><code>self.fc1 = nn.Linear(320, 50)</code>：全连接层1，输入大小为320，输出大小为50</li>
<li><code>forward(self, x)</code>：神经网络的前向传播函数，用于定义输入数据在网络中的流动和计算过程<ul>
<li><code>F.relu(F.max_pool2d(self.conv1(x), 2))</code>：将输入 <code>x</code> 传入第一个卷积层 <code>self.conv1</code> 中进行卷积操作，然后应用 ReLU 激活函数，并通过最大池化操作缩小特征图的尺寸</li>
<li><code>x = x.view(-1, 320)</code>: 将特征图展平为一维向量，以便输入到全连接层 <code>self.fc1</code>，-1 表示将剩余维度自动调整为使得展平后的大小为320</li>
<li><code>x = F.relu(self.fc1(x))</code>：将展平后的特征向量<code>x</code>传入全连接层<code>self.fc1</code>中，并应用<code>ReLU</code>激活函数，将卷积层提取的特征映射到一个较低维度的空间</li>
<li><code>x = F.dropout(x, training=self.training)</code>应用 dropout 操作，随机地将部分神经元的输出设置为0，以减少过拟合。<code>training=self.training</code>参数表示只在训练模式下应用 dropout，而在测试模式下不应用</li>
<li><code>x = self.fc2(x)</code>将经过 dropout 操作的特征向量 <code>x</code> 传入全连接层 <code>self.fc2</code> 中，得到最终的分类结果</li>
<li><code>return F.log_softmax(x, dim=1)</code>对全连接层 <code>self.fc2</code> 的输出进行 <code>log_softmax</code> 操作，以得到预测的类别概率分布</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化网络和优化器</span></span><br><span class="line">network = Net()</span><br><span class="line">optimizer = optim.SGD(network.parameters(), lr=learning_rate, momentum=momentum)</span><br></pre></td></tr></table></figure></div>



<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">train_losses = []</span><br><span class="line">train_counter = []</span><br><span class="line">test_losses = []</span><br><span class="line">test_counter = [i * <span class="built_in">len</span>(train_loader.dataset) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>train_losses</code>：记录训练过程中的损失值</li>
<li><code>train_counter</code>：用于记录训练过程中的批次数</li>
<li><code>test_losses</code>：用于记录测试过程中的损失值</li>
<li><code>test_counter</code>：在训练了 0、1、2、…、n_epochs 个 epoch 后进行测试的样本数</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    network.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = network(data)</span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % log_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'</span></span><br><span class="line">                  .<span class="built_in">format</span>(epoch, batch_idx * <span class="built_in">len</span>(data),<span class="built_in">len</span>(train_loader.dataset), </span><br><span class="line">                          <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader),loss.item()))</span><br><span class="line">            train_losses.append(loss.item())</span><br><span class="line">            train_counter.append((batch_idx * <span class="number">64</span>) + ((epoch - <span class="number">1</span>) * <span class="built_in">len</span>(train_loader.dataset)))</span><br><span class="line">            torch.save(network.state_dict(), <span class="string">'./model.pth'</span>)</span><br><span class="line">            torch.save(optimizer.state_dict(), <span class="string">'./optimizer.pth'</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>network.train()</code>: 将神经网络模型设置为训练模式</li>
<li><code>optimizer.zero_grad()</code>: 清零优化器的梯度缓存。每次迭代中，梯度都会累积，所以在每个批次开始时需要将梯度清零</li>
<li><code>loss = F.nll_loss(output, target)</code>：计算模型预测结果 <code>output</code> 与真实标签 <code>target</code> 之间的损失。在这里，采用的损失函数是负对数似然损失<code>(Negative Log Likelihood，NLL)</code>。这个损失函数通常用于多类别分类任务，并且在模型最后一层没有应用 softmax 激活函数的情况下使用</li>
<li><code>loss.backward()</code>：反向传播损失，计算参数的梯度。这一步将计算出损失函数对网络中所有参数的梯度</li>
<li><code>optimizer.step()</code>：根据计算出的梯度更新模型的参数。这一步是优化器的核心步骤，它会根据梯度更新模型参数，使得损失函数尽可能减小</li>
<li><code>train_losses.append(loss.item())</code>：将当前批次的损失值记录到 <code>train_losses</code> 列表中</li>
<li><code>(batch_idx * 64) + ((epoch - 1) * len(train_loader.dataset))</code>记录当前批次的索引，这个索引表示当前已经处理的样本数</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    network.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            output = network(data)</span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">'sum'</span>).item()</span><br><span class="line">            pred = output.data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.data.view_as(pred)).<span class="built_in">sum</span>()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    test_losses.append(test_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\nTest set: Avg. loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>network.eval()</code>：将神经网络模型设置为评估模式，这一步是为了确保在测试过程中不会应用训练过程中的一些特定于训练的操作，例如 dropout 和批量归一化。在评估模式下，模型的行为会略有不同，以便更准确地评估模型在测试数据上的性能</li>
<li><code>with torch.no_grad()</code>表示在该代码块中计算的梯度不会被保存，从而节省内存并加快计算速度</li>
<li><code>test_loss += F.nll_loss(output, target, reduction='sum').item()</code>：计算模型对当前批次测试数据的损失，并累积到 <code>test_loss</code> 中，这里采用的损失函数是负对数似然损失（Negative Log Likelihood，NLL）</li>
<li><code>pred = output.data.max(1, keepdim=True)[1]</code>：从模型的输出中获取预测类别</li>
<li><code>correct += pred.eq(target.data.view_as(pred)).sum()</code>：统计模型在当前批次上预测正确的样本数量</li>
<li><code>test_loss /= len(test_loader.dataset)</code>：计算平均测试损失</li>
</ul>
<p>训练结果如图</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/662a5eb90ea9cb1403f6898a.png"></p>
<h4 id="检查点的持续训练"><a href="#检查点的持续训练" class="headerlink" title="检查点的持续训练"></a>检查点的持续训练</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化一组新的网络和优化器</span></span><br><span class="line">continued_network = Net()</span><br><span class="line">continued_optimizer = optim.SGD(network.parameters(), lr=learning_rate, momentum=momentum)</span><br><span class="line"><span class="comment"># 加载网络的内部状态，并在最后一次保存它们时优化它们</span></span><br><span class="line">network_state_dict = torch.load(<span class="string">'model.pth'</span>)</span><br><span class="line">continued_network.load_state_dict(network_state_dict)</span><br><span class="line">optimizer_state_dict = torch.load(<span class="string">'optimizer.pth'</span>)</span><br><span class="line">continued_optimizer.load_state_dict(optimizer_state_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">9</span>):</span><br><span class="line">    test_counter.append(i * <span class="built_in">len</span>(train_loader.dataset))</span><br><span class="line">    train(i)</span><br><span class="line">    dtest()</span><br></pre></td></tr></table></figure></div>

<p>新增几轮训练之后的测试结果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/662a5eb90ea9cb1403f689e3.png"></p>
<h3 id="术语概念解释"><a href="#术语概念解释" class="headerlink" title="术语概念解释"></a>术语概念解释</h3><blockquote>
<p><strong>卷积</strong>（Convolution)：</p>
<p>​	从一个小小的权重矩阵，也就是卷积核（kernel）开始，让它逐步（从左至右，从上至下）在二维输入数据上“扫描”。卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积（注意这里是两个矩阵对应数据相乘再把所有结果相加，不是矩阵乘法！！！），然后把结果汇总成一个输出像素。</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic1.zhimg.com/v2-6428cf505ac1e9e1cf462e1ec8fe9a68_b.webp"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/v2-705305fee5a050575544c64067405fce_b.webp"></p>
<blockquote>
<p><strong>填充</strong>（Padding）：</p>
<p>​	前面可以发现，输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。</p>
<p>​	为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界<strong>填充（Padding）</strong>，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“0”来进行填充的（如图中矩形外围的虚线框）。</p>
<p>​	常用的两种padding：</p>
<p><strong>（1）valid padding</strong>：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界</p>
<p><strong>（2）same padding</strong>：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/v2-2a2307d5c20551f1a3e8458c7070cf16_b.webp" alt="gif"></p>
<blockquote>
<p><strong>步长</strong>(Stride)：</p>
<p>​	滑动卷积核时，我们会先从输入的左上角开始，每次往左滑动一列或者往下滑动一行逐一计算输出，我们将每次滑动的行数和列数称为Stride，在之前的图片中，Stride=1；在下图中，Stride=2。</p>
<p>​	步长Stride的作用：成倍缩小尺寸，而这个参数的值就是缩小的具体倍数，比如步幅为2，输出就是输入的1/2；步幅为3，输出就是输入的1/3。</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic1.zhimg.com/v2-294159b043a917ea622e1794b4857a34_b.webp" alt="动图"></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-magnifying-glass"></i><p>TIPS</p>

    </div>
    <div class="notel-content">
      <p>卷积核的大小一般为奇数*奇数 1*1，3*3，5*5，7*7都是最常见的。<strong>这是为什么呢？</strong>为什么没有偶数*偶数？</p>

    </div>
  </div>

<blockquote>
<p><strong>（1）更容易padding</strong></p>
<p>​	在卷积时，我们有时候需要卷积前后的尺寸不变。这时候我们就需要用到padding。假设图像的大小，也就是被卷积对象的大小为n*n，卷积核大小为k*k，padding的幅度设为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="3.873ex" height="2.791ex" role="img" focusable="false" viewBox="0 -888.7 1712.1 1233.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,398) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mn" transform="translate(679.3,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="1472.1" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>时，卷积后的输出就为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="20.378ex" height="3.523ex" role="img" focusable="false" viewBox="0 -1212.4 9006.9 1557.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,584) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(989,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1767,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2267,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mo" transform="translate(2767,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mfrac" transform="translate(3156,0)"><g data-mml-node="mrow" transform="translate(220,398) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mn" transform="translate(679.3,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="1472.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(4868.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5257.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(6035.1,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(6556.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(2498.7,-345) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><rect width="5110.9" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(5573.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6573.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7351.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(8406.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>，即卷积输出为n*n，保证了卷积前后尺寸不变。但是如果k是偶数的话，(k-1)/2就不是整数了。</p>
<p><strong>（2）更容易找到卷积锚点</strong></p>
<p>​	在CNN（卷积神经网络）中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。若卷积核为奇数，卷积锚点自然就是卷积核模块中心，但如果卷积核是偶数，这时候就没有办法确定了。</p>
</blockquote>

  <div class="note-large purple">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-star"></i><p>IMPORTANT</p>

    </div>
    <div class="notel-content">
      <p><strong>卷积的计算公式</strong></p>
<p><strong>输入图片的尺寸：</strong>一般用 n×n 表示输入的image大小。</p>
<p><strong>卷积核的大小：</strong>一般用 f×f 表示卷积核的大小。</p>
<p><strong>填充（Padding）：</strong>一般用 p 来表示填充大小。</p>
<p><strong>步长(Stride)：</strong>一般用 s 来表示步长大小。</p>
<p><strong>输出图片的尺寸：</strong>一般用 o 来表示。</p>
<p>如果已知 n 、f 、p、s 可以求得 o ，<strong>计算公式如下：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.469ex;" xmlns="http://www.w3.org/2000/svg" width="18.574ex" height="4.07ex" role="img" focusable="false" viewBox="0 -1149.5 8209.8 1799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mrow" transform="translate(1818.6,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="230A" d="M224 -649V1150H275V-598H511V-649H224Z"></path></g><g data-mml-node="mfrac" transform="translate(528,0)"><g data-mml-node="mrow" transform="translate(220,485) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(1878,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(2656,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(3159,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3937,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g></g><g data-mml-node="mi" transform="translate(1640.6,-345) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><rect width="3372.8" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(4140.8,0) translate(0 -0.5)"><path data-c="230B" d="M252 -598V1150H303V-649H16V-598H252Z"></path></g></g><g data-mml-node="mo" transform="translate(6709.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(7709.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></strong></p>
<p>其中”⌊ ⌋”是向下取整符号，用于结果不是整数时进行向下取整。</p>

    </div>
  </div>


<blockquote>
<p><strong>多通道卷积</strong></p>
<p>上述例子均为单通道图像。实际上，大多数输入图像都有 RGB 3个通道。</p>
<p>这里就要涉及到“卷积核”和“filter”这两个术语的区别。在单通道的情况下，“卷积核”就相当于“filter”，这两个概念是可以互换的。但在一般情况下，它们是两个完全不同的概念。<strong>每个“filter”实际上恰好是“卷积核”的一个集合</strong>，在当前层，每个通道都对应一个卷积核，且这个卷积核是独一无二的。</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic2.zhimg.com/80/v2-d40e48b85e19b2d16c86eee901870755_720w.webp" alt="img"></p>
<blockquote>
<p><strong>最大池化</strong>是一种常用的池化操作，用于在卷积神经网络中对特征图进行下采样。它的作用是通过保留特征图中每个区域的最大值来减小特征图的空间大小，从而减少计算量并提取最显著的特征。</p>
<p>池化层每次在一个池化窗口上计算输出，然后根据步幅移动池化窗口。下图是目前最常用的池化层，步幅为2，池化窗口为2×2的二维最大池化层。每隔2个元素从图像划分出2×2的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。</p>
</blockquote>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Computer Network Experiment</title>
    <url>/2024/05/16/10Summary%20of%20Computer%20Network%20Experiment/</url>
    <content><![CDATA[<h2 id="计算机网络实验总结"><a href="#计算机网络实验总结" class="headerlink" title="计算机网络实验总结"></a>计算机网络实验总结</h2><p>写在前面：</p>
<ol>
<li>网络实验室PC机的虚拟网卡可能会产生不良影响，建议开机后首先将所有虚拟网卡禁用。</li>
<li>网络实验室的路由器和交换机的出厂配置可能会产生不良影响，例如路由器出厂设置中默认配置了interface vlan 1（ip address 192.168.0.1 ），建议首先将这个IP地址undo，以免这个地址自动参与router id 选举，影响ospf或bgp协议的正常工作</li>
<li><img lazyload="" src="/images/loading.svg" data-src="https://i.postimg.cc/x1Z6f8wV/image.png"></li>
<li>多使用“？”命令获取帮助</li>
</ol>
<h3 id="实验一-网络实验入门"><a href="#实验一-网络实验入门" class="headerlink" title="实验一 网络实验入门"></a>实验一 网络实验入门</h3><h4 id="清空-重启"><a href="#清空-重启" class="headerlink" title="清空/重启"></a>清空/重启</h4><p>实验之前先清空配置，并重启路由器/交换机</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;H3C&gt;reset saved-configuration	#删除保存配置，选择yes</span><br><span class="line">&lt;H3C&gt;reboot					    #重启设备，第一个选择no，第二个选择yes</span><br></pre></td></tr></table></figure></div>

<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#上面的代码左侧&lt;H3C&gt;表示这是用户视图</span><br><span class="line">&lt;H3C&gt;sys							#可进入系统视图（完整命令是system-view)，左侧变为[H3C]</span><br><span class="line">[H3C]interface ethernet 1/0/1 		#进入以太网端口1/0/1，要根据设备的实际端口写命令，可以通过dis cu命令查看端口信息</span><br><span class="line">[H3C-interface e 1/0/1]quit			#退出当前视图</span><br></pre></td></tr></table></figure></div>

<h4 id="网络配置基本命令"><a href="#网络配置基本命令" class="headerlink" title="网络配置基本命令"></a>网络配置基本命令</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;H3C&gt;dis cu								#完整命令为display current-configuration，显示系统当前配置</span><br><span class="line">&lt;H3C&gt;display version					#显示系统软件的版本</span><br><span class="line">[H3C]display interface ethernet 1/0/1	#显示具体端口的信息和状态</span><br><span class="line">[H3C]display ?							#命令行帮助</span><br></pre></td></tr></table></figure></div>

<h4 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C]sysname R1								#重命名为R1</span><br><span class="line">[R1]interface ethernet 0/0 					#进入0/0以太网端口</span><br><span class="line">[R1-Ethernet 0/0]ip address 192.168.0.1 24	#配置端口的ip地址，子网掩码</span><br><span class="line">											#或者使用ip address 192.168.0.1 255.255.255.0，效果相同</span><br><span class="line">[R1-Ethernet 0/0]undo ip address			#取消ip地址</span><br><span class="line">[R1-Ethernet 0/0]shutdown					#关闭端口</span><br><span class="line">[R1-Ethernet 0/0]undo shutdown				#启动端口</span><br></pre></td></tr></table></figure></div>

<h4 id="交换机基本配置"><a href="#交换机基本配置" class="headerlink" title="交换机基本配置"></a>交换机基本配置</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C]interface ethernet 1/0/1					#进入指定以太网端口</span><br><span class="line">[H3C-Ethernet 1/0/1]shutdown					#关闭端口</span><br><span class="line">[H3C-Ethernet 1/0/1]undo shutdown				#启动端口</span><br><span class="line">[H3C-Ethernet 1/0/1]port link-type access		#设置端口为access端口</span><br><span class="line">[H3C-Ethernet 1/0/1]port link-type trunk		#设置端口为trunk端口</span><br><span class="line">[H3C-Ethernet 1/0/1]port link-type hybrid		#设置端口为hybrid端口</span><br><span class="line">[H3C-Ethernet 1/0/1]undo port link-type			#恢复端口的链路类型为默认的access</span><br></pre></td></tr></table></figure></div>

<h4 id="基于地址转换的组网实验"><a href="#基于地址转换的组网实验" class="headerlink" title="基于地址转换的组网实验"></a>基于地址转换的组网实验</h4><p>​	<code>Network Address Translation/NAT</code>，是地址转换技术，它可以将多个内部专用IP地址映射为少数几个甚至一个公网IP地址，用来减少公网IP地址的使用。</p>
<p>​	当请求报文转发到出口NAT路由器时，NAT路由器首先会查看公网地址池，然后在地址转换表中插入一条记录，分别是转换前的源地址、源端口号和转换后的源地址、源端口号。NAT路由器会按照转换后的地址和端口号重新封装报文，目的地址和端口不变。</p>
<p>​	当应答报文转发到出口NAT路由器时，同样将目的地址和端口转换成内网本地地址和端口，重新封装后转发。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645efcbd9c307b7e9bb889b.png"></p>
<p>​	注意这里0/1端口要配置ip地址。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置外出规则(access control list, acl)，编号2001</span><br><span class="line">[R1]acl basic 2001											#老版本命令是acl number 2001</span><br><span class="line">[R1]rule permit source 10.0.0.0 0.0.0.255 					#定义了允许ip源地址为10.0.0.0/24的外出数据包</span><br><span class="line">															#注意用网络地址和反掩码</span><br><span class="line">[R1]rule deny source any</span><br><span class="line"></span><br><span class="line">#配置地址池，编号1</span><br><span class="line">[R1]nat address-group 1</span><br><span class="line">[R1 address-group-1]address 192.168.5.105 192.168.5.109  	#定义了一个包含5个公网地址（5-9）的地址池，地址池名称为1</span><br><span class="line"></span><br><span class="line">#在端口中应用规则和地址池</span><br><span class="line">[R1]interface e 0/1											#进入出口端口</span><br><span class="line">[R1-Ethernet 0/1]nat outbound 2001 address-group 1			#在出口e 0/1启动地址转换</span><br><span class="line"></span><br><span class="line">#记得添加静态路由，下一跳地址填地址池中地址的网关例如192.168.5.105就填192.168.5.1</span><br><span class="line">[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.5.1 			#在路由表添加静态路由</span><br></pre></td></tr></table></figure></div>

<h3 id="实验二-数据链路层实验"><a href="#实验二-数据链路层实验" class="headerlink" title="实验二 数据链路层实验"></a>实验二 数据链路层实验</h3><h4 id="基本配置命令"><a href="#基本配置命令" class="headerlink" title="基本配置命令"></a>基本配置命令</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645a4a5d9c307b7e940dad9.png"></p>
<h4 id="端口聚合"><a href="#端口聚合" class="headerlink" title="端口聚合"></a>端口聚合</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C]display mac-address								#查看交换机的mac地址表</span><br><span class="line">[H3C]sysname s1</span><br><span class="line">[s1]stp disable											#撤销生成树协议的配置</span><br><span class="line">[s1]interface bridge-aggregation 1						#定义聚合组</span><br><span class="line">[s1-bridge-aggregation 1]link-aggregation mode dynamic</span><br><span class="line">[s1]interface Ethernet 1/0/1</span><br><span class="line">[s1-Ethernet 1/0/1]port link-aggregation group 1		#将物理端口加入聚合组中</span><br><span class="line">[s1]interface Ethernet 1/0/2</span><br><span class="line">[s1-Ethernet 1/0/2]port link-aggregation group 1</span><br></pre></td></tr></table></figure></div>

<h4 id="创建-删除VLAN，向VLAN中添加端口"><a href="#创建-删除VLAN，向VLAN中添加端口" class="headerlink" title="创建/删除VLAN，向VLAN中添加端口"></a>创建/删除VLAN，向VLAN中添加端口</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C]vlan 2 		#创建vlan 2，2可以替换为其他vlan id，执行后会变为[h3c-vlan2]</span><br><span class="line">[H3C]undo vlan 2 	#删除vlan 2，2可以替换为其他vlan id</span><br><span class="line">[h3c-vlan2]port e 1/0/1 to e 1/0/3 </span><br><span class="line">#进入vlan后，使用port ... to ...将某一范围内的端口添加到该VLAN，使用的是基于端口的VLAN划分。</span><br><span class="line">#需要注意的是，e是Ethernet的缩写，线下网络实验室应当使用g</span><br><span class="line">[h3c-vlan2]undo port e 1/0/1 to e 1/0/2 // 将e 1/0/1 to e 1/0/3从VLAN2中删除</span><br></pre></td></tr></table></figure></div>

<h4 id="指定端口类型"><a href="#指定端口类型" class="headerlink" title="指定端口类型"></a>指定端口类型</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C-Ethernet 1/0/1]port link-type access		#设置端口为access端口</span><br><span class="line">[H3C-Ethernet 1/0/1]port link-type trunk		#设置端口为trunk端口</span><br><span class="line">[H3C-Ethernet 1/0/1]port link-type hybrid		#设置端口为hybrid端口</span><br><span class="line">[H3C-Ethernet 1/0/1]undo port link-type  		#取消端口类型设置</span><br></pre></td></tr></table></figure></div>

<p>​	根据端口对VLAN数据帧的处理方式,可以将交换机的端口分为Access、Trunk和Hybrid类（默认情况为Access类）：</p>
<ul>
<li>Access端口一般是指那些连接<strong>不支持VLAN技术</strong>的终端设备的端口，这些端口接收到的数据帧都<strong>不包含VLAN标签</strong>，而向外发送数据帧时，必须保证数据帧中<strong>也不包含VLAN标签</strong>。一般接主机或路由器。</li>
<li>Trunk端口一般是指那些连接<strong>支持VLAN技术</strong>的网络设备(如交换机)的端口，这些端口接收到的数据帧一般<strong>都包含 VLAN标签</strong>（数据帧VLAN ID和端口默认VLAN ID相同除外），而向外发送数据帧时，必须保证接收端能够区分不同VLAN的数据帧，故常常需要<strong>添加VLAN标签</strong>（数据帧VLAN ID和端口默认VLAN ID相同除外）。一般用于交换机之间的连接。</li>
<li>Hybrid 端口属于 Access和Trunk的<strong>混合模式</strong>，工作在 Hybrid 模式下的端口<strong>可以属于多个VLAN</strong>，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于连接用户的计算机。</li>
</ul>
<p>​	Hybrid端口和Trunk端口的不同之处在于Hybrid端口允许多个VLAN的报文不带标签，而Trunk端口只允许默认VLAN的报文不带标签。</p>
<h4 id="指定VLAN端口可通过的数据帧"><a href="#指定VLAN端口可通过的数据帧" class="headerlink" title="指定VLAN端口可通过的数据帧"></a>指定VLAN端口可通过的数据帧</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C-Ethernet 1/0/1]port trunk permit vlan 2 to 3         #允许通过2和3的数据帧，ensp中将perimit换为allow-pass</span><br><span class="line">[H3C-Ethernet 1/0/1]undo port trunk permit vlan 2 to 3	  </span><br><span class="line">[H3C]display vlan 3										  #查看交换机上vlan3的配置</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66447db10ea9cb1403cf7d5e.png"></p>
<p>​	将E1/0/13端口设置为trunk，并允许vlan 2 3的数据帧通过。这样的操作使得不同交换机中相同vlan的主机可以相互联通，原因是trunk端口中非默认端口允许携带tag，并设置了E1/0/13时允许vlan2和vlan3的数据通过。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645a3dad9c307b7e93f8c31.png"></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[H3C-Ethernet 1/0/13]undo port link-type</span><br><span class="line">[H3C-Ethernet 1/0/13]port link-type hybrid</span><br><span class="line">[H3C-Ethernet 1/0/13]port hybrid pvid vlan 1</span><br><span class="line">[H3C-Ethernet 1/0/13]port hybrid vlan 2 tagged</span><br><span class="line">[H3C-Ethernet 1/0/13]port hybrid vlan 3 untagged</span><br></pre></td></tr></table></figure></div>

<p>​	此时PCA能ping通PCC，但是PCB不能ping通PCD，原因是s1和s2中1/0/13端口均设置了vlan2为tagged，vlan3为untagged。因此来自vlan2的报文进入s2时会携带自己的vlan tag，因此能顺利转发给有相同vlan id的端口，而vlan 3则不行。</p>
<h4 id="广域网数据链路层协议"><a href="#广域网数据链路层协议" class="headerlink" title="广域网数据链路层协议"></a>广域网数据链路层协议</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645c4ced9c307b7e97d9ff7.png"></p>
<h5 id="配置PPP协议"><a href="#配置PPP协议" class="headerlink" title="配置PPP协议"></a>配置PPP协议</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]interface Serial 1/0</span><br><span class="line">[R1-Serial1/0]link-protocol ppp		#配置PPP</span><br><span class="line">#配置完成之后需要重新启动接口使其生效</span><br><span class="line">[R1-Serial1/0]shutdown</span><br><span class="line">[R1-Serial1/0]undo shutdown</span><br><span class="line">[R1-Serial2/0]shutdown				#关闭另一个端口防止其他信息干扰</span><br><span class="line">#R2配置与上述命令类似</span><br><span class="line">&lt;R1&gt;debugging ppp all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure></div>

<p>根据调试信息画流程图如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645bde4d9c307b7e970a339.png"></p>
<h5 id="配置PAP"><a href="#配置PAP" class="headerlink" title="配置PAP"></a>配置PAP</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#路由器[R1]的配置</span><br><span class="line">[R1]local-user RTB class network							#配置用户对应列表</span><br><span class="line">[R1-luser-network-RTB]service-type ppp						#配置服务类型</span><br><span class="line">[R1-luser-network-RTB]password simple aaa					#配置用户对应密码</span><br><span class="line">[R1]inter Serial 1/0</span><br><span class="line">[R1-Serial1/0]ppp authentication pap						#授权PAP验证</span><br><span class="line"></span><br><span class="line">#路由器[R2]的配置</span><br><span class="line">[R2]interface serial 0/0                                             </span><br><span class="line">[R2-serial0/0]ppp pap local-user RTB password simple aaa	#配置pap用户名和密码</span><br></pre></td></tr></table></figure></div>

<p>根据调试信息画出流程图：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645c45cd9c307b7e97cd232.png"></p>
<p>解释PAP：</p>
<p>​	PAP（Password AuthenticationProtocol，密码认证协议）是一种很简单的认证协议，分两步进行，验证过程从客户端发起，密码<strong>明文</strong>传输。PAP协议仅在连接建立阶段进行，在数据传输阶段不进行PAP 认证。</p>
<ol>
<li>A与B之间通过PPP互联，,A设置为验证方，B为被验证方，当B拨通A后，B会将用户名(一般设置为路由器的名字)与口令一起发给A</li>
<li>验证方A根据本端的用户数据库（或Radius服务器）查看是否有此用户，口令是否正确。如正确则会给对端发送ACK报文，通告对端已被允许进入下一阶段协商;否则发送NAK报文，通告对端验证失败</li>
</ol>
<p>​	通常，验证失败并不会直接将链路关闭。只有当验证失败的次数达到一定值时,才会关闭链路，以防止因误传、网络干扰等造成不必要的LCP重新协商过程。<br>​	PAP的特点是在网络上以明文的方式传递用户名及口令，如在传输过程中被截获，便有可能对网络安全造成极大的威胁。因此，它适用于对网络安全要求相对较低的环境。</p>
<h3 id="实验三-网络层实验"><a href="#实验三-网络层实验" class="headerlink" title="实验三 网络层实验"></a>实验三 网络层实验</h3><h4 id="ARP分析"><a href="#ARP分析" class="headerlink" title="ARP分析"></a>ARP分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645ce4ed9c307b7e98f1fcb.png"></p>
<p>​	ARP协议，即地址解析协议，用于将IP地址解析成硬件地址。在每台使用ARP的主机中,都保留了一个专用的内存区(称为缓存)，存放最近的IP地址与硬件地址的对应关系。一旦收到ARP应答，主机将获得的地址和硬件地址的对应关系存到缓存中。当发送报文时,首先去缓存中查找相应的项,如果找到相应项，便将报文直接发送出去;如果找不到，再利用ARP进行解析。ARP缓存信息在一定时间内有效，过期不更新就会被删除。</p>
<p>​	同一网段的主机进行通信时，如果ARP缓存中找不到硬件地址，则源主机直接发送ARP请求报文，目的主机对此请求做应答即可。</p>
<p>​	不同网段的主机进行通信时，源主机会将arp报文发送给它的默认网关（这也是两个组网实验得到的arp报文中target IP address的区别），默认网关再根据报文的目的IP地址进行转发。</p>
<h5 id="配置VLAN的IP地址"><a href="#配置VLAN的IP地址" class="headerlink" title="配置VLAN的IP地址"></a>配置VLAN的IP地址</h5><p>不是给某个端口配！是给这个vlan配置ip地址！请注意区别，要使用<code>inter vlan id</code>的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s1]vlan 2</span><br><span class="line">[s1-vlan2]port e 1/0/1</span><br><span class="line">[s1-vlan2]inter vlan 2</span><br><span class="line">[s1-vlan interface2]ip address 192.168.1.10 255.255.255.0</span><br><span class="line">#S2交换机的配置类似</span><br></pre></td></tr></table></figure></div>

<h4 id="ICMP分析"><a href="#ICMP分析" class="headerlink" title="ICMP分析"></a>ICMP分析</h4><p>ICMP报文可以分为ICMP差错报文和ICMP询问报文两种。具体类型和对应的值如下表。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6645d4aad9c307b7e99679b9.png"></p>
<h4 id="IP分析"><a href="#IP分析" class="headerlink" title="IP分析"></a>IP分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6646014fd9c307b7e9ce8839.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66460180d9c307b7e9ced643.png"></p>
<h4 id="VLAN间通信"><a href="#VLAN间通信" class="headerlink" title="VLAN间通信"></a>VLAN间通信</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66460229d9c307b7e9cfb598.png"></p>
<p>好好弄清楚vlan之间怎么通信的，注意端口性质。</p>
<h3 id="OSPF实验"><a href="#OSPF实验" class="headerlink" title="OSPF实验"></a>OSPF实验</h3><p>​	OSPF是开放路径最短优先（open shortest path first）的缩写，核心思想是每一台路由器将其周边的链路状态（接口的直连网段，相连的路由器等信息）描述出来，发送给相邻的路由器。经过一段时间的链路状态信息交互，每台路由器都保存了一个链路状态数据库，该数据库是针对整个网络完整的链路状态描述。</p>
<p>​	OSPF协议是一种内部网关协议，其应用范围为一个自治系统内部。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6646c61bd9c307b7e9adb229.png"></p>
<h4 id="OSPF基本配置"><a href="#OSPF基本配置" class="headerlink" title="OSPF基本配置"></a>OSPF基本配置</h4><h5 id="OSPF相关命令"><a href="#OSPF相关命令" class="headerlink" title="OSPF相关命令"></a>OSPF相关命令</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset ospf all process（用户视图） 	#重新启动OSPF进程</span><br><span class="line">display ospf peer				  	#显示OSPF邻居信息</span><br><span class="line">display ospf brief					#显示OSPF概要信息</span><br><span class="line">display ospf routing				#显示OSPF路由表的信息</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6646c768d9c307b7e9aede38.png"></p>
<h5 id="配置Router-ID"><a href="#配置Router-ID" class="headerlink" title="配置Router ID"></a>配置Router ID</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R1&gt;system-view</span><br><span class="line">[R1]router id 1.1.1.1			#配置路由器的ID</span><br><span class="line">[R1]undo router id				#取消路由器的ID号</span><br></pre></td></tr></table></figure></div>

<h5 id="配置回环地址"><a href="#配置回环地址" class="headerlink" title="配置回环地址"></a>配置回环地址</h5><p>​	Loopback是一种纯软件性质的虚拟接口，Loopback接口一旦被创建，将一直保持Up状态，直到被删除。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]interface loopback 1</span><br><span class="line">[R1-LoopBack1]ip address 1.1.1.1 32</span><br></pre></td></tr></table></figure></div>

<h5 id="启动OSPF"><a href="#启动OSPF" class="headerlink" title="启动OSPF"></a>启动OSPF</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]ospf											#启动OSPF路由进程</span><br><span class="line">[R1-ospf-1]area 0									#创建区域0，undo area area-id可删除</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 1.1.1.0 0.0.0.255	#在接口Loop1上启动ospf并指定所属区域</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 168.1.1.0 0.0.0.255	#在E0上启动OSPF并指定所属区域</span><br><span class="line">#R2命令类似，注意使用网络地址和反掩码</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6646d146d9c307b7e9ba4f53.png"></p>
<h5 id="显示调试信息"><a href="#显示调试信息" class="headerlink" title="显示调试信息"></a>显示调试信息</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R1&gt;debugging ospf event</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure></div>
<h5 id="引入静态路由"><a href="#引入静态路由" class="headerlink" title="引入静态路由"></a>引入静态路由</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]ip route-static 4.4.4.0 255.255.255.0 192.168.1.1 </span><br><span class="line">#在R1上配置指向S1Loopback接口网段的静态路由，字段分别为 目的网络地址 子网掩码 下一跳</span><br><span class="line">[R1-ospf]import-route static						#将此静态路由引入到OSPF中</span><br><span class="line">[S1]ip route-static 0.0.0.0 0.0.0.0 192.168.1.2		#配置返回路由</span><br></pre></td></tr></table></figure></div>

<h5 id="配置cost"><a href="#配置cost" class="headerlink" title="配置cost"></a>配置cost</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vlan端口：</span><br><span class="line">[S1]inter vlan 3</span><br><span class="line">[S1-Vlan-interface3]ospf cost 100</span><br><span class="line">[S1-Vlan-interface3]inter vlan 2</span><br><span class="line">[S1-Vlan-interface2]ospf cost 500</span><br><span class="line">#普通端口：</span><br><span class="line">[R1]inter e0/0</span><br><span class="line">[R1-Ethernet0/0]ospf cost 100</span><br><span class="line">[R1-Ethernet0/0]inter s 0/0</span><br><span class="line">[R1-Serial0/0]ospf cost 500</span><br></pre></td></tr></table></figure></div>

<h4 id="DR和BDR的选举过程"><a href="#DR和BDR的选举过程" class="headerlink" title="DR和BDR的选举过程"></a>DR和BDR的选举过程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6647080ad9c307b7e9f7f93b.png"></p>
<p>​	DR和BDR一旦选举完成，除非他们发生故障，否则不会更换，即使后来的路由器priority更高。这样可以避免DR的频繁更迭，以及由此带来的路由器之间邻接关系重新建立和链路状态信息重新同步等问题。有利于网络的稳定和减少对网络带宽的占用。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/664708ccd9c307b7e9f8b38d.png"></p>
<h4 id="区域划分以及LSA的种类"><a href="#区域划分以及LSA的种类" class="headerlink" title="区域划分以及LSA的种类"></a>区域划分以及LSA的种类</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66470f1cd9c307b7e9018a38.png"></p>
<p>​	区域内部仍然使用第一类和第二类LSA描述区域内部的网络，并仅限于内部传播。但是区域边界路由器ABR收到这些信息之后，会据此对该区域内的路由生成一种新的第三类LSA，并将其传播到相邻的区域。第三类LSA主要对区域内的路由信息进行描述，比如网段、子网掩码、度量值等。和第一类第二类相比大大减少了路由信息描述的数据量。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66471412d9c307b7e907b0e6.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66471629d9c307b7e90a382a.png"></p>
<p>​	注意ABR要配置两个区域，其他命令无变化。</p>
<p>​	此处全网互通需要对R1和S1配置静态路由，命令在上面。</p>
<h4 id="路由器的类型"><a href="#路由器的类型" class="headerlink" title="路由器的类型"></a>路由器的类型</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66471186d9c307b7e904cc54.png"></p>
<h4 id="第一类LSA（Router-LSA）的分析"><a href="#第一类LSA（Router-LSA）的分析" class="headerlink" title="第一类LSA（Router LSA）的分析"></a>第一类LSA（Router LSA）的分析</h4><p>显示第一类LSA信息的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]display ospf lsdb router</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/664704bad9c307b7e9f49945.png"></p>
<p>type字段：transnet表示为广播或NBMA类型</p>
<h4 id="第二类LSA（Network-LSA）的分析"><a href="#第二类LSA（Network-LSA）的分析" class="headerlink" title="第二类LSA（Network LSA）的分析"></a>第二类LSA（Network LSA）的分析</h4><p>显示第二类LSA信息的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]display ospf lsdb network</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66470514d9c307b7e9f4f21e.png"></p>
<h4 id="第三类LSA（Summary-Network-LSA）的分析"><a href="#第三类LSA（Summary-Network-LSA）的分析" class="headerlink" title="第三类LSA（Summary Network LSA）的分析"></a>第三类LSA（Summary Network LSA）的分析</h4><p>显示第三类LSA信息的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]display ospf lsdb summary</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66471dbcd9c307b7e913d7d8.png"></p>
<h4 id="第四类（ASBR-Summary-LSA）和第五类（AS-External-LSA）分析"><a href="#第四类（ASBR-Summary-LSA）和第五类（AS-External-LSA）分析" class="headerlink" title="第四类（ASBR-Summary-LSA）和第五类（AS-External-LSA）分析"></a>第四类（ASBR-Summary-LSA）和第五类（AS-External-LSA）分析</h4><p>显示第四类LSA信息的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]display ospf lsdb asbr</span><br></pre></td></tr></table></figure></div>

<p>显示第五类LSA信息的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]display ospf lsdb ase</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/664722f3d9c307b7e919ac91.png"></p>
<h4 id="OSPF协议路由的计算过程"><a href="#OSPF协议路由的计算过程" class="headerlink" title="OSPF协议路由的计算过程"></a>OSPF协议路由的计算过程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66472a14d9c307b7e921b738.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66472a32d9c307b7e921daed.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66481dbfd9c307b7e9321572.png"></p>
<p>​	注意TranseNet，StubNet，P-2-P的区别</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/6648208cd9c307b7e934fa34.png"></p>
<p>​	请注意下一跳的内容是具体地址，路径填写路由器号。如填表，最左侧一栏要覆盖所有路由器交换机（本机除外）以及TransNet和StubNet，写清楚具体网络地址。</p>
<p>​	用traceroute命令可以验证最短路径树。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]tarcert 10.1.1.2</span><br></pre></td></tr></table></figure></div>

<h4 id="设计性实验1"><a href="#设计性实验1" class="headerlink" title="设计性实验1"></a>设计性实验1</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/664855b8d9c307b7e976bb0a.png"></p>
<p>如何使全网互通？这里有三种方式：</p>
<ol>
<li><p>将PC所在网段引入OSPF路由：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s1]ospf</span><br><span class="line">[s1-ospf-1]area 1</span><br><span class="line">[s1-ospf-1-area-0.0.0.1]import-route direct</span><br><span class="line">[s2]ospf</span><br><span class="line">[s2-ospf-1]area 2</span><br><span class="line">[s2-ospf-1-area-0.0.0.2]import-route direct</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在ASBR所在区域的ABR上配置到ASE的静态路由并引入OSPF:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[r1]ip route-static 192.168.5.0 255.255.255.2 192.168.3.2</span><br><span class="line">[r1]ospf</span><br><span class="line">[r1-ospf-1]import-route static</span><br><span class="line">[r2]ip route-static 192.168.6.0 255.255.255.2 192.168.4.2</span><br><span class="line">[r2]ospf</span><br><span class="line">[r2]import-route static</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在每台交换机/路由器上配置到PC1/PC2的静态路由，命令类似。</p>
</li>
</ol>
<h4 id="设计性实验2"><a href="#设计性实验2" class="headerlink" title="设计性实验2"></a>设计性实验2</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/66485a79d9c307b7e97c1907.png"></p>
<p>使全网互通的方式：</p>
<p>要同时提供给ospf从R1或R2到211.100.2.0网段的路由</p>
<ul>
<li><p>首先将R1注入一条202.112.2.2的静态路由，并通过静态路由和直连引入ospf</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1]ip route-static 211.100.2.0 255.255.255.0 202.112.1.2</span><br><span class="line">[R1]ospf</span><br><span class="line">[R1-ospf-1]import-route static</span><br><span class="line">[R1-ospf-1]import-route direct</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>R2也需要引入一条到211.100.2.1的静态路由：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R2]ip route-static 211.100.2.0 255.255.255.0 202.112.2.2</span><br><span class="line">[R2]ospf</span><br><span class="line">[R2-ospf-1]import-route static</span><br><span class="line">[R2-ospf-1]import-route direct</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对于回环地址，设置返回地址：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[S2]ip route-static 0.0.0.0 0.0.0.0 202.112.1.2 pre 50</span><br><span class="line">[S2]ip route-static 0.0.0.0 0.0.0.0 202.112.2.2 pre 60</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将两台PC通过直连引入ospf：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[S1]import-route direct</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>ospf动态计算路由，选择cost最小的path，网络全连接时选择S1-R1-S2-loop1；R1-S1断开时，选择S1-R2-S2-loop1；R2-S2断开时，选择S1-R2-R1-S2-loop1</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
</search>
