<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Python notes</title>
    <url>/2023/06/26/Python-notes/</url>
    <content><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h5 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'async'</span>, <span class="string">'await'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h5><p>使用反斜杠<code>\</code>来实现多行语句</p>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ul>
<li>单行注释以 <strong>#</strong> 开头</li>
<li>多行注释可以用多个 <strong>#</strong> 号，也可用三个单引号 <strong>'‘’</strong> 或者三个双引号 <strong>"“”</strong> 将注释括起来</li>
</ul>
<h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><p>使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> ，缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数</p>
<h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>python中数字有四种类型：整数(int, 1…)、布尔型(bool, True…)、浮点数(float, 1.23…)和复数(complex, 1+2j…)</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用<strong>完全相同</strong></li>
<li>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串</li>
<li>转义符 <code>\</code></li>
<li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行</li>
<li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong></li>
<li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复</li>
<li>字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始</li>
<li>Python 中的字符串不能改变</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串</li>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong>(步长表示间隔)</li>
</ul>
<h5 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h5><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"a"</span></span><br><span class="line">y=<span class="string">"b"</span></span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">" "</span>)</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line">a b </span><br></pre></td></tr></table></figure></div>

<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>变量无需声明，但每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建</li>
<li>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型</li>
</ul>
<p>同时为多个变量赋值：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>为多个对象指定多个变量：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"runoob"</span></span><br></pre></td></tr></table></figure></div>

<h5 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h5><p>Python3 的六个标准数据类型中：</p>
<ul>
<li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）</li>
<li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）</li>
</ul>
<h5 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h5><p>int、float、bool、complex（复数）</p>
<p>内置的 <code>type()</code> 函数和 <code>isinstance</code>可以询变量所指的对象类型</p>
<blockquote>
<p><strong>注意：</strong>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， <strong>True==1、False==0</strong> <em>会返回</em> <strong>True</strong>，但可以通过<strong>is</strong>来判断类型。</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>==<span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<h6 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数, 往小的方向取整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在混合计算时，Python会把整型转换成为浮点数</li>
<li>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 **<code>a + bj</code>**，或者 <strong><code>complex(a,b)</code></strong> 表示， 复数的实部 <code>a</code> 和虚部 <strong><code>b</code></strong> 都是浮点型</li>
<li><code>//</code> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系</li>
</ul>
<h6 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h6><p>只需要将数据类型作为函数名即可</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数</li>
<li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y，x 和 y 是数字表达式</li>
</ul>
<h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left">cmp(x, y)</td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-log.html">log(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定参数的最大值，参数可以为序列</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定参数的最小值，参数可以为序列</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">x**y 运算后的值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-round.html">round(x,[,n]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。**其实准确的说是保留值将保留到离上一位更近的一端</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回数字x的平方根</td>
</tr>
</tbody></table>
<h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数</td>
</tr>
<tr>
<td align="left">[randrange (<a class="link" href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-random.html">random() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">随机生成下一个实数，它在[0,1)范围内</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-seed.html">seed([x]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">随机生成下一个实数，它在[x,y]范围内</td>
</tr>
</tbody></table>
<h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反余弦弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反正弦弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的反正切弧度值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回给定的 X 及 Y 坐标值的反正切值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x的弧度的余弦值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回欧几里德范数 sqrt(x*x + y*y)</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回的x弧度的正弦值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">返回x弧度的正切值</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td align="left"><a class="link" href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将角度转换为弧度</td>
</tr>
</tbody></table>
<h6 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h6><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）</td>
</tr>
</tbody></table>
<h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><ul>
<li>字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 <code>\</code>转义特殊字符</li>
<li>使用反斜杠 <code>\</code> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r'Ru\noob'</span>)</span><br><span class="line">Ru\noob</span><br></pre></td></tr></table></figure></div></li>
<li>自带空格连接<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></div></li>
<li>Python 字符串不能被改变。向一个索引位置赋值，比如 <strong><code>word[0] = 'm'</code></strong> 会导致错误\</li>
<li>用+运算符连接在一起，用*运算符重复</li>
<li>两种索引方式，从左往右以0开始，从右往左以-1开始</li>
<li>字符串的截取的语法格式如下：<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br><span class="line"><span class="comment">#不会打印尾下标字符，也就是说会打印到尾下标之前的那一个字符</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h6 id="字符串更新"><a href="#字符串更新" class="headerlink" title="字符串更新"></a>字符串更新</h6><p>通过截取字符串的一部分并与其他字段拼接：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">var1 = <span class="string">'Hello World!'</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"已更新字符串 : "</span>, var1[:<span class="number">6</span>] + <span class="string">'Runoob!'</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h6><table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>\</strong>(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td><strong><span>\</span></strong></td>
<td>反斜杠</td>
</tr>
<tr>
<td><strong>\‘</strong></td>
<td>单引号</td>
</tr>
<tr>
<td><strong>\“</strong></td>
<td>双引号</td>
</tr>
<tr>
<td><strong>\a</strong></td>
<td>响铃</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>退格</td>
</tr>
<tr>
<td><strong>\000</strong></td>
<td>空</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td>换行</td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td>纵向制表符</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td>横向制表符</td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td>回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成</td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td>换页</td>
</tr>
<tr>
<td><strong>\yyy</strong></td>
<td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行</td>
</tr>
<tr>
<td><strong>\xyy</strong></td>
<td>十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td>
</tr>
</tbody></table>
<h6 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h6><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串连接</td>
<td align="left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">重复输出字符串</td>
<td align="left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通过索引获取字符串中字符</td>
<td align="left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td align="left">[ : ]</td>
<td align="left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td>
<td align="left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td align="left"><strong>‘H’ in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td align="left"><strong>‘M’ not in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">r/R</td>
<td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法</td>
<td align="left"><code>print( r'\n' ) print( R'\n' )</code></td>
</tr>
</tbody></table>
<h6 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">"我叫 %s 今年 %d 岁!"</span> % (<span class="string">'Leo'</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符串格式化符号与C语言类似</li>
<li><a class="link" href="https://www.runoob.com/python/att-string-format.html">str.format() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>增强了字符串格式化的功能</li>
</ul>
<h6 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h6><p>三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符</p>
<h5 id="bool（布尔类型）"><a href="#bool（布尔类型）" class="headerlink" title="bool（布尔类型）"></a>bool（布尔类型）</h5><ul>
<li>布尔类型即 True 或 False</li>
<li>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0</li>
<li>可以和逻辑运算符一起使用，包括 and、or 和 not，这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &lt; <span class="number">3</span>)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> == <span class="number">3</span>)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a)    <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(a))   <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(b)) <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(a))   <span class="comment"># "True"</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意:</strong> 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 <strong>0、空字符串、空列表、空元组</strong>等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。</p>
</blockquote>
<h5 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h5><ul>
<li>表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（类似于Java中的泛型）</li>
<li>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表</li>
<li>和字符串一样，列表同样可以被索引和截取，截取后返回一个包含所需元素的新列表</li>
<li>与Python字符串不一样的是，列表中的元素是可以改变的：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = []   <span class="comment"># 将对应的元素值设置为 []</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></div></li>
<li>Python 列表截取可以接收第三个参数，参数作用是截取的步长，如果第三个参数为负数表示逆向读取</li>
</ul>
<p>逆转句子的实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">" "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">' '</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">'I like runoob'</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure></div>

<h6 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h6><p>直接进行修改或更新:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"第三个元素为 : "</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"更新后的第三个元素为 : "</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></div>

<p>使用 append() 方法:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line">list1.append(<span class="string">'Baidu'</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"更新后的列表 : "</span>, list1)</span><br></pre></td></tr></table></figure></div>

<h6 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h6><p>使用 del 语句来删除列表的的元素，如下实例:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></div>

<h6 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure></div>

<h6 id="与列表有关的函数和方法"><a href="#与列表有关的函数和方法" class="headerlink" title="与列表有关的函数和方法"></a>与列表有关的函数和方法</h6><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">len(list)	max(list) 	min(list)	list(<span class="built_in">seq</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">list.append(obj)	list.count(obj)		list.extend(<span class="built_in">seq</span>)	list.index(obj)		</span><br><span class="line">list.insert(index, obj)		list.pop([index=-1])	list.remove(obj)	list.reverse()		</span><br><span class="line">list.sort( key=None, reverse=False)		list.clear()		list.copy()</span><br></pre></td></tr></table></figure></div>

<h5 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h5><ul>
<li>与列表类似，不同之处在于元组的元素<strong>不能修改</strong>(可以把字符串看作一种特殊的元组)</li>
<li>元组写在小括号 <strong>()</strong> 里，元素之间用<strong>逗号</strong>隔开</li>
<li>元组中的元素类型也可以不相同</li>
<li>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表\</li>
</ul>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号，否则括号会被当作运算符使用</span></span><br></pre></td></tr></table></figure></div>

<h6 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h6><p>使用下标索引：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<h6 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h6><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="comment"># 不允许出现类似tup1[0] = 100的用法</span></span><br></pre></td></tr></table></figure></div>

<h6 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h6><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">del</span> tup</span><br></pre></td></tr></table></figure></div>

<h6 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">len(tuple)	+	+=	*	in</span><br></pre></td></tr></table></figure></div>

<h6 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h6><p>同列表</p>
<h6 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h6><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>len(tuple)</code> 计算元组元素个数</td>
<td align="left"><code>&gt;&gt;&gt; tuple1 = ('Google', 'Runoob', 'Taobao') &gt;&gt;&gt; len(tuple1) 3 </code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>max(tuple)</code> 返回元组中元素最大值</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; max(tuple2) '8'  </code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>min(tuple)</code> 返回元组中元素最小值</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; min(tuple2) '4' &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>tuple(iterable)</code> 将可迭代系列转换为元组</td>
<td align="left"><code>&gt;&gt;&gt; list1= ['Google', 'Taobao', 'Runoob', 'Baidu'] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 ('Google', 'Taobao', 'Runoob', 'Baidu')</code></td>
</tr>
</tbody></table>
<h5 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h5><ul>
<li>一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员</li>
<li>基本功能是进行成员关系测试和删除重复元素</li>
<li>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sites = {<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Zhihu'</span>, <span class="string">'Baidu'</span>}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'Runoob'</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Runoob 在集合中'</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Runoob 不在集合中'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'alacazam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure></div>

<h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.add( x )		<span class="comment">#将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作</span></span><br><span class="line">s.update( x )	<span class="comment">#也可以添加元素，且参数可以是列表，元组，字典等</span></span><br></pre></td></tr></table></figure></div>

<h6 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.remove( x )		<span class="comment">#将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误</span></span><br><span class="line">s.discard( x )		<span class="comment">#移除集合中的元素，如果元素不存在，不会发生错误</span></span><br><span class="line">s.pop() 			<span class="comment">#随机删除集合中的一个元素</span></span><br></pre></td></tr></table></figure></div>

<h6 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure></div>

<h6 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure></div>

<h6 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></div>

<h6 id="集合内置方法"><a href="#集合内置方法" class="headerlink" title="集合内置方法"></a>集合内置方法</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add()		<span class="comment">#为集合添加元素</span></span><br><span class="line">clear()		<span class="comment">#移除集合中的所有元素</span></span><br><span class="line">copy()		<span class="comment">#拷贝一个集合</span></span><br><span class="line">difference()	<span class="comment">#返回多个集合的差集</span></span><br><span class="line">difference_update()		<span class="comment">#移除集合中的元素，该元素在指定的集合也存在。</span></span><br><span class="line">discard()		<span class="comment">#删除集合中指定的元素</span></span><br><span class="line">intersection()		<span class="comment">#返回集合的交集</span></span><br><span class="line">intersection_update()		<span class="comment">#返回集合的交集</span></span><br><span class="line">isdisjoint()		<span class="comment">#判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</span></span><br><span class="line">issubset()			<span class="comment">#判断指定集合是否为该方法参数集合的子集。</span></span><br><span class="line">issuperset()		<span class="comment">#判断该方法的参数集合是否为指定集合的子集</span></span><br><span class="line">pop()		<span class="comment">#随机移除元素</span></span><br><span class="line">remove()	<span class="comment">#移除指定元素</span></span><br><span class="line">symmetric_difference()		<span class="comment">#返回两个集合中不重复的元素集合</span></span><br><span class="line">symmetric_difference_update()	</span><br><span class="line"><span class="comment">#移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中</span></span><br><span class="line">union()			<span class="comment">#返回两个集合的并集</span></span><br><span class="line">update()		<span class="comment">#给集合添加元素</span></span><br></pre></td></tr></table></figure></div>

<h5 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h5><ul>
<li>列表是有序的对象集合，字典是无序的对象集合，两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取</li>
<li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合</li>
<li>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中</li>
<li>键(key)必须使用不可变类型</li>
</ul>
<h6 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h6><p>把相应的键放入到方括号中：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tinydict['Name']: "</span>, tinydict[<span class="string">'Name'</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tinydict['Age']: "</span>, tinydict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure></div>

<h6 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h6><p>增加新的键/值对，修改或删除已有键/值对：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line">tinydict[<span class="string">'Age'</span>] = <span class="number">8</span>                <span class="comment"># 更新 Age</span></span><br><span class="line">tinydict[<span class="string">'School'</span>] = <span class="string">"菜鸟教程"</span>  	<span class="comment"># 添加信息</span></span><br></pre></td></tr></table></figure></div>

<h6 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = {<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">'Name'</span>] <span class="comment"># 删除键 'Name'</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br></pre></td></tr></table></figure></div>

<h6 id="字典键特性"><a href="#字典键特性" class="headerlink" title="字典键特性"></a>字典键特性</h6><ul>
<li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</li>
<li>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</li>
</ul>
<h6 id="字典内置函数和方法"><a href="#字典内置函数和方法" class="headerlink" title="字典内置函数和方法"></a>字典内置函数和方法</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">dict</span>)	<span class="comment">#计算字典元素个数，即键的总数</span></span><br><span class="line"><span class="built_in">str</span>(<span class="built_in">dict</span>)	<span class="comment">#输出字典，可以打印的字符串表示</span></span><br><span class="line"><span class="built_in">type</span>(variable)	<span class="comment">#返回输入的变量类型，如果变量是字典就返回字典类型</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.clear()	<span class="comment">#删除字典内所有元素</span></span><br><span class="line"><span class="built_in">dict</span>.copy()		<span class="comment">#返回一个字典的浅复制</span></span><br><span class="line"><span class="built_in">dict</span>.fromkeys()		<span class="comment">#创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</span></span><br><span class="line"><span class="built_in">dict</span>.get(key, default=<span class="literal">None</span>)		<span class="comment">#返回指定键的值，如果键不在字典中返回 default 设置的默认值</span></span><br><span class="line">key <span class="keyword">in</span> <span class="built_in">dict</span>		<span class="comment">#如果键在字典dict里返回true，否则返回false</span></span><br><span class="line"><span class="built_in">dict</span>.items()	<span class="comment">#以列表返回一个视图对象</span></span><br><span class="line"><span class="built_in">dict</span>.keys()		<span class="comment">#返回一个视图对象</span></span><br><span class="line"><span class="built_in">dict</span>.setdefault(key, default=<span class="literal">None</span>)		<span class="comment">#和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</span></span><br><span class="line"><span class="built_in">dict</span>.update(dict2)		<span class="comment">#把字典dict2的键/值对更新到dict里</span></span><br><span class="line"><span class="built_in">dict</span>.values()		<span class="comment">#返回一个视图对象</span></span><br><span class="line">pop(key[,default])		<span class="comment">#删除字典 key（键）所对应的值，返回被删除的值</span></span><br><span class="line">popitem()	<span class="comment">#返回并删除字典中的最后一对键和值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><ul>
<li>自动将一种数据类型转换为另一种数据类型</li>
<li>较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失</li>
<li>某些情况（例如字符串与整数相加）无法隐式转换</li>
</ul>
<h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><p>使用 int()、float()、str() 等预定义函数来执行显式类型转换</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="built_in">int</span>(<span class="number">2.8</span>) <span class="comment"># y 输出结果为 2</span></span><br><span class="line">w = <span class="built_in">float</span>(<span class="string">"4.2"</span>) <span class="comment"># w 输出结果为 4.2</span></span><br><span class="line">z = <span class="built_in">str</span>(<span class="number">3.0</span>)  <span class="comment"># z 输出结果为 '3.0'</span></span><br></pre></td></tr></table></figure></div>

<p>以下几个内置的函数可以执行数据类型之间的转换，这些函数返回一个新的对象，表示转换的值：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a class="link" href="https://www.runoob.com/python/python-func-int.html">int(x[,base]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将x转换为一个整数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-float.html">float(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将x转换到一个浮点数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python/python-func-complex.html">complex(real[,imag]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">创建一个复数</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-str.html">str(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-repr.html">repr(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-eval.html">eval(str) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python3-att-list-list.html">list(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-set.html">set(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">转换为可变集合</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-dict.html">dict(d) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">转换为不可变集合</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-chr.html">chr(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-ord.html">ord(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-hex.html">hex(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td align="center"><a class="link" href="https://www.runoob.com/python3/python-func-oct.html">oct(x) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td align="left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">+, -, *, /, %, **, //</span><br></pre></td></tr></table></figure></div>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">==, !=, &gt;, &lt; , &gt;=, &lt;=</span><br></pre></td></tr></table></figure></div>

<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">=, +=, -=, *=, /=, %=, **=, //=, :=</span><br></pre></td></tr></table></figure></div>

<p>(<code>:=</code>是海象运算符，可在表达式内部为变量赋值)</p>
<h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>假设a为10， b为20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th align="left">逻辑表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td align="left">x and y</td>
<td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值</td>
<td align="left">(a and b) 返回 20</td>
</tr>
<tr>
<td>or</td>
<td align="left">x or y</td>
<td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值</td>
<td align="left">(a or b) 返回 10</td>
</tr>
<tr>
<td>not</td>
<td align="left">not x</td>
<td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True</td>
<td align="left">not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h5 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#in, not in</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"变量 a 在给定的列表中 list 中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"变量 a 不在给定的列表中 list 中"</span>)</span><br></pre></td></tr></table></figure></div>

<p>指示指定序列中是否包含元素</p>
<h5 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(x) != id(y)**，如果引用的不是同一个对象则返回结果 True，否则返回 False</td>
</tr>
</tbody></table>
<p><strong>注：</strong> <a class="link" href="https://www.runoob.com/python/python-func-id.html">id() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 函数用于获取对象内存地址</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"1 - a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"1 - a 和 b 没有相同的标识"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">id</span>(a) == <span class="built_in">id</span>(b) ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"2 - a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"2 - a 和 b 没有相同的标识"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#1 - a 和 b 有相同的标识</span></span><br><span class="line"><span class="comment">#2 - a 和 b 有相同的标识</span></span><br></pre></td></tr></table></figure></div>

<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure></div>

<p>注：</p>
<ul>
<li><strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong></li>
<li>每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块</li>
<li>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块</li>
</ul>
<h5 id="match…case"><a href="#match…case" class="headerlink" title="match…case"></a>match…case</h5><p>match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，**_** 可以匹配一切:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure></div>

<p>实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    <span class="keyword">match</span> status:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Bad request"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Not found"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I'm a teapot"</span></span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Something's wrong with the internet"</span></span><br></pre></td></tr></table></figure></div>

<p>一个 case 也可以设置多个匹配条件，条件使用 <strong>｜</strong> 隔开</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>一般格式为：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure></div>

<p>注：</p>
<ul>
<li>同样需要注意冒号和缩进</li>
<li>Python 中没有 do..while 循环</li>
</ul>
<h5 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h5><p>如果while 后面的条件语句为 false 时，则执行 else 的语句块：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:    </span><br><span class="line">	&lt;statements&gt; </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">	&lt;statements&gt;</span><br></pre></td></tr></table></figure></div>

<p>实例如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sites = [<span class="string">"Baidu"</span>, <span class="string">"Google"</span>,<span class="string">"Runoob"</span>,<span class="string">"Taobao"</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="built_in">print</span>(site)</span><br><span class="line">    </span><br><span class="line">word = <span class="string">'runoob'</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">    <span class="built_in">print</span>(letter)</span><br></pre></td></tr></table></figure></div>

<h5 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h5><p>当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure></div>

<h5 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h5><p>会返回指定区间的值：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	     <span class="built_in">print</span>(i)</span><br><span class="line">	</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">     </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">     </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></div>

<h5 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h5><p>Python pass是空语句，是为了保持程序结构的完整性</p>
<p>pass 不做任何事情，一般用做占位语句:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">'执行 pass 块'</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br></pre></td></tr></table></figure></div>

<h3 id="Python推导式"><a href="#Python推导式" class="headerlink" title="Python推导式"></a>Python推导式</h3><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line">或者 </span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure></div>

<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">new_names = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">'ALICE'</span>, <span class="string">'JERRY'</span>, <span class="string">'WENDY'</span>, <span class="string">'SMITH'</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">{ key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection }</span><br><span class="line">或</span><br><span class="line">{ key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition }</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">listdemo = [<span class="string">'Google'</span>,<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line">newdict = {key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo}</span><br><span class="line"><span class="comment">#{'Google': 6, 'Runoob': 6, 'Taobao': 6}</span></span><br></pre></td></tr></table></figure></div>

<h5 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">{ expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> }</span><br><span class="line">或</span><br><span class="line">{ expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional }</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = {x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>}</span><br><span class="line"><span class="comment">#{'d', 'r'}</span></span><br></pre></td></tr></table></figure></div>

<h5 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h5><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure></div>

<p>元组推导式返回的结果是一个生成器对象:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代是Python访问集合元素的一种方式</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可使用for进行常规遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#也可以使用 next() 函数</span></span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></div>

<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><ul>
<li>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）</li>
<li>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield</strong> 后面的表达式作为当前迭代的值返回</li>
<li>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果</li>
</ul>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure></div>

<p>使用 yield 实现斐波那契数列：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></div>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong></li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算面积函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_welcome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome"</span>, name)</span><br><span class="line"> </span><br><span class="line">print_welcome(<span class="string">"Runoob"</span>)</span><br><span class="line">w = <span class="number">4</span></span><br><span class="line">h = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"width ="</span>, w, <span class="string">" height ="</span>, h, <span class="string">" area ="</span>, area(w, h))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Welcome Runoob</span></span><br><span class="line"><span class="string">width = 4  height = 5  area = 20</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><h6 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h6><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值，例如</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure></div>

<h6 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h6><p>调用函数时，如果没有传递参数，则会使用默认参数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"------------------------"</span>)</span><br><span class="line">printinfo( name=<span class="string">"runoob"</span> )	<span class="comment">#age = 35</span></span><br></pre></td></tr></table></figure></div>

<h6 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></div>

<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">70</span></span><br><span class="line"><span class="string">(60, 50)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<p>还有一种就是参数带两个星号 ******基本语法如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] **var_args_dict </span>):</span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></div>

<p>加了两个星号 ****** 的参数会以字典的形式导入:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">{'a': 2, 'b': 3}</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>

<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>Python 使用 <strong>lambda</strong> 来创建匿名函数</p>
<p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">"相加后的值为 : "</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"相加后的值为 : "</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure></div>

<p>将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> a : a * n</span><br><span class="line"> </span><br><span class="line">mydoubler = myfunc(<span class="number">2</span>)	<span class="comment">#a*2</span></span><br><span class="line">mytripler = myfunc(<span class="number">3</span>)	<span class="comment">#a*3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(mydoubler(<span class="number">11</span>))	<span class="comment">#22</span></span><br><span class="line"><span class="built_in">print</span>(mytripler(<span class="number">11</span>))	<span class="comment">#33</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 1</title>
    <url>/2023/03/17/Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%201/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第一单元作业总的训练目标是对表达式结构进行建模，体会层次化的思想，三次作业为迭代开发。第一次作业是完成对多项式括号的展开，第二次作业新引入了三角函数(sin,cos)以及自定义函数(f(x),g(x,y),h(x,y,z))，第三次作业新增求导因子(dx(表达式))并允许函数定义时调用其他已定义过的函数。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>我的总思路分为三步：</p>
<ol>
<li>预处理表达式</li>
<li>解析表达式</li>
<li>转化为字符串并打印</li>
</ol>
<h4 id="预处理表达式"><a href="#预处理表达式" class="headerlink" title="预处理表达式"></a>预处理表达式</h4><h5 id="PreStr"><a href="#PreStr" class="headerlink" title="PreStr"></a><code>PreStr</code></h5><p>预处理：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed81ddac507ccd3d7d8.png#pic_center"></p>
<ul>
<li>去除所有连续的空白字符（用Java自带的方法<code>replaceAll</code>即可解决）</li>
<li>通过一系列<code>replaceAll</code>使得字符串不含有连续的两个及以上的’+’和’-‘（例如”—-“应化为”+”，”+-“应化为”-“）</li>
<li>将表示幂次的”**”替换为”^”，防止与乘号弄混，产生不必要的bug</li>
</ul>
<h4 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h4><h5 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a><code>Lexer</code></h5><p>读取处理：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc1e.png#pic_center"></p>
<ul>
<li><code>read()</code>能够保证每次取出当前的操作数或者运算符</li>
<li><code>next()</code>能够往后读一个操作数或者运算符</li>
<li>由于数字长度的不确定，使用<code>getNumber()</code>能够取出当前数字</li>
</ul>
<h5 id="Ele"><a href="#Ele" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>根据题目要求，我选择新建一个<code>Ele</code>类完成对基本元素的存储，每一个<code>Ele</code>应形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd382e8.png#pic_center"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd38349.png#pic_center"></p>
<p><code>coe</code>存储每一个<code>Ele</code>的系数，<code>hashVar</code>通过<code>HashMap</code>存储变量及其对应幂次。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a935.png#pic_center"></p>
<p>刚开始写<code>Ele</code>时只写了<code>setCoe()</code>,<code>getCoe()</code>,<code>setHashVar()</code>,<code>getHashVar()</code>四个方法用于设定值和取值，其他方法是在后续框架的整体搭建中书写的，因此放到后面讲解。</p>
<h5 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>一连串的表达式形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd382fe.png#pic_center"></p>
<p>此处系数本身是可能带符号的，因此直接用加号相连。</p>
<p>为了方便数据的调用，我选择<code>ArrayList</code>来存储多个<code>Ele</code>：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a95c.png#pic_center"></p>
<p><code>Expr</code>方法中，<code>initExperList(ArrayList&lt;Ele&gt;)</code>,<code>initExpr(Ele)</code>用于初始化，<code>getExperlist()</code>用于取出该<code>ArrayList</code>，其他很多方法是在构建整体的过程中完成的，因此也放到后面。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a9a2.png#pic_center"></p>
<h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a><code>Parser</code></h5><p>使用递归下降解析表达式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39dc3.png#pic_center"></p>
<p>注：<code>dealEx(Expr)</code>是<code>parseExpr()</code>的一部分，分离出来是因为方法过长影响码风:）</p>
<p>1.<code>parseExpr()</code>用于解析表达式，根据定义，表达式由加法和减法运算符连接若干项组成并且在第一项之前，可以带一个正号或者负号，表示第一个项的正负，因此考虑如下结构。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">parseExpr</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (当前符号 == <span class="string">'+'</span> || 当前符号 == <span class="string">'-'</span>) { <span class="comment">//表达式的第一个项可以有符号（+，-）</span></span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (当前符号 == <span class="string">'+'</span> || 当前符号 == <span class="string">'-'</span>) {</span><br><span class="line">            parseTerm();</span><br><span class="line">            combTerm();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<p>此处涉及到正负号的处理，因此不在方法中区分加减，而是新建合并的方法<code>Expr.combTerm(ArrayList&lt;Ele&gt; list, String s)</code>，<code>s</code>代表符号。若<code>s</code>为负号，就通过<code>Expr.reverseList(ArrayList&lt;Ele&gt; list)</code>取反，然后使用<code>addAll()</code>，考虑性能，我们需要化简，在<code>combTerm</code>之后使用<code>merge()</code>合并同类项。</p>
<p>2.<code>parseTerm()</code>用于解析项，项由乘法运算符连接若干因子组成，总体架构与上文相似，只是要重新写一个乘法的方法，也就是<code>Expr.mulTerm(ArrayList&lt;Ele&gt;)</code>能够实现两个<code>ArrayList&lt;Ele&gt;</code>的相乘（实际上就是多个相加）。</p>
<p>3.<code>parseFactor()</code>用于解析因子。由定义知，因子包括幂函数，常数因子和表达式因子。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">parseFactor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (符号 == <span class="string">'('</span>) { <span class="comment">//表达式因子，函数表达式（已在PreStr中套上了一层括号，因此也可以当成表达式因子处理）</span></span><br><span class="line">            parseExpr();</span><br><span class="line">            <span class="keyword">if</span> (下一个符号是<span class="string">'^'</span>) { <span class="comment">//下一个一定为指数</span></span><br><span class="line">                <span class="comment">//读入下一个整数n;</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) { <span class="comment">//考虑特殊情况</span></span><br><span class="line">                    <span class="comment">//置1;</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//重复的乘原表达式n-1次;</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (符号 == <span class="string">'+'</span> || 符号 == <span class="string">'-'</span>) { <span class="comment">//不是第一个带符号的因子，则一定为有符号常数</span></span><br><span class="line">            <span class="comment">//读入常数n并结合当前符号;</span></span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (符号为数字) { <span class="comment">//处理无符号整数</span></span><br><span class="line">           <span class="comment">// 读入常数n;</span></span><br><span class="line">            <span class="keyword">return</span> expr;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">//处理幂函数</span></span><br><span class="line">            <span class="keyword">return</span>  parsePow();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<p>4.<code>parsePow()</code>同上文分支一样，用于解析幂函数，并返回一个<code>Expr</code>类。这里单独写是因为方法行数太多影响码风：)</p>
<h4 id="转化为字符串并打印"><a href="#转化为字符串并打印" class="headerlink" title="转化为字符串并打印"></a>转化为字符串并打印</h4><p>这一点主要体现在<code>Expr</code>类中的<code>toString()</code>方法。总的思路是设置<code>StringBuilder</code>然后不断<code>append</code>。对<code>ArrayList</code>中的每一个<code>Ele</code>依次判断是否有’+’，是否为正负1，幂次是否为0，整体是否为0。（这一部分细节还挺多的需要特别注意）</p>
<h3 id="基于度量的程序结构分析"><a href="#基于度量的程序结构分析" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析"><a href="#代码规模分析" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b8ec.png#pic_center"></p>
<p>核心代码在450行左右，<code>Expr</code>类行数最多，占到了175行，其次是119行的解析<code>Parser</code>类。</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度"><a href="#方法复杂度" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">16</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.canMerge(Ele)</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">expr.Ele.compareTo(Object)</td>
<td align="left">7</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">expr.Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.isOne()</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">expr.Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.sort()</td>
<td align="left">9</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">expr.Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">118</td>
<td align="left">49</td>
<td align="left">109</td>
<td align="left">117</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">3.47</td>
<td align="left">1.44</td>
<td align="left">3.21</td>
<td align="left">3.44</td>
</tr>
</tbody></table>
<h5 id="类复杂度"><a href="#类复杂度" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b913.png"></p>
<p>表中可以看出最复杂的三个方法：<code>Parser.parseFactor()</code>，<code>expr.Expr.toString()</code>和<code>expr.Expr.varStr(Ele)</code>。由于因子的可能类型较多，讨论情况较多，因此复杂度也较高。后两者都是转化为字符串的方法，由于情况种类较多，因此复杂度上升较显著。</p>
<p>图中也能看到<code>Expr</code>类，<code>Ele</code>类和<code>Parser</code>类的复杂度较高，<code>Parser</code>类中分解的方法较多，<code>Expr</code>和<code>Ele</code>中计算合并之类的方法较多导致了这几个类的复杂度较高。</p>
<h6 id="附：度量分析条目解释"><a href="#附：度量分析条目解释" class="headerlink" title="附：度量分析条目解释"></a>附：度量分析条目解释</h6><ul>
<li>CogC：认知复杂度</li>
<li>ev(G)：非抽象方法的基本复杂度，用以衡量一个方法的控制流结构缺陷，范围是 [1, v(G)]</li>
<li>iv(G)：方法的设计复杂度，用以衡量方法控制流与其他方法之间的耦合程度，范围是 [1, v(G)]</li>
<li>v(G)：非抽象方法的圈复杂度，用以衡量每个方法中不同执行路径的数量</li>
<li>OC：类的非抽象方法圈复杂度，继承类不计入</li>
<li>WMC：类的总圈复杂度</li>
</ul>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39d21.jpg#pic_center"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业新增了这些要求：</p>
<ul>
<li>支持嵌套多层括号</li>
<li>新增三角函数因子，三角函数括号内部包含任意因子</li>
<li>新增自定义函数因子，但自定义函数的函数表达式中不会调用其他函数</li>
</ul>
<p>因此在第一次作业的基础上，需要完成这些工作：</p>
<ol>
<li>替换自定义函数</li>
<li>引入新的数据结构能够存储三角因子</li>
<li>增加或完善方法并完成三角函数的计算与化简</li>
</ol>
<h4 id="替换自定义函数"><a href="#替换自定义函数" class="headerlink" title="替换自定义函数"></a>替换自定义函数</h4><h5 id="DeFun"><a href="#DeFun" class="headerlink" title="DeFun"></a><code>DeFun</code></h5><p>仅仅实现替换，替换之后即可按照之前的递归下降实现表达式解析：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd3838f.png#pic_center"></p>
<ul>
<li>根据’=’分割成左右两字符串，左边的可根据’,’找出形参，将形参和右边的表达式存入<code>HashMap</code></li>
<li>在原表达式中通过<code>process()</code>替换所有的自定义函数</li>
</ul>
<h4 id="处理三角因子"><a href="#处理三角因子" class="headerlink" title="处理三角因子"></a>处理三角因子</h4><h5 id="Ele-1"><a href="#Ele-1" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>本次作业每个<code>Ele</code>类型应形如：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeea81ddac507ccd3831e.png#pic_center"></p>
<p>将三角因子括号内部的因子<code>toString</code>作为<code>key</code>，指数作为<code>value</code>再存入<code>HashMap</code>：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a9d7.png#pic_center"></p>
<p>增加了处理三角因子的方法：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc7d.png"></p>
<h5 id="Expr-1"><a href="#Expr-1" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>加法和乘法只需在原有基础上添加三角因子的运算即可（加法乘法需要在<code>canMerge()</code>中添加条件)。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeed01ddac507ccd3cc2b.png"></p>
<p>在<code>toString()</code>中加上打印三角因子的方法<code>triStr(Ele)</code>。</p>
<h3 id="基于度量的程序结构分析-1"><a href="#基于度量的程序结构分析-1" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析-1"><a href="#代码规模分析-1" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b9a6.png"></p>
<p>核心代码在742行左右，<code>Expr</code>类行数最多，占到了259行，其次是150行的解析<code>Parser</code>类。</p>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度-1"><a href="#方法复杂度-1" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DeFun.max(int, int)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">DeFun.process(String)</td>
<td align="left">22</td>
<td align="left">6</td>
<td align="left">13</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">DeFun.readFun(String)</td>
<td align="left">6</td>
<td align="left">3</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">18</td>
<td align="left">5</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Parser.parseTri()</td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.canMerge(Ele)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">expr.Ele.compareTo(Object)</td>
<td align="left">27</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">expr.Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashCos()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashSin()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.isOne()</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">expr.Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.putHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Ele.putHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashCos(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashSin(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">expr.Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">expr.Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">expr.Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">expr.Expr.simplify()</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">expr.Expr.sort()</td>
<td align="left">32</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">expr.Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.triStr(Ele)</td>
<td align="left">14</td>
<td align="left">1</td>
<td align="left">11</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">expr.Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">expr.Term.getTermList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">233</td>
<td align="left">90</td>
<td align="left">180</td>
<td align="left">195</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">4.75</td>
<td align="left">1.83</td>
<td align="left">3.67</td>
<td align="left">3.97</td>
</tr>
</tbody></table>
<h5 id="类复杂度-1"><a href="#类复杂度-1" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b9f2.png"></p>
<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeec21ddac507ccd3b943.jpg"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业新增了这些要求：</p>
<ul>
<li>自定义函数定义时可以调用已经定义过的自定义函数</li>
<li>新增求导因子</li>
</ul>
<p>因此，在第二次作业的基础上，需要完成这些工作：</p>
<ol>
<li>在<code>DeFun</code>类中完善方法使支持调用定义过的自定义函数并且包含求导因子</li>
<li>在<code>Expr</code>类中新增求导的方法</li>
</ol>
<h4 id="完善替换自定义函数的方法"><a href="#完善替换自定义函数的方法" class="headerlink" title="完善替换自定义函数的方法"></a>完善替换自定义函数的方法</h4><h5 id="DeFun-1"><a href="#DeFun-1" class="headerlink" title="DeFun"></a><code>DeFun</code></h5><p>在同一个类中替换已经存在于HashMap中的自定义函数，然后替换求导因子（根据题目要求，需要在这里将求导因子化简并替换），因此我们直接复用之前的Parser类解析求导因子内部的表达式，并且用<code>toString()</code>替换原求导因子。</p>
<p>下面是可能的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.contains(<span class="string">"d"</span>)) { <span class="comment">//求导因子只出现一次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> str.indexOf(<span class="string">"d"</span>);</span><br><span class="line">            <span class="comment">//subString = dx(表达式) | dy(表达式) | dz(表达式)，是求导因子</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> sim.substring(<span class="comment">/*将dx()或dy()或dz()的子串提取出来*/</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">derFact</span> <span class="operator">=</span> subString.substring(<span class="number">2</span>); <span class="comment">//derFact是需要求导的表达式</span></span><br><span class="line">            parser.parseExpr();<span class="comment">//预处理，解析，返回一个Expr类</span></span><br><span class="line">            expr.derExpr();<span class="comment">//括号内的表达式进行求导能够返回一个Expr类</span></span><br><span class="line">            str = str.replace(subString, <span class="string">"("</span> + expr + <span class="string">")"</span>); <span class="comment">//将整个求导因子剔除（替换）</span></span><br><span class="line">        }</span><br></pre></td></tr></table></figure></div>

<h4 id="增加求导的方法"><a href="#增加求导的方法" class="headerlink" title="增加求导的方法"></a>增加求导的方法</h4><h5 id="Ele-2"><a href="#Ele-2" class="headerlink" title="Ele"></a><code>Ele</code></h5><p>在<code>Ele</code>中增加方法支持判断该<code>Ele</code>是否包含该变量（’x’,’y’,’z’)，若不包含，则求导的结果为零，反之则可进行正常的求导。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39cef.png"></p>
<h5 id="Expr-2"><a href="#Expr-2" class="headerlink" title="Expr"></a><code>Expr</code></h5><p>增加支持求导的方法，<code>derExpr(char)</code>中对参数<code>char</code>作为自变量求导，分别对每一个<code>Ele</code>的变量部分，三角因子部分进行求导再合并。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb91ddac507ccd3a8f4.png"></p>
<h3 id="基于度量的程序结构分析-2"><a href="#基于度量的程序结构分析-2" class="headerlink" title="基于度量的程序结构分析"></a>基于度量的程序结构分析</h3><h4 id="代码规模分析-2"><a href="#代码规模分析-2" class="headerlink" title="代码规模分析"></a>代码规模分析</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeecf1ddac507ccd3cb6a.png"></p>
<p>核心代码在899行左右，<code>Expr</code>类行数最多，占到了370行，其次是173行的解析<code>Expr</code>类。</p>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="方法复杂度-2"><a href="#方法复杂度-2" class="headerlink" title="方法复杂度"></a>方法复杂度</h5><table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">CogC</th>
<th align="left">ev(G)</th>
<th align="left">iv(G)</th>
<th align="left">v(G)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DeFun.findRi(int, String)</td>
<td align="left">9</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">DeFun.max(int, int)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">DeFun.process(String)</td>
<td align="left">10</td>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">DeFun.readFun(String)</td>
<td align="left">7</td>
<td align="left">3</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Ele.Ele()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.canMerge(Ele)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Ele.compareTo(Object)</td>
<td align="left">27</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Ele.cosContain(String)</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.getCoe()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashCos()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashSin()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.getHashVar()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.initHashVar(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.isOne()</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">Ele.isZero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.putHashCos(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.putHashSin(HashMap&lt;String, BigInteger&gt;)</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.setCoe(BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashCos(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashSin(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.setHashVar(String, BigInteger)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Ele.sinContain(String)</td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Ele.varContain(String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Ele.zero()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.combTerm(ArrayList, String)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.derCos(int, String)</td>
<td align="left">7</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Expr.derExpr(char)</td>
<td align="left">14</td>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">Expr.derSin(int, String)</td>
<td align="left">7</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Expr.derVar(int, String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.getExprList()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.initExpr(Ele)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.initExprList(ArrayList)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Expr.merge()</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Expr.mulTerm(ArrayList)</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Expr.reverse()</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.reverseList(ArrayList)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Expr.simplify()</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Expr.sort()</td>
<td align="left">32</td>
<td align="left">13</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Expr.toString()</td>
<td align="left">16</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">Expr.triStr(Ele)</td>
<td align="left">22</td>
<td align="left">1</td>
<td align="left">13</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Expr.varStr(Ele)</td>
<td align="left">21</td>
<td align="left">1</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Lexer.Lexer(String)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Lexer.getNumber()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Lexer.next()</td>
<td align="left">6</td>
<td align="left">2</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Lexer.read()</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">MainClass.main(String[])</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Parser.Parser(Lexer)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.dealEx(Expr)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseDer(char)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Parser.parseExpr()</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Parser.parseFactor()</td>
<td align="left">20</td>
<td align="left">6</td>
<td align="left">14</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">Parser.parsePow()</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Parser.parseTerm()</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Parser.parseTri()</td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">PreStr.pre(String)</td>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">277</td>
<td align="left">102</td>
<td align="left">214</td>
<td align="left">230</td>
</tr>
<tr>
<td align="left">Average</td>
<td align="left">4.85</td>
<td align="left">1.79</td>
<td align="left">3.75</td>
<td align="left">4.04</td>
</tr>
</tbody></table>
<h5 id="类复杂度-2"><a href="#类复杂度-2" class="headerlink" title="类复杂度"></a>类复杂度</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeecf1ddac507ccd3cb95.png"></p>
<p>图中也能看到<code>Expr</code>类，<code>Ele</code>类和<code>Parser</code>类的复杂度较高，Expr类中大量的化简、计算和求导方法使得该类复杂度很高。</p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eeeb41ddac507ccd39d81.jpg"></p>
<p>每个类的设计考虑已在上文的设计与架构中说明，此处不再赘述。</p>
<h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><h3 id="分析自己程序的bug"><a href="#分析自己程序的bug" class="headerlink" title="分析自己程序的bug"></a>分析自己程序的bug</h3><h5 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h5><ul>
<li>一些特殊点的情况，例如：0^0+5^0+2*10^0，需要提前做好调试并在<code>toString()</code>中修改</li>
</ul>
<h5 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h5><ul>
<li>替换自定义函数时根据逗号分割，因此在面对嵌套函数例如f(g(y,z),h(x,y),sin(x))中存在多于2个逗号的情况可能会出错，解决方案是每次循环找到最靠后的一个自定义函数（保证这个函数里异地没有嵌套的自定义）进行替换</li>
<li>注意替换时索引的位置，例如f((((x,y,z))))可能会出现括号判断错误</li>
<li>注意特殊和边界点，例如sin((0))^2,sin((0))^0,cos((0))^3</li>
<li>幂次为0时应该直接读取整数而不是往后解析表达式（大概是脑子抽了才这样写，大部分类似的问题全都是这点引起的）</li>
</ul>
<h5 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h5><ul>
<li>求导之后化简会出问题，例如dx(x*cos(x)**0)最后解析得到的Expr没有问题但是输出会出错，原因在于我判断cos部分含不含x是根据HashMap是否为空（第二次作业的遗留），但是在求导之后我没有进行相应的remove工作，导致输出错误</li>
</ul>
<h3 id="分析他人程序的bug"><a href="#分析他人程序的bug" class="headerlink" title="分析他人程序的bug"></a>分析他人程序的bug</h3><p>手动构造具有代表性的边界数据，拥有多层嵌套括号，同时包含特殊条件（结果为0，1，求导内部无自变量），例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title function_">f</span>(x,y)=(((<span class="title function_">sin</span>(<span class="title function_">cos</span>(x))-(+<span class="number">1</span>-<span class="title function_">sin</span>(<span class="title function_">cos</span>(y))))))</span><br><span class="line"><span class="title function_">f</span>((<span class="title function_">sin</span>(x)),(y**<span class="number">2</span>-<span class="number">0</span>**<span class="number">0</span>))+<span class="title function_">cos</span>(<span class="number">0</span>)**<span class="number">0</span>-<span class="title function_">sin</span>(<span class="number">0</span>)**<span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="title function_">dx</span>(x*<span class="title function_">cos</span>(x)**<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>第一单元作业主要是针对表达式括号展开和求导的三次迭代开发。从最开始的不理解git的作用，到现在渐渐认识到版本管理在工程中的重要性；从对IDEA的无所适从和屡次犯错，到逐渐领略到这款IDE功能的强大；从最开始的对Java感到陌生，到逐渐熟悉它的众多优良简便的方法、数据结构和其面向对象的思维。同时，三次作业对代码风格的要求使我进一步意识到码风的重要性并逐渐内在地提升了自己编程的码风。第一次作业由于只有整体的架构，在缺少对Java语法以及数据结构等知识的缺乏的情况下，完成得非常艰难。在第二次第三次的迭代开发中，任务量明显比第一次的从零开始要轻松一些，但是要特别特别注意类以及方法之间的耦合性，尽量不改变现有的方法，这样更容易发现代码的bug。最后，我认为可以多参考讨论区里同学们的设计思路，这对于我的架构设计有很大的帮助^_^ 感谢助教和同学们的热心帮助！</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 4</title>
    <url>/2023/06/18/Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%204/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第四单元作业主要任务是完成一个图书馆模拟系统，以训练对程序架构的设计和抽象能力。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="本单元所实践的正向建模与开发"><a href="#本单元所实践的正向建模与开发" class="headerlink" title="本单元所实践的正向建模与开发"></a>本单元所实践的正向建模与开发</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在正向建模与开发的过程中，首先需要进行需求分析。根据指导书，我们需要完成这些任务：</p>
<ul>
<li>选用合适的方式表示书本，并提供合适的容器。在第一次作业中，由于不涉及校际借阅，情况较为简单，因此我直接用字符串（书本名称）指代这本书，所有的容器都采用<code>HashMap&lt;String, Integer&gt;</code>的形式表示对应书本及其数量。但是后续作业中新增了校际借阅的功能，这意味着每一本书都有其来源学校，并且还存在是否允许借阅的权限问题。因此必须重构，对书建类<code>Book</code>类，在构造方法中提供对来源地（<code>source</code>）、书名（<code>bookName</code>）、是否允许校际借阅（<code>permisssion</code>）的初始化并配置对应访问方法，重构之后所有存储书的容器就应该转化为<code>HashMap&lt;Book, Integer&gt;</code>。值得注意的是，将Book类作为键时，需要确保重新实现了<code>hashCode()</code>和<code>equals()</code>方法，以便在<code>HashMap</code>中正确地进行键的比较和查找，这样可以确保相同的书对象将被视为相等的键。比如：<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ((bookName == <span class="literal">null</span>) ? <span class="number">0</span> : bookName.hashCode());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) {</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Book</span> <span class="variable">other</span> <span class="operator">=</span> (Book) obj;</span><br><span class="line">    <span class="keyword">return</span> bookName.equals(other.bookName);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li>对于每种职责的管理人员需要为其建类并提供相应的方法处理书本，其中大部分标准输出在这些类里完成。请看下一小节 <strong>类设计</strong></li>
<li>处理日期。注意到作业要求整理日早晨必须整理并输出，因此对于图书借阅的标准输入要按照这样的步骤来处理：<ol>
<li>判断是否日期发生变化，若没有发生变化，继续处理当前信息</li>
<li>日期发生变化，处理当天没有成功处理的信息（没有成功借书，走校际借阅or校内预定（等书或者购买））</li>
<li>从变化前日期后一天开始，遍历所有在变化后日期之前的整理日，按顺序（完成新书购置，整理图书并输出整理信息，发放预定图书）处理<br>其中日期可以调用<code>java.time.LocalDate</code>现有的方法，比如：<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;String&gt; <span class="title function_">findArDays</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">initDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">startDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">endDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">    HashSet&lt;String&gt; datesSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (startDate.isBefore(endDate)) { <span class="comment">//isBefore可以比较日期前后</span></span><br><span class="line">        <span class="keyword">if</span> (initDate.until(startDate, ChronoUnit.DAYS) % <span class="number">3</span> == <span class="number">0</span>) { <span class="comment">//until返回日期间隔天数</span></span><br><span class="line">			datesSet.add(<span class="string">'['</span> + startDate.toString() + <span class="string">']'</span>);</span><br><span class="line">        }</span><br><span class="line">        startDate = startDate.plusDays(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    datesSet.add(<span class="string">'['</span> + initDate.toString() + <span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">return</span> datesSet;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
（在程序开始之前的静态方法，找出这一年所有整理日，之后通过<code>contains()</code>可以判断是否为整理日）</li>
</ol>
</li>
</ul>
<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><h4 id="Student"><a href="#Student" class="headerlink" title="Student"></a><code>Student</code></h4><p> 每一个学生都是独一无二的，由于后续作业表明不同学校可能有相同学号的学生，因此每个Student类中需要包含学校名和学生名(学号）两个字段。此外，每个学生借书还书还需要提供书的容器，以及保存当前拥有书籍借阅日期的信息：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bde1ddac507cc00c7a2.png"></p>
<p>对于书籍的损坏，我并没有将损坏作为一个字段放在<code>Book</code>类中，而是对于在<code>Student</code>类中新建<code>HashSet&lt;Book&gt;</code>中保存已损坏的书籍。下面是借书还书的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowB</span><span class="params">(Book book, String date)</span> {</span><br><span class="line">    <span class="built_in">this</span>.bs.add(book);</span><br><span class="line">    <span class="built_in">this</span>.borrowDate.put(book.getName(), date);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">returnB</span><span class="params">(String bookName)</span> {</span><br><span class="line">    <span class="type">Book</span> <span class="variable">reBook</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Book book: bs) {</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(bookName)) {</span><br><span class="line">            reBook = book;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.bs.remove(reBook);</span><br><span class="line">    <span class="built_in">this</span>.borrowDate.remove(bookName);</span><br><span class="line">    <span class="keyword">return</span> reBook;</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></div>

<p>在主函数Main中，我是用<code>HashMap&lt;String, HashMap&lt;String, Student&gt;&gt; students</code>来保存所有的学生的。</p>
<h4 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a><code>Lib</code></h4><p>用于表示每个学校的图书馆。提供查询图书方法，以及查询借阅是否合法（针对预定），校内借阅，校际借阅的方法。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b77f.png"></p>
<h4 id="Bar（borrowing-and-returning-librarian）"><a href="#Bar（borrowing-and-returning-librarian）" class="headerlink" title="Bar（borrowing and returning librarian）"></a><code>Bar</code>（borrowing and returning librarian）</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b723.png"></p>
<p> 借还管理员类中应包含学校名称，接受校内归还的图书以及未成功借出的图书存储到<code>barLib</code>，校际借阅归的图书还到<code>outBooks</code>。其中包含了借书还书，赔偿罚款，运走接受书籍（校际借阅），判断日期间隔的方法。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b75c.png"></p>
<h4 id="Mace-self-service-machine"><a href="#Mace-self-service-machine" class="headerlink" title="Mace(self-service machine)"></a><code>Mace</code>(self-service machine)</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd31ddac507cc00b7c5.png"></p>
<p>与上文借还管理员类相似。</p>
<h4 id="Rai（logistics-division）"><a href="#Rai（logistics-division）" class="headerlink" title="Rai（logistics division）"></a><code>Rai</code>（logistics division）</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bde1ddac507cc00c77a.png"></p>
<p>后勤管理处用于修补损坏的图书，提供<code>raiLib</code>存储校内借阅的图书，<code>outBooks</code>存储校际借阅的图书。同时提供运送书籍和接收书籍的方法。</p>
<h4 id="Odr-ordering-librarian"><a href="#Odr-ordering-librarian" class="headerlink" title="Odr(ordering librarian)"></a><code>Odr</code>(ordering librarian)</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bd41ddac507cc00b855.png"></p>
<p>预定管理员通过<code>orderList</code>和<code>buyList</code>记录每一天需要进行校内预定（等待还书和购买）的信息，同时提供一个存储书籍的容器<code>counter</code>和存储购买的新书的容器<code>buyMap</code>。该类还提供分发书籍，将书籍放回图书馆等方法。</p>
<h3 id="设计细节与bug分析"><a href="#设计细节与bug分析" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h3><ul>
<li><p>利用泛型存储每个学校的所有管理员对象：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用TreeMap在遍历时可以按照字典序输出</span></span><br><span class="line">TreeMap&lt;String, ArrayList&lt;Object&gt;&gt; schools = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//ArrayList&lt;Object&gt;可以允许不同的类型存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initDepartment</span><span class="params">(ArrayList&lt;Object&gt; departments, String schoolName)</span> {</span><br><span class="line">    <span class="type">Bar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bar</span>(schoolName);<span class="comment">// 1-&gt;Bar BorrowingAndReturningLibrarian</span></span><br><span class="line">    departments.add(bar);</span><br><span class="line">    <span class="type">Odr</span> <span class="variable">odr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Odr</span>(schoolName);<span class="comment">// 2-&gt;Odr OrderLibrarian</span></span><br><span class="line">    departments.add(odr);</span><br><span class="line">    <span class="type">Mace</span> <span class="variable">mace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mace</span>(schoolName);<span class="comment">// 3-&gt;Mace ServiceMachine</span></span><br><span class="line">    departments.add(mace);</span><br><span class="line">    <span class="type">Rai</span> <span class="variable">rai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rai</span>(schoolName);<span class="comment">// 4-&gt;Rai LogisticsDivision</span></span><br><span class="line">    departments.add(rai);</span><br><span class="line">    <span class="type">Arg</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arg</span>(schoolName);<span class="comment">// 5-&gt;Arg ArrangingLibrarian</span></span><br><span class="line">    departments.add(arg);</span><br><span class="line">    <span class="type">Pcd</span> <span class="variable">pcd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pcd</span>(schoolName);<span class="comment">// 6-&gt;Pcd PurchasingDepartment</span></span><br><span class="line">    departments.add(pcd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>特别注意最后一条信息之后也要处理当天的预定信息：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) {<span class="comment">//m条图书借还信息</span></span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">if</span> (i == m - <span class="number">1</span>) {</span><br><span class="line">        process(proList, schools, transList, students);<span class="comment">//处理所有没能借成功的信息</span></span><br><span class="line">        transport(transList, schools, today);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注意日期的加减，应该调用<code>plusDays()</code>方法，而不是将day++然后手动转化，比如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">findArrDay</span><span class="params">(String year, String month, String day)</span> {</span><br><span class="line">    <span class="keyword">return</span> LocalDate.of(year, month, day).plusDays(<span class="number">1</span>).toString();</span><br><span class="line">    <span class="comment">//错误示范：</span></span><br><span class="line">    <span class="comment">//String nextDay = (Integer.parseInt(day) + 1).toString();</span></span><br><span class="line">    <span class="comment">//return LocalDate.of(year, month, nextDay).toString();</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="最终的代码和UML模型设计之间的追踪关系"><a href="#最终的代码和UML模型设计之间的追踪关系" class="headerlink" title="最终的代码和UML模型设计之间的追踪关系"></a>最终的代码和UML模型设计之间的追踪关系</h2><p>本单元作业在第二次作业进行了重构。因为考虑到校际借阅的问题，每个图书中包含的信息量增大，不能仅仅用字符串来表示，这样底层的容器，方法必须全部修改。此外还要考虑多个学校多个管理员以及顺序输出，因此schools存储结构也要改变（相比之下，我的第一次作业就是一种单例模式）。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f0bdf1ddac507cc00c823.png"></p>
<p>最终的代码和UML图基本吻合。从UML类图可以看出，图书馆的各个管理员都建立了类，每个类内部提供方法执行对应的职能，在主类中直接调用对象的方法即可。</p>
<h2 id="四个单元中架构设计思维的演进"><a href="#四个单元中架构设计思维的演进" class="headerlink" title="四个单元中架构设计思维的演进"></a>四个单元中架构设计思维的演进</h2><ul>
<li>第一单元（表达式化简）：架构设计的雏形，第一次接触到用递归下降方法解析表达式。我们需要通过各个类来实现具体的解析和计算，可以简单理解为分工合作，各个部分完成的工作大不相同却又相辅相成，相互依赖</li>
<li>第二单元（多线程和电梯）：初步接触多线程编程，通过调度器类支持整个模块的运转</li>
<li>第三单元（JML与规格）：掌握编程的规范化，了解了接口，继承以及多态（<code>emojiMessage, moneyMessage等</code>)在面向对象中的实现</li>
<li>第四单元（通过UML对图书馆建模）：根据需求绘制UML类图，根据图进行正向建模</li>
</ul>
<h2 id="四个单元中测试思维的演进"><a href="#四个单元中测试思维的演进" class="headerlink" title="四个单元中测试思维的演进"></a>四个单元中测试思维的演进</h2><p>前两个单元主要依靠讨论区同学们提供的评测机以及手动构造数据来进行测试，认识到自动化测试是一种高效的测试方法。</p>
<p>第三单元主要依靠JUnit进行方法进行单元测试，通过编写单元测试类和方法，来实现对类和方法实现正确性的快速检查和测试，可以很好排除bug。</p>
<p>第四单元的测试点并没有刻意去增加强度，而是希望我们把重点放在UML图的设计中，手动构造数据即可很容易地通过测试。</p>
<h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><ul>
<li>深入理解了面向对象的思维方式。面向对象强调将问题领域的概念和行为转化为对象，并通过它们之间的交互来解决问题。这种思维方式使得系统的设计更加模块化、可扩展和可维护。比如说第一单元表达式分为表达式，项，因子类等，第四单元将众多图书管理员各自建立类实现。</li>
<li>熟悉了一门编程语言。不得不说，Java和C语言在很多方面都有相似之处，通过面向对象的学习可以让我在实践中逐渐掌握一门新的语言。</li>
<li>认识了一些设计模式。设计模式如工厂模式、观察者模式和单例模式等，提供了解决特定问题的经典解决方案。这些模式对于构建高质量的软件系统至关重要。</li>
<li>对测试有了新的理解。千万不要妄想着一遍不做任何测试就能成功，即使整体思路不存在问题，还是会出现许多小bug，因此做好测试是十分有必要的。</li>
</ul>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 2</title>
    <url>/2023/04/14/Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%202/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第二单元作业的基本训练目标是模拟<strong>多线程实时电梯系统</strong>，三次作业为迭代开发。</p>
<ul>
<li>第一次作业要求设计一个具有功能为上下行，开关门，以及模拟乘客进出的电梯系统，目标是让我们熟悉线程的创建、运行等基本操作，熟悉多线程程序的设计方法；</li>
<li>第二次作业新增加了模拟电梯系统扩建和日常维护时乘客的调度的功能，目标是让我们掌握线程安全知识并解决线程安全问题，同时在架构上围绕线程之间的协同设计层次架构；</li>
<li>第三次作业新增电梯系统调度参数，具体来说是对每一层楼正处于开门状态的电梯数量加以限制，同时电梯不一定满足每层楼可达， 目标是让我们掌握线程之间的交互，强化线程之间的协同设计层次架构。</li>
</ul>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业需要完成这些工作：</p>
<ol>
<li>设计一个<strong>队列</strong>类，用于进行乘客进入/移除，同时还需有判断是否为空/是否结束和设定结束等方法</li>
<li>设计一个<strong>调度器</strong>类，作为总等候队列与电梯之间的桥梁，需要完成对乘客的分配工作</li>
<li>设计一个<strong>电梯</strong>类，能够完成题目要求的任务</li>
<li>在<code>Main</code>中启动调度器线程和电梯线程，并将输入（如果有）送给总等候队列，结束时将等候队列设定结束</li>
</ol>
<blockquote>
<p>说明：本次作业课程组已经为我们提供了输入输出的接口，因此不再考虑解析输入的请求和格式化时间戳输出。</p>
</blockquote>
<h4 id="队列类"><a href="#队列类" class="headerlink" title="队列类"></a>队列类</h4><h5 id="PassengerQueue"><a href="#PassengerQueue" class="headerlink" title="PassengerQueue:"></a><code>PassengerQueue</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec5ffb.png"></p>
<p> <code>addPassenger(Passenger)</code>和<code>removePassenger(Passenger)</code>用于添加和移除乘客，<code>getOnePassenger()</code>用于分配乘客时按时间先后取出，<code>setEnd(boolean)</code>用于设定队列结束。其他方法用于返回该队列的一些属性，例如是否结束，是否为空以及队列所有乘客组成的集合(<code>ArrayList&lt;Passenger&gt;</code>)。</p>
<h4 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a><strong>调度器类</strong></h4><h5 id="Controller"><a href="#Controller" class="headerlink" title="Controller:"></a><code>Controller</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec46f8.png"></p>
<p>重写了<code>run()</code>方法将乘客分配。</p>
<p>分配策略：采取均匀分配的策略。按照乘客到来的时间先后顺序将总等候队列中的乘客均匀分配给电梯的等候队列。（<del>所以性能不好<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 600 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Missing superscript or subscript argument" title="Missing superscript or subscript argument"><rect data-background="true" width="600" height="950" y="-200"></rect><title>Missing superscript or subscript argument</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">_</text></g></g></g></g></svg></mjx-container></del>)</p>
<p>一个示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*结束条件*/</span>) {</span><br><span class="line">            <span class="comment">//将所有电梯等候队列设为结束//</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> waitQueue.getOnePassenger()<span class="comment">//按时间顺序取出//;</span></span><br><span class="line">        <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        elevatorQueues.get(<span class="comment">/*index*/</span>).addPassenger(passenger);<span class="comment">//分配</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="电梯类："><a href="#电梯类：" class="headerlink" title="电梯类："></a>电梯类：</h4><h5 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator:"></a><code>Elevator</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec47c9.png"></p>
<p> 重写了<code>run()</code>方法使电梯运行，总的模式是这样的：根据等候队列中的顺序，确定主请求然后将主请求的乘客送到目的地。在这个过程中分为接主请求乘客和送主请求乘客两部分，这两个过程中在未超载（主请求计算在内）且运行方向相同的情况下可进行捎带。在每一个主请求到达的时候将电梯内部先到的乘客确定为主请求，继续运行直至电梯内部为空，再从等候队列中取出乘客。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*结束条件*/</span>) {</span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> queue.getOnePassenger();<span class="comment">//queue(ArrayList&lt;Passenger&gt;)是该电梯的等候队列</span></span><br><span class="line">        <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//分两步：</span></span><br><span class="line">        <span class="comment">//1.将最早的乘客起始点设为主请求，接人</span></span><br><span class="line">        <span class="built_in">this</span>.setTarget(passenger.getFromFloor());</span><br><span class="line">        forward(passenger);</span><br><span class="line">        <span class="comment">//2.将该乘客目的地设为主请求，送人</span></span><br><span class="line">        <span class="built_in">this</span>.setTarget(passenger.getToFloor());</span><br><span class="line">        forward(passenger);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.list.isEmpty()) {</span><br><span class="line">            <span class="comment">//将剩下的乘客逐一运送</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>forward(Passenger p)</code>方法用于<strong>接</strong>或<strong>送</strong>乘客<code>p</code>，同时还需满足捎带：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(Passenger p)</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.nowFloor != <span class="built_in">this</span>.targetFloor) { <span class="comment">//捎带：方向一致，目标小于主目标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*捎带或中途下人条件是否成立*/</span>openOrNot()) {</span><br><span class="line">            <span class="comment">//开门、出人、进人、关门</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.move();<span class="comment">//移动一层</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//到达指定层</span></span><br><span class="line">    <span class="built_in">this</span>.open();</span><br><span class="line">    <span class="comment">//1.如果p在电梯内且到了目的地，先让p下电梯</span></span><br><span class="line">    <span class="comment">//2.如果捎带的乘客目的地也在此层，下电梯</span></span><br><span class="line">    <span class="comment">//3.如果p还没上电梯，先让p进电梯</span></span><br><span class="line">    <span class="comment">//4.根据剩余容量捎带此层满足条件的乘客</span></span><br><span class="line">    <span class="built_in">this</span>.close();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>in()</code>,<code>out()</code>,<code>open()</code>,<code>close()</code>,<code>arrive()</code>均需要输出指定内容，<code>addPassenger()</code>和<code>removePassenger()</code>是电梯内队列的增减乘客操作方法（这里的方法和前文的队列类不同，就是很简单的删减操作，因为每一个电梯内队列只会被当前电梯操作，无需考虑线程安全的问题），都很容易实现~</p>
<h4 id="线程之间的交互和总运行流程"><a href="#线程之间的交互和总运行流程" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>开始输入，官方接口接受输入，<code>Main</code>将每一个<code>Passenger</code>送到总等候队列<code>waitQueue</code>（相当于生产者消费者模型中的托盘），调度器是电梯和乘客之间的桥梁，按照某种方式将<code>waitQueue</code>中的乘客放入不同电梯的等候队列(注意不是电梯内部)。而此时电梯和等候队列的关系也正好对应了消费者和托盘的关系，不同的是，一个等候队列仅对应一个电梯，因此每个电梯只需考虑将自己的等候队列里乘客处理完毕，直至收到结束信号并且等候队列和电梯内均为空则结束线程。</p>
<h4 id="同步块与锁"><a href="#同步块与锁" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和普通的程序不同，多线程编程中要注意线程安全的问题。例如，如果两个线程同时对一个对象进行写的操作，很有可能出现冲突和异常。因此要保证该对象每次只被一个线程访问，可以在所有可能被多个对象同时访问的成员方法加上synchronized关键字，在方法末尾调用<code>notifyAll()</code>唤醒其他线程。锁和同步块中处理语句之间的关系是，当一个线程进入同步块时，它会自动获取同步块所关联的锁对象，当它退出同步块时，它会自动释放锁对象，这样可以保证同步块中的处理语句不会被其他线程干扰。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removePassenger</span><span class="params">(Passenger p)</span> {</span><br><span class="line">    <span class="comment">//Your Method</span></span><br><span class="line">    notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5b1ddac507ccec498a.png"></p>
<h4 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次作业的中测在<del>写调度器之前</del>频繁超时，加上调度器之后就没有bug了。</p>
<p>强测和互测各出现了一个不能稳定复现的超时bug，大概率是高频发时会引发某些问题，导致乘客没进或没出以至于程序无法终止。检查代码的时候我发现在捎带乘客那一部分实际设定的电梯容量是5（@_@)，改正之后居然就能够解决了。</p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第一次作业基础上需要增加这些工作：</p>
<ol>
<li>将<strong>电梯</strong>类的属性变量添加到构造方法中以满足个性化添加电梯，并在具体实现中将常量替换为该电梯的属性</li>
<li>在<strong>队列</strong>类中新增和<code>maintain</code>有关的方法和变量以满足维修的需求</li>
<li>在<strong>电梯</strong>类的运行方法中新增判断是否<code>maintain</code>的方法以及处理措施的方法</li>
<li>修改线程结束的条件(<code>waitQueue</code>的输入来源不止一个main了，还有维修的电梯)</li>
</ol>
<h4 id="队列类-1"><a href="#队列类-1" class="headerlink" title="队列类"></a>队列类</h4><h5 id="PassengerQueue-1"><a href="#PassengerQueue-1" class="headerlink" title="PassengerQueue:"></a><code>PassengerQueue</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec604a.png"></p>
<p>增加了<code>setMaintainSymbol(int)</code>， <code>isMaintained()</code>和<code>addMaintainList(ArrayList&lt;PersonRequest)</code>三个方法。其中<code>setMaintainSymbol(int)</code>和<code>isMaintained()</code>分别用于设定维修标志和判断维修标志,<code>addMaintainList()</code>将参数<code>ArrayList&lt;PersonRequest&gt; list</code>全部加入到此对象的<code>List</code>中，可以适应将与维修电梯相关人员加入到<code>waitQueue</code>的操作。</p>
<h4 id="调度器类-1"><a href="#调度器类-1" class="headerlink" title="调度器类"></a>调度器类</h4><h5 id="Distribute"><a href="#Distribute" class="headerlink" title="Distribute:"></a><code>Distribute</code>:</h5><p><del>对的，不是打错了，是改名了</del></p>
<p>由于电梯也能将<code>waitQueue</code>加入乘客，因此需要修改调度器的结束条件：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!waitQueue.isEmpty()) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Your Method</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对比一下之前的：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Your Method</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其实仅仅时增加了中间一部分，因为考虑到maintain这个过程是需要时间的，如果仅仅在<code>waitQueue</code>为空时结束，那么一些收到maintain信号的电梯可能没来得及放出乘客，此时关闭调度器可能会使这些乘客无法参与分配从而永远到达不了目的地<del>_</del></p>
<p>所以我在满足原结束条件的情况下使调度器休眠固定时间，这也是由于课程组要求两层<code>arrive</code>以内必须完成<code>maintain</code>的操作，因此这个时间不会太难控制。如果休眠之后仍满足该条件，则结束。</p>
<p>第二次作业的调度策略与第一次作业的差别不大，此处不再赘述。</p>
<h4 id="电梯类"><a href="#电梯类" class="headerlink" title="电梯类"></a>电梯类</h4><h5 id="Elevator-1"><a href="#Elevator-1" class="headerlink" title="Elevator:"></a><code>Elevator</code>:</h5><p>在第一次作业上新增了一个方法：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff5a1ddac507ccec4773.png"></p>
<p>用于处理维修请求，一个示例（删去了很多细节代码，仅供参考）：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dealMaintain</span><span class="params">(PersonRequest p)</span> {</span><br><span class="line">    ArrayList&lt;PersonRequest&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*p不在电梯中*/</span>) {</span><br><span class="line">       waitQueue.add(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (PersonRequest person : arr) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*乘客未到达*/</span>) {</span><br><span class="line">            <span class="comment">//修改person的属性fromFloor为当前楼层</span></span><br><span class="line">            person.setFromFloor(nowFloor);</span><br><span class="line">            waitQueue.add(person);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.out(person);</span><br><span class="line">    }</span><br><span class="line">    waitQueue.addAll(<span class="built_in">this</span>.queue.getList());<span class="comment">//别忘了等候队列的可怜人:)</span></span><br><span class="line">    <span class="built_in">this</span>.maintainFlag = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>同时在其他方法比如<code>forward()</code>和<code>run()</code>中增加新内容以适应维修的需求：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">this</span>.nowFloor != <span class="built_in">this</span>.targetFloor) { </span><br><span class="line">           <span class="comment">//需要在正常上下客之前判断maintain</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.queue.isMaintained()) {</span><br><span class="line">               <span class="built_in">this</span>.dealMaintain(p);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">//Originated Method</span></span><br><span class="line">       }   </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">           ......</span><br><span class="line">           <span class="keyword">if</span> (<span class="comment">/*维护条件*/</span>) {</span><br><span class="line">               <span class="comment">/*输出维护信号*/</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           }</span><br><span class="line">           ......</span><br><span class="line">           forward(passenger);</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.maintainFlag == <span class="number">1</span>) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">while</span> (<span class="comment">/*电梯非空*/</span>) {</span><br><span class="line">               ......</span><br><span class="line">               forward(passenger);</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">this</span>.maintainFlag == <span class="number">1</span>) {</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></table></figure></div>

<p>总体还是通过改变<code>maintainFlag</code>来实现的。</p>
<h4 id="线程之间的交互和总运行流程-1"><a href="#线程之间的交互和总运行流程-1" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>总体结构变化不大，与第一次作业的区别：</p>
<ul>
<li>调度器并不会在标准输入结束之后结束，而是还要确定所有维护电梯均被维护才能结束</li>
<li>电梯线程可能会因为维护而提前结束，通过设定对应的等候队列的<code>maintainSymbol</code>，然后将其从<code>elevatorQueues</code>中<code>remove</code>可以切断调度器与之的联系，不会再给此电梯分配乘客，接着每个电梯根据是否收到此<code>maintainSymbol</code>来进行相应操作</li>
</ul>
<h4 id="同步块与锁-1"><a href="#同步块与锁-1" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和第一次作业区别不大。</p>
<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p>第二次作业使用了官方的<code>PersonRequest</code>类，因此比第一次作业少一个类，区别不大。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff601ddac507ccec5343.png"></p>
<h4 id="bug分析-1"><a href="#bug分析-1" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次作业应该是这个单元最折磨的一次了，因为我的代码出现了大面积CPU超时的问题，中测甚至提交了9次才通过:(</p>
<p>那一次周六对着电脑看了一天都没看出来问题，看到晚上晚上几近崩溃。每一次提交得到的10个CPU超时真的很揪心……</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff591ddac507ccec467b.png"></p>
<p>求助了助教还有很多同学，最终发现了问题的所在：</p>
<p>我一开始并没有让调度器在所有维修电梯完成且分配完成之后休眠，而是一直等到了所有乘客离开整个系统。</p>
<blockquote>
<p>程序的输入输出为<strong>实时交互</strong>，评测机可以做到在某个时间点投放一定量的输入</p>
</blockquote>
<p>也就是说输入结束的时间应该是最后一条指令实际被接受到的时刻附近。而正是这样，我觉得<code>setEnd</code>（我的理解偏差，这个时候我认为输入结束是指将数据复制到终端然后按下回车的时刻）之后调度器还必须等待最后一条指令，因为最后一条指令也可能会将<code>waitqueue</code>中添加乘客。所以就有了下面的大量无意义循环：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Distribute.java:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEnd()) {</span><br><span class="line">                <span class="keyword">for</span> (PassengerQueue elevatorQueue : elevatorQueues) {</span><br><span class="line">                    elevatorQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd() &amp;&amp; table.isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> waitQueue.getOnePassenger();<span class="comment">//每次出来的结果都是null</span></span><br><span class="line">            <span class="keyword">if</span> (passenger == <span class="literal">null</span>) {                          </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            .....</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PassengerQueue.java:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> Passenger <span class="title function_">getOnePassenger</span><span class="params">()</span> { <span class="comment">//按时间先后取出(先来后到)</span></span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; !<span class="built_in">this</span>.isEnd()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            ......</span><br><span class="line">    	}</span><br></pre></td></tr></table></figure></div>

<p>已经将<code>waitQueue</code>设定<code>setEnd()</code>，每次在<code>getOnePassenger</code>中的第一个if会直接跳过，而此时<code>queue</code>又确实为空会返回<code>null</code>。但整个系统还有乘客（<code>!table.isEmpty</code>），这样会进入大量循环返回<code>null</code>然后不断<code>continue</code>，占用大量的<code>CPU</code>资源导致超时。解决方法很容易，只要能理解到输入结束的时间就很好改了，正确的结束方式已经在前文的第二次作业总结-&gt;调度器类中解释了。</p>
<p>强测中出现了很多捎带的问题，发现漏掉了捎带的条件。</p>
<h5 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h5><p>使用了很多检查CPU时间的工具，都没能起到实质性的作用，不如直接在循环里<code>print(something)</code>，如果某个方法打印输出的东西达到了几十万行，就很好定位了：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//System.out.println("**********distributeI");</span></span><br><span class="line">        <span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.isEmpty()) {</span><br><span class="line">            ......</span><br><span class="line">        }</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//System.out.println("**********distributeO");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>不断将两条语句向中间靠近，找到循环最多的一个分支，就很容易发现问题了。</p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第二次作业基础上，需要新增这些内容：</p>
<ol>
<li>对每层楼可开门的数量加以限制</li>
<li>考虑到部分电梯的可达性，需要在分配乘客之前确定路径</li>
</ol>
<p>为了解决上述问题，我新增了一个<code>StateMap</code>类并提供诸多方法用于解决新的问题。</p>
<h4 id="个性化需求类"><a href="#个性化需求类" class="headerlink" title="个性化需求类"></a>个性化需求类</h4><h5 id="StateMap"><a href="#StateMap" class="headerlink" title="StateMap:"></a><code>StateMap</code>:</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff6f1ddac507ccec6bfe.png"></p>
<p>对于限制开门数量的要求，可以这样实现：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff681ddac507ccec6068.png"></p>
<p><code>serviceMap</code>的<code>value</code>对应了每层楼服务中的电梯数量，<code>key</code>指示楼层，因此初始时每层楼服务数量都是0。</p>
<p>开门时，直接调用<code>addService()</code>，由于<code>synchronized</code>的存在，每次只会有一个电梯访问该方法，若数量大于规定数量，则等待，直至该楼层服务中电梯数量小于规定数量，被唤醒，然后该楼层服务中电梯数量加1：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.serviceMap.get(floor) &gt;= <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    serviceMap.put(floor, serviceMap.get(floor) + <span class="number">1</span>);</span><br><span class="line">    notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>关门则直接调用<code>removeService()</code>:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeService</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">    serviceMap.put(floor, serviceMap.get(floor) - <span class="number">1</span>);</span><br><span class="line">    notifyAll();</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></div>

<p>对于只接人的电梯数量则跟上述方法类似，只不过需要新增方法来判断该电梯是否为只接人的。</p>
<p>为了解决路径问题，我定义了两个HashMap：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff671ddac507ccec5f6d.png"></p>
<p><code>accessMap</code>指示每个电梯可以直达的楼层，<code>pathMap</code>指示每层楼可以直达的楼层（类似于邻接矩阵）。</p>
<p>通过<code>findPath(Passenger p)</code>方法返回一个<code>LinkedList&lt;Integer&gt;</code>类型的需求队列，队列头部是该乘客下一个目的地，队列尾部是乘客的最终目的地。</p>
<h4 id="调度器类-2"><a href="#调度器类-2" class="headerlink" title="调度器类"></a>调度器类</h4><h5 id="Distribute："><a href="#Distribute：" class="headerlink" title="Distribute："></a><code>Distribute</code>：</h5><p>在调度的时候需要考虑乘客的当前需求楼层和所在楼层对于该电梯是可达的，在此基础上均匀分配：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; demand = stateMap.findPath(passenger);</span><br><span class="line">passenger.updateDemand(demand);</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    i = (i + <span class="number">1</span>) % elevatorQueues.size();</span><br><span class="line">} <span class="keyword">while</span> (!(<span class="comment">/*乘客的当前需求楼层和所在楼层对于该电梯是可达的*/</span>));</span><br><span class="line">elevatorQueues.get(i).addPassenger(passenger);</span><br></pre></td></tr></table></figure></div>

<h4 id="电梯类-1"><a href="#电梯类-1" class="headerlink" title="电梯类"></a>电梯类</h4><h5 id="Elevetor"><a href="#Elevetor" class="headerlink" title="Elevetor:"></a><code>Elevetor</code>:</h5><p>需要在开门前，关门后对<code>stateMap</code>做处理，如果数量不满足条件则会<code>wait()</code>直至被唤醒：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*判断只接人的方法*/</span>) {</span><br><span class="line">  	<span class="built_in">this</span>.stateMap.addOnly(nowFloor);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">this</span>.stateMap.addService(nowFloor);</span><br><span class="line">open();</span><br></pre></td></tr></table></figure></div>

<p>还需要把原来<code>passenger.getToFloor()</code>替换为<code>passenger.getDemand()</code>。因为现在乘客的总需求被拆分为多个子请求，我们在得到路径之后需要逐一处理子请求，<code>getDemand()</code>就是取出队列头部元素：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDemand</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.demand.getFirst();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="线程之间的交互和总运行流程-2"><a href="#线程之间的交互和总运行流程-2" class="headerlink" title="线程之间的交互和总运行流程"></a>线程之间的交互和总运行流程</h4><p>总的结构区别不大，与第二次作业的区别：</p>
<ul>
<li>开关门时需要有额外的判断条件，新增<code>stateMap</code>类解决</li>
<li>对于换乘，我们在每次乘客进入<code>waitQueue</code>时更新<code>demand</code>队列，每次取出头部元素作为当前主请求，每次下电梯时判断是否为终点，再选择是否重新进入<code>waitQueue</code></li>
</ul>
<h4 id="同步块与锁-2"><a href="#同步块与锁-2" class="headerlink" title="同步块与锁"></a>同步块与锁</h4><p>和第一次作业区别不大。仅在新类<code>stateMap</code>中对应的添加删除对应楼层元素的方法中使用了synchronized关键字。</p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff671ddac507ccec5f30.png"></p>
<h4 id="bug分析-2"><a href="#bug分析-2" class="headerlink" title="bug分析"></a>bug分析</h4><p>本次中测未测出bug，但是在使用评测机自行测试的时候发现了这样一个问题：即使设定了<code>addService</code>这样的方法但是还是会出现同一层服务电梯数量超过的情况，后来想清楚了：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前的方法:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(<span class="type">int</span> floor)</span> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.serviceMap.get(floor) &gt;= <span class="number">4</span>) {</span><br><span class="line">       <span class="comment">//Your Method(wait......)</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//Your Method</span></span><br><span class="line">	notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在这里要注意到<code>serviceMap</code>是一个<code>HashMap</code>类型，所有楼层的信息全部存储在这里。假如5楼开门的电梯已经达到最大数量，其他准备在5楼开门的电梯就会等待。但是要注意其他楼层的开关门操作也会改变该HashMap，但不一定改变此层楼对应的键值，这样5层不该开门的电梯有可能被错误地唤醒。修改方法很容易，把<code>if</code>改成<code>while</code>就行了，加一次判断即可。</p>
<h5 id="debug方法-1"><a href="#debug方法-1" class="headerlink" title="debug方法"></a>debug方法</h5><p>先用评测机评测随机数据，如果出现错误，先根据错误信息定位错误区间，确定出问题的方法。</p>
<p>强测出现了一个不能稳定复现的bug，在本地跑了好多遍都没有什么问题，官方给出的解释信息是real_time_limit_exceed，出现的异常信息：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Exception</span> <span class="keyword">in</span> thread <span class="string">"Thread-6"</span> java.<span class="property">lang</span>.<span class="property">NullPointerException</span></span><br><span class="line">    at <span class="title class_">StateMap</span>.<span class="title function_">findPath</span>(<span class="title class_">StateMap</span>.<span class="property">java</span>:<span class="number">100</span>)</span><br><span class="line">    at <span class="title class_">Distribute</span>.<span class="title function_">run</span>(<span class="title class_">Distribute</span>.<span class="property">java</span>:<span class="number">32</span>)</span><br></pre></td></tr></table></figure></div>

<p>检查了这个方法，不能够确定是否是没有加锁导致的。加锁之后，交上去，过了。但是在代码中只有一个线程能够访问此方法，所以很疑惑，感觉也不一定是线程安全的问题。</p>
<h2 id="三次作业总结"><a href="#三次作业总结" class="headerlink" title="三次作业总结"></a>三次作业总结</h2><h4 id="UML协作图"><a href="#UML协作图" class="headerlink" title="UML协作图"></a>UML协作图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648eff6f1ddac507ccec6c2d.png"></p>
<h4 id="分析内容"><a href="#分析内容" class="headerlink" title="分析内容"></a>分析内容</h4><p>稳定的内容：其实也就是第一次作业的内容，运送乘客，电梯开关门上下行。调度器线程从<code>waitQueue</code>中把乘客送给电梯的等候队列，电梯线程从等候队列中接人，捎带，运送乘客。</p>
<p>易变的内容：加入了维修需求之后，<code>waitQueue</code>接受的输入不止有标准输入了，还有电梯线程。自定义需求（容量，操作时间）使得电梯线程中的时间操作，输出操作需要做出相应更改。可达性需求出现后，调度器分配时要考虑乘客当前和需求楼层均可达，电梯开关门和捎带也必须考虑这两点。限制开门数量的需求出现后，在原来开关门的基础上需要额外增加条件。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全问题在多线程编程中非常重要。由于存在多个线程同时共享一个资源的情况，我们需要严格控制能够访问这一资源的数量。方法就是加锁。本次作业中我只使用了<code>synchronized</code>这一种锁<del>（其实也只会这一种）</del>，在每个方法之前加上synchronized关键字，在方法最末尾<code>notifyAll</code>唤醒其他可能正在等待访问此资源的线程。</p>
<h4 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h4><p>本单元的作业进一步加深了我对层次化设计的理解。使用生产者消费者模式可以很容易地理解每一个类扮演的角色是什么。如果是生产者，那么这个类里完成所有分配商品（乘客）到传送带（<code>waitQueue</code>）的工作，如果是消费者，只需要完成取出商品的工作即可。这样每个类能够仅考虑自己的工作，一定程度上吻合了“高内聚，低耦合”的思想，同时层次更加清晰，易于理解<del>（更容易找bug）</del>。</p>
<h4 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h4><p>本单元真的是收获颇丰的一单元，从对多线程的一无所知到能够编写出这样多功能的多线程协作电梯调度程序，已经是一件非常有成就感的事。在这个过程中，我主要有这样几点认识：</p>
<ul>
<li>寻找问题比解决问题重要得多。这是本单元第二次作业给我的教训。在没有真正发现问题之前修改一些自认为可能的bug，非常浪费时间浪费精力。<blockquote><p>The difficulty is not in finding a subject to talk about, but in discovering a subject that will reveal something in your own nature.</p>
<footer><strong>Charles Dickens</strong><cite>David Copperfield</cite></footer></blockquote></li>
<li>协作与合作的重要性。在这之前，每次的作业基本都是自己慢慢琢磨出来的。但是这单元的第二次作业我请教了大量的同学，问了很多的高年级同学，最终才发现了这个问题。没有这么多人的帮助我不可能完成这一次作业。</li>
</ul>
<p>感谢这么多同学的热心帮助^_^，希望在这条路上能够取得更大的收获。</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary of Object-Oriented Design and Construction Unit 3</title>
    <url>/2023/05/19/Summary%20of%20Object-Oriented%20Design%20and%20Construction%20Unit%203/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>第三单元作业的训练目标是<strong>掌握JML规格的理解与实现</strong>，三次作业为迭代开发。</p>
<p>需要完成的任务为实现简单社交关系的模拟和查询（第一次作业），实现社交关系模拟系统中的群组和消息功能（第二次作业）和实现社交关系系统中不同消息类型以及相关操作（第三次作业）。</p>
<p>点击此处可以参考我的代码：<a class="link" href="https://github.com/LeostarR/Object-oriented-Design-and-Construction">https://github.com/LeostarR/Object-oriented-Design-and-Construction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="第一次作业总结"><a href="#第一次作业总结" class="headerlink" title="第一次作业总结"></a>第一次作业总结</h2><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>本次作业需要完成这些工作：</p>
<ol>
<li>根据官方接口和JML实现<code>MyPerson</code>类和<code>MyNetwork</code>类</li>
<li>继承官方提供的各抽象异常类，实现四个异常类</li>
<li>为<code>Network</code>类中的<code>query_triple_sum</code>方法书写OK测试</li>
</ol>
<h4 id="MyPerson"><a href="#MyPerson" class="headerlink" title="MyPerson"></a><code>MyPerson</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7bfb3.png"></p>
<p> <code>id</code>, <code>name</code>, <code>age</code>, <code>acquaintance</code>和<code>value</code>是该类的五个属性，接口要求为其中三个属性提供访问方法。<code>isLinked</code>用于判断两者是否有社交关系，<code>queryValue</code>用于查询社交值（如果有），<code>addPerson</code>和<code>addValue</code>用于添加社交关系。由于社交关系是动态变化的，因此我在设计的时候将acquaintance和value两个属性都定义为了<code>ArrayList</code>的结构，便于实现动态管理。</p>
<h4 id="MyNetwork"><a href="#MyNetwork" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06191ddac507ccf78e43.png"></p>
<p> <code>people</code>为按照接口要求实现的变量。<code>contains</code>方法判断社交网络中是否包含此人，<code>addPerson</code>和<code>addRelation</code>分别用于添加人和关系，<code>queryValue</code>用于查询两人之间的社交值（如果有），<code>isCircle</code>判断两人是否相连（通过与其他人的关系）。<code>queryBlockSum</code>用于查询最大连通分支的数目，<code>queryTripleSum</code>用于查询三元环的数目。<code>queryTripleSumOKTest</code>是一个对<code>queryTripleSum</code>方法进行OK测试的方法。</p>
<h4 id="Exception："><a href="#Exception：" class="headerlink" title="Exception："></a>Exception：</h4><h5 id="MyEqualPersonIdException"><a href="#MyEqualPersonIdException" class="headerlink" title="MyEqualPersonIdException"></a><code>MyEqualPersonIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06101ddac507ccf77f58.png"></p>
<h5 id="MyEqualRelationException"><a href="#MyEqualRelationException" class="headerlink" title="MyEqualRelationException"></a><code>MyEqualRelationException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06101ddac507ccf77f72.png"></p>
<h5 id="MyPersonIdNotFoundException"><a href="#MyPersonIdNotFoundException" class="headerlink" title="MyPersonIdNotFoundException"></a><code>MyPersonIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c016.png"></p>
<h5 id="MyRelationNotFoundException"><a href="#MyRelationNotFoundException" class="headerlink" title="MyRelationNotFoundException"></a><code>MyRelationNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c0f7.png"></p>
<p> 四种异常类的实现方法大同小异：定义静态变量sum，每次throw时将sum加1，同时定义静态HashMap存储每个id发生的异常次数。</p>
<h4 id="设计细节与bug分析"><a href="#设计细节与bug分析" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 如果完全按照JML的字面意思来实现的话，本次作业就是完完全全的照葫芦画瓢，没有任何难度。我们发现<code>isCircle</code>如果采用图遍历的方式每次调用时查找，CPU运行时间会大大增加，同样对于<code>queryTripleSum</code>。</p>
<p>因此本次作业采用并查集来解决CPU运行时间过长的问题：定义<code>HashMap&lt;Integer, Integer&gt; symbol = new HashMap&lt;&gt;()</code>指示每个节点对应的并查集，初始（添加这个人）时该集合设定为自己。每次调用<code>isCircle</code>时会调用<code>find()</code>方法判断两者是否同属一个并查集。而<code>find()</code>方法会递归地寻找从这个点到根节点的所有节点，并将这些节点的并查集全部更新：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*key的并查集不是自己*/</span>) {</span><br><span class="line">        symbol.put(key, find(symbol.get(key)));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*查找之后得到的并查集*/</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>而在每次<code>addRelation()</code>时，我们会调用<code>merge()</code>将两节点合并到同一个并查集中：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> <span class="comment">/*id1的并查集*/</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> <span class="comment">/*id2的并查集*/</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 != root2) {</span><br><span class="line">        symbol.put(root1, root2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这样就完成了对<code>isCircle()</code>的优化。</p>
<p> 同样对于<code>queryBlockSum</code>和<code>queryTripleSum</code>的方法也可以利用上述的方法：设定全局变量<code>globalQts</code>和<code>globalQbs</code>。每次<code>addPerson</code>时需要将连通分支数目加一，在<code>addRelation</code>中<code>merge</code>之前判断两人是否同属一个并查集，若不是，则将连通分支数目减一。而三元环的数目只需每次<code>addRelation</code>之后判断有多少个点同时与这两点相连即可。</p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06061ddac507ccf76df8.png"></p>
<h2 id="第二次作业总结"><a href="#第二次作业总结" class="headerlink" title="第二次作业总结"></a>第二次作业总结</h2><h3 id="设计与架构-1"><a href="#设计与架构-1" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第一次作业基础上需要增加这些工作：</p>
<ol>
<li>按照官方接口的JML实现<code>Group</code>类和<code>Message</code>类，并完善<code>Network</code>类中的更多方法</li>
<li>实现更多的异常类</li>
<li>为<code>Network</code>类中的<code>modifyRelation</code>方法书写OK测试</li>
</ol>
<h4 id="MyGroup"><a href="#MyGroup" class="headerlink" title="MyGroup"></a><code>MyGroup</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf77ff8.png"></p>
<p> 此类用于模拟社交群组，<code>id</code>为组id，<code>people: ArrayList&lt;Person&gt;</code>为组中人的集合，<code>addPerson</code>和<code>delPerson</code>用于向组中加入和删除成员，<code>hasPerson</code>用于判断组中是否存在某个成员，<code>getValueSum</code>，<code>getAgeMean</code>，<code>getAgeVar</code>用于计算整个组和成员年龄相关的值，<code>getSize</code>返回成员总数。</p>
<h4 id="MyMessage"><a href="#MyMessage" class="headerlink" title="MyMessage"></a><code>MyMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf78093.png"></p>
<p> 此类定义了五个成员属性：<code>id</code>, <code>socialValue</code>, <code>type</code>, <code>person1</code>, <code>person2</code>, <code>group</code>，并分别配置了访问方法。</p>
<h4 id="MyNetwork-1"><a href="#MyNetwork-1" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf78f2b.png"></p>
<p>相比第一次作业，此类新增了更多方法。<code>modifyRelation</code>用于调整两个人之间的关系，可以是改变社交值，也可以是删除关系，此外还需要为该方法编写OK测试方法。<code>addGroup</code>用于添加组，<code>addToGroup</code>用于将人添加到指定组中，<code>delFromGroup</code>则是将人从指定组中删去。<code>queryGroupValueSum</code>和<code>queryGroupAgeVar</code>用于返回组群中特定含义的数。<code>addMessage</code>，<code>getMessage</code>和<code>sendMessage</code>分别用于添加消息，接受消息和发送消息。<code>queryBestAcquaintance</code>用于查询对应id的有关系的人中社交值最高并且id更小的一个id。<code>queryCoupleSum</code>用于查询两个id互为对方的<code>BestAcquaintance</code>的对数。</p>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><h5 id="MyAcquaintanceNotFoundException"><a href="#MyAcquaintanceNotFoundException" class="headerlink" title="MyAcquaintanceNotFoundException"></a><code>MyAcquaintanceNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77296.png"></p>
<h5 id="MyEqualGroupIdException"><a href="#MyEqualGroupIdException" class="headerlink" title="MyEqualGroupIdException"></a><code>MyEqualGroupIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf970c9.png"></p>
<h5 id="MyEqualMessageIdException"><a href="#MyEqualMessageIdException" class="headerlink" title="MyEqualMessageIdException"></a><code>MyEqualMessageIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf970f7.png"></p>
<h5 id="MyGroupIdNotFoundException"><a href="#MyGroupIdNotFoundException" class="headerlink" title="MyGroupIdNotFoundException"></a><code>MyGroupIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06111ddac507ccf78015.png"></p>
<h5 id="MyMessageIdNotFoundException"><a href="#MyMessageIdNotFoundException" class="headerlink" title="MyMessageIdNotFoundException"></a><code>MyMessageIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06191ddac507ccf78dc1.png"></p>
<p> 新的异常类和第一次作业设计相同，不再赘述。</p>
<h4 id="设计细节与bug分析-1"><a href="#设计细节与bug分析-1" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 有了第一次作业的经验，我们知道，某些JML表面意思为做大量循环的方法要考虑直接循环的代价。所以可以考虑实现动态变化，在所有可能改变这个值的方法里修改这个值，在真正需要这个值的时候直接调用即可。例如<code>queryValueSum</code>，用于计算群组中所有的人和其他有关系的人的value之和，只有这些地方需要修改<code>valueSum</code>：<code>addRelation</code>之后，<code>modifyRelation</code>之后。</p>
<p> 但对于<code>ageMean</code>和<code>ageVar</code>两个与群组人数相关的变量，每次增加人数都不能确定改变的大小，因此必须在改变人数之后进行计算，这里可以设置标记，若没有增加或删除人，则可以返回上一次的计算结果，以达到提高效率的目的。</p>
<p> 对于<code>queryBestAcquaintance</code>，我们直接返回对应person中的一个变量，这个变量也是动态变化的。具体来说，每一次<code>addRelation</code>和<code>modifyRelation</code>时我们都要考虑这个变量，添加关系时，判断该<code>value</code>是否大于原<code>maxValue</code>，修改value时考虑是否会超过原<code>maxValue</code>，或者原value就是<code>maxValue</code>，以及删除关系时考虑最大值被删除等等（情况比较多，我在这里没有完全考虑清楚导致强测出现了很严重的bug）。</p>
<p> <code>queryCoupleSum</code>实际上依赖于<code>queryBestAcquaintance</code>(所以这里也寄了)，由上文知道，<code>BestAcquaintance</code>只会在<code>addRelation</code>和<code>modifyRelation</code>之后发生变化，并且只会针对两个点，我们只需在此时新建一个方法，这个方法可以计算两个点涉及的<code>coupleSum</code>数目（最小为0，最大为2），在改变关系前后分别调用，再相减就能得到经过这次改变<code>CoupleSum</code>应该变化的大小。</p>
<p> 同时，我们第一次作业中对于并查集的部分也因为增加了删边的新功能而必须修改。在这种情况下，我们必须保证每一次存入<code>HashMap</code>中的(id1-&gt;id2)按顺序排列，否则可能会出现因删边导致异常的情形。新增<code>disconnect</code>方法用于删除两节点的关系并且重新构造：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.min(id1, id2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.max(id1, id2);</span><br><span class="line">    pairs.remove(i1);</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry&lt;Integer, Integer&gt; entry : symbol.entrySet()) {</span><br><span class="line">        entry.setValue(entry.getKey());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry&lt;Integer, Integer&gt; entry : pairs.entrySet()) {</span><br><span class="line">        merge(entry.getKey(), entry.getValue());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06071ddac507ccf76e7b.png"></p>
<h2 id="第三次作业总结"><a href="#第三次作业总结" class="headerlink" title="第三次作业总结"></a>第三次作业总结</h2><h3 id="设计与架构-2"><a href="#设计与架构-2" class="headerlink" title="设计与架构"></a>设计与架构</h3><p>在第二次作业基础上，需要新增这些内容：</p>
<ol>
<li>根据官方接口的JML实现<code>MyEmojiMessage</code>，<code>MyNoticeMessage</code>和<code>MyRedEnvelopeMessage</code>三个类，并完善<code>MyNetwork</code>类</li>
<li>新增三个异常类</li>
<li>对<code>deleteColdEmoji</code>编写OK测试方法</li>
</ol>
<h4 id="MyEmojiMessage"><a href="#MyEmojiMessage" class="headerlink" title="MyEmojiMessage"></a><code>MyEmojiMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf97046.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>emojiId</code>字段和对应的访问方法。</p>
<h4 id="MyNoticeMessage"><a href="#MyNoticeMessage" class="headerlink" title="MyNoticeMessage"></a><code>MyNoticeMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf790af.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>string</code>字段和对应的访问方法。</p>
<h4 id="MyRedEnvelopeMessage"><a href="#MyRedEnvelopeMessage" class="headerlink" title="MyRedEnvelopeMessage"></a><code>MyRedEnvelopeMessage</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7c09c.png"></p>
<p>相比<code>MyMessage</code>类，新增了<code>money</code>字段和对应的访问方法。</p>
<h4 id="MyNetwork-2"><a href="#MyNetwork-2" class="headerlink" title="MyNetwork"></a><code>MyNetwork</code></h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f061a1ddac507ccf79047.png"></p>
<p> 需要新实现的方法有<code>containsEmojiId()</code>(查找表情是否存在)，<code>storeEmojiId()</code>（添加表情）,<code>queryMoney()</code>（查询money字段）, <code>queryPopularity()</code>（查询popularity字段）, <code>deleteColdEmoji()</code>（删除heat值小于limit的表情）, <code>clearNotice()</code>(清除通知）,<code>queryLeatMoments()</code>（查找最短自环）。并要求对原<code>sendMessage</code>方法进行完善。</p>
<h4 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h4><h5 id="MyEmojiIdNotFoundException"><a href="#MyEmojiIdNotFoundException" class="headerlink" title="MyEmojiIdNotFoundException"></a><code>MyEmojiIdNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07351ddac507ccf97012.png"></p>
<h5 id="MyEqualEmojiIdException"><a href="#MyEqualEmojiIdException" class="headerlink" title="MyEqualEmojiIdException"></a><code>MyEqualEmojiIdException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f07361ddac507ccf97083.png"></p>
<h5 id="MyPathNotFoundException"><a href="#MyPathNotFoundException" class="headerlink" title="MyPathNotFoundException"></a><code>MyPathNotFoundException</code></h5><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06361ddac507ccf7beb6.png"></p>
<p>新的异常类与之前实现完全相同，不再赘述。</p>
<h4 id="设计细节与bug分析-2"><a href="#设计细节与bug分析-2" class="headerlink" title="设计细节与bug分析"></a>设计细节与bug分析</h4><p> 第三次作业对算法的要求极高，在查找最小环的过程需要通过枚举非树边和<code>djikstra</code>算法结合查找每一个点的最小环，同时必须按照优先队列的方式枚举以达到减小循环次数的目的。</p>
<p> 此外，笔者因为第一次作业的遗留问题在互测中被多次hack@_@（很奇怪居然前两次测试都没有测出来）。例如在将某个人的acquaintance为空时添加与自己本身的关系时，应该抛出异常的却没有抛出异常，再根据JML仔细查看发现了问题：判断<code>isLinked()</code>的方法前面一个括号包含了循环，后面的<code>id != person.getId()</code>并不包含在括号中。如果我把判断id和<code>person.getId()</code>放在循环中，但是此时person的acquaintance为空，因此不会进入循环也就不会返回<code>true</code>（以及第二次作业的<code>ageVar</code>和<code>ageMean</code>出现问题也是因为JML括号的识别问题）。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77255.png"></p>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://pic.imgdb.cn/item/648f06091ddac507ccf77201.png"></p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h5 id="对黑箱测试、白箱测试的理解"><a href="#对黑箱测试、白箱测试的理解" class="headerlink" title="对黑箱测试、白箱测试的理解"></a>对黑箱测试、白箱测试的理解</h5><p>黑箱测试是基于软件的功能和需求进行测试，而不考虑内部的实现细节和结构。测试人员对软件系统进行测试时，只关注输入和输出之间的关系，测试软件的功能是否符合预期。黑箱测试的目标是发现系统的功能缺陷、界面错误、性能问题等，而不关注代码的具体实现。</p>
<p>白箱测试是基于软件的内部结构和实现细节进行测试。测试人员具有对源代码的访问权限，可以深入了解软件的内部逻辑和数据流。白箱测试的目标是验证软件的内部逻辑是否正确、代码是否符合编码标准、是否存在潜在的错误和安全漏洞等。</p>
<h5 id="对单元测试、功能测试、集成测试、压力测试、回归测试的理解"><a href="#对单元测试、功能测试、集成测试、压力测试、回归测试的理解" class="headerlink" title="对单元测试、功能测试、集成测试、压力测试、回归测试的理解"></a>对单元测试、功能测试、集成测试、压力测试、回归测试的理解</h5><ul>
<li>单元测试是对软件中最小的可测试单元进行验证的过程。单元可以是函数、方法或类等独立的代码块。单元测试的目标是在尽可能独立的环境中对单元进行测试，以确保其功能的正确性。</li>
<li>功能测试是对软件的功能进行验证的测试类型。它涉及对软件的各个功能模块和组件进行测试，以确认其是否按照需求规格说明书或用户期望的方式正常工作。功能测试通常以用户的角度来进行，通过模拟真实用户的操作来检查软件的功能是否符合预期。</li>
<li>集成测试是在多个独立的软件模块或组件之间进行测试，以验证它们的协同工作和接口的正确性。集成测试的目标是发现模块之间的集成问题、接口错误、数据传递问题等。它可以确保各个模块在集成后能够正常工作，并且相互之间没有冲突或不一致。</li>
<li>压力测试是对软件系统在正常或超出正常工作负载条件下进行测试的过程。其目的是评估系统的性能、稳定性和可靠性，以确定在负载增加的情况下系统的响应是否满足需求。压力测试通过模拟高并发、大数据量或异常负载情况来测试系统的极限情况。</li>
<li>回归测试是在软件进行更改或修复后，重新执行既有的测试用例，以确保新的修改没有引入新的错误或破坏了原有的功能。回归测试的目标是验证软件在经过修改后仍然具有稳定性和兼容性，不会对现有功能产生负面影响。</li>
</ul>
<h5 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h5><ol>
<li>正常值：选择符合程序预期输入的正常值作为测试数据。这些值应涵盖程序的各种功能和逻辑情况，包括边界值、典型值和一般情况。</li>
<li>边界值：选择接近边界条件的测试数据。边界值通常是最有可能导致错误的情况，因此在测试过程中应特别关注这些值。例如，构造一个不存在长度大于等于3的自环，验证<code>queryLeastMoments</code>的正确性。</li>
<li>随机值：使用随机生成的测试数据来测试程序。通过生成大量的随机数据来覆盖各种情况和可能的输入组合，利用评测机。</li>
</ol>
<h2 id="对OK测试的思考"><a href="#对OK测试的思考" class="headerlink" title="对OK测试的思考"></a>对OK测试的思考</h2><h5 id="OK测试的作用"><a href="#OK测试的作用" class="headerlink" title="OK测试的作用"></a>OK测试的作用</h5><ol>
<li>OK测试可以帮助开发人员更好地理解需求规格，并在开发过程中发现规格中可能存在的问题或矛盾。通过对规格中的每个要求都进行OK测试，可以确保程序实现了所有规格要求，同时也能够提高开发人员对规格的理解和准确性。</li>
<li>OK测试提供了一种客观、可验证的方法来检查代码实现是否符合规格要求。它能够帮助开发人员确保代码的正确性，并减少因为规格不清晰或错误而导致的问题。</li>
<li>OK测试可以提高代码的可维护性。由于OK测试要求开发人员明确规格要求和实现的一致性，因此可以帮助减少代码中的冗余和不必要的复杂性，使得代码更易于理解和维护。</li>
</ol>
<h5 id="改进和建议"><a href="#改进和建议" class="headerlink" title="改进和建议"></a>改进和建议</h5><ol>
<li>提高OK测试的覆盖率。为了发现更多的问题和缺陷，需要尽可能覆盖更多的规格要求。这可以通过增加测试用例、考虑不同的输入组合来实现。</li>
<li>自动化测试。将OK测试自动化可以减少测试成本和人力成本，并提高测试效率和准确性。可以使用现有的自动化测试框架来实现。</li>
</ol>
<h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><h5 id="规格与实现分离"><a href="#规格与实现分离" class="headerlink" title="规格与实现分离"></a>规格与实现分离</h5><p> 规格与实现分离的目的是为了降低程序的复杂度，提高程序的可读性和可维护性。通过将规格描述与程序实现分离，可以使得程序的设计更加模块化、可重用，更容易理解和修改。此外，规格与实现分离还可以提高程序的测试效率和质量，因为规格描述可以作为测试用例的基础，而不必依赖于程序的具体实现。</p>
<h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5><ul>
<li>从0到深入了解JML：JML是一种允许开发人员指定程序属性、前置条件、后置条件和不变量的语言。JML提供了一种结构化和规范的方法来定义程序的预期行为。学习JML使我能够编写更可靠和易于维护的代码。</li>
<li>应用JML编写程序，整个单元通过迭代式开发，依赖于大量JML语言完成一个社交网络的模拟。回首整个单元不断发现问题，debug成功的过程，其实是一件很有成就感的事情。</li>
</ul>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Object-Oriented</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading and Questions about The Building Method of Modern Software Engineering</title>
    <url>/2024/03/08/Reading%20and%20Questions%20about%20The%20Building%20Method%20Modern%20Software%20Engineering/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">这个作业属于哪个课程</td>
<td><a class="link" href="https://bbs.csdn.net/forums/buaa-ase2024">2024年北航敏捷软件工程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">这个作业的要求在哪里</td>
<td><a class="link" href="https://bbs.csdn.net/topics/618159304">个人作业：阅读和提问 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">我在这个课程的目标是</td>
<td>学习并实践软件工程，提升自己的工程能力和团队协作能力</td>
</tr>
<tr>
<td align="left">这个作业在哪个具体方面帮助我实现目标</td>
<td>培养自己的思考能力，去形成自己分析问题、解决问题的思路</td>
</tr>
</tbody></table>
<h4 id="阅读提问"><a href="#阅读提问" class="headerlink" title="阅读提问"></a>阅读提问</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><blockquote>
<p>向进度落后的项目中增加人员，会让项目更加落后。	–《人月神话》</p>
</blockquote>
<p>我在书中第1.2.3节，第15页上方看到了这句话。在网上查找资料后我了解到，增加人员仍会使项目更加落后的原因是：</p>
<ul>
<li><strong>“关键时间”的浪费</strong>：新人对项目不了解，所以项目组需要抽调人员培训新人，这样不仅新人自己帮不上忙，还要浪费浪费项目组成员的关键时间</li>
<li><strong>“沟通时间”的增加</strong>：新加的人员需要增加额外的沟通来消除彼此之间对项目的不同认识，<strong>一个团队内部的沟通方式总数=n*(n-1)/2</strong></li>
<li><strong>“等待时间”的消耗</strong>：在实际项目中，总项目已经细分为分项目（一个人的工作量），分项目往往具有先后顺序，所以新加进来的人发挥不了作用，造成了等待时间的消耗</li>
</ul>
<p>我的问题是 如果现实中互联网企业发生了项目进度落后的情况（通常由于一些成员个人的原因），团队leader应该在不增加人员的情况下采取什么措施保证项目进度呢，这些措施是否有效呢？</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><blockquote>
<p>结对编程中有两个角色：</p>
<ol>
<li>驾驶员（Driver）：控制键盘输入</li>
<li>领航员（Navigator）：起到领航、提醒的作用</li>
</ol>
<p>这两个角色是可以互换的……</p>
</blockquote>
<p>我在书中4.5.1节，第79页上方看到了这一段话。我了解到在越野赛车中，驾驶员和领航员的身份往往不轻易互换，因为驾驶员的驾驶技术往往更胜一筹，而领航员的领航技术往往也是更强的。但是在实际的结对编程中，两人是不断变化角色的，因为结对编程是一个相互磨合的渐进过程，不论谁的资历等级更高抑或是设计编程的能力更强，双方都拥有平等的决策权力，所以这样的比喻（越野赛车的驾驶和领航员）我认为不妥当。</p>
<h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><blockquote>
<p>1969年代，程序员Melvin Conway就总结了一个康威规律：</p>
<p>一个机构设计出来的系统，它的体系结构注定会沿用这个机构的内部交流模式。</p>
</blockquote>
<p>我在书中第5.2.10节，第95页上方看到了这一段话。这句话大概意思是说组织内部的工作和交流方式，会极大地影响系统的设计。但是这会带来一个问题，团队模式不会轻易改变，但是系统的架构或者模式可能会随着时间推移不断优化和完善，这样一来可能导致组织架构和系统架构的失配，从这个角度来看这个规律变得不正确了，这是否是一种悖论或者”陷阱“？</p>
<h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><blockquote>
<p>团队成员往往各抒己见，争执地不亦乐乎，但是最后谁也说服不了谁，还有一些人觉得无从下手，干脆不参加讨论。在这种情况下，可以考虑通过Wideband Delphi方法来做到快速沟通并达到意见的一致。</p>
</blockquote>
<p>我在书中8.6.2节，第171页上方看到这一段话。这一方法反映了生活中遇到的团队意见不一致的问题，并在后面给出了解决方法。我的问题是，Wideband Delphi方法确实一定程度上统一了所有人意见，但这些意见是否大概率是主持人自己的意见呢？作为一个moderator，他在主持讨论的时候会慢慢地说服我们他自己的意见，所以我对此抱有疑问，如果使用这个方法最终统一的意见大部分取决于主持人，就达不到讨论和统一意见的意义了。除此之外，我认为某些情况下人与人之间理解的差异还是很大的，这种情况该如何达到共识呢，或者如何界定共识的标准？</p>
<h5 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h5><blockquote>
<p>原则2</p>
<p>软件工程师应以其客户和雇主利益最大化的方式做事，与公众利益保持一致。</p>
</blockquote>
<p>我在书中17.8节，第407页看到了这段话。这一部分主要在讲软件工程师的职业道德，我的疑问是某些情况下雇主和客户的利益可能与公众利益冲突，比如用户隐私相关的事务。在这种情况下，要如何平衡各方利益呢？</p>
]]></content>
      <categories>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>Software engineering</tag>
      </tags>
  </entry>
</search>
